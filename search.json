[{"title":"A Path to Game Development","url":"/2015/01/12/NSLog/APathtoGameDevelopment/","content":"<p>转载自<a href=\"http://www.gamedev.net/page/resources/_/technical/game-programming/how-do-i-make-games-a-path-to-game-development-r892\">此处</a>.<br>10多年前的文章了，但我个人认为目前仍然适用。学习必须摒弃浮躁，贯穿始终。</p>\n<span id=\"more\"></span>\n\n<hr>\n<p>How do I make games? A Path to Game Development<br>By <a href=\"http://www.gamedev.net/user/6-dave-astle/\">Geoff Howland</a> | Published Jan 05 2000 09:52 AM in <a href=\"http://www.gamedev.net/page/resources/_/technical/game-programming/\">Game Programming</a>    </p>\n<p>When I talk to people looking to get into game development some of the first things I often hear fall along the lines of, &quot;How do I make games?&quot; or &quot;I want to make a game like Quake/Everquest/Starcraft and…&quot;. The first is just way out of the realm of answerability, as there are too many aspects to possibly go into, and each of those components can be infinitely complex.</p>\n<p>The second, however, falls into just being unrealistic in expectations. Starcraft, Everquest and Quake were all made by teams of professionals who had budgets usually million dollar plus. More importantly though, all of these games were made by people with a lot of experience at making games. They did not just decide to make games and turned out mega-hit games, they started out small and worked their way up. This is the point that anyone who is interested in getting into game development needs to understand and repeat, repeat, repeat until it becomes such a part of your mindset that you couldn&#39;t possibly understand life without this self evident, universal truth.</p>\n<p>Until you understand that all skills in game development are learned by experience, (meaning to start very small and working your way up) you will be absolutely doomed to never finish your projects. Even the infinitesimal number of teams that do manage to finish a non-trivial project before they have made any smaller ones have to learn incrementally, it just takes them many times longer than if they had started out with smaller projects.</p>\n<!-- more -->\n\n<h2 id=\"So-where-do-I-start\"><a href=\"#So-where-do-I-start\" class=\"headerlink\" title=\"So where do I start?\"></a>So where do I start?</h2><h3 id=\"Tetris\"><a href=\"#Tetris\" class=\"headerlink\" title=\"Tetris.\"></a>Tetris.</h3><p>Tetris is the perfect game to begin your journey on the path to becoming an able bodied game developer. Why? Because Tetris contains the all the elements found in every game, and can be done with just about the least amount of work. Also, you don&#39;t have to be an artist to make a good looking Tetris game. Anyone who can draw a block, which is everyone with a paint program, can make a commercial quality version of Tetris.</p>\n<p>This is another one of the big benefits of starting with Tetris. Not only can you make a fully functioning game, that is fun and addictive, but it looks basically just as good as any commercial version done of it. Blocks are blocks no matter who draws them, and tetraminos (the shapes used in Tetris) are all just a collection of four blocks.</p>\n<p>Tetris has all the individual components that ALL games share in common. It has a game loop (the process of repeating over and over until the game is quit). The game loop reads in input, processes the input, updates the elements of the game (the falling tetraminos), and checks for victory/loss conditions.</p>\n<p>Every single game you will ever make does all of these things, so learning the process and actually implementing it is extremely important. After you have completed this the first time, it will give you an insight into how hard it will be and how long it may take on future games. Without having done this all the way, at least once, you will never fully have a proper grasp of each of the elements. When you have larger projects, there will be more unknowns that you can&#39;t judge for in complexity and time. If you don&#39;t even fully understand the entire process because you have failed to DO it, you will likely be helpless to create schedules or estimate times properly and will most likely not succeed at the endeavor.</p>\n<h2 id=\"What-39-s-Next\"><a href=\"#What-39-s-Next\" class=\"headerlink\" title=\"What&#39;s Next?\"></a>What&#39;s Next?</h2><p>After you have totally, completely, absolutely finished your version Tetris, you are ready for your next challenge:</p>\n<h3 id=\"Breakout\"><a href=\"#Breakout\" class=\"headerlink\" title=\"Breakout.\"></a>Breakout.</h3><p>Breakout is also a similar game, but it adds in much more advanced collision detection than was necessary in Tetris. You will also need to add some simple deflection physics of the ball rebounding off different portions of the paddle and the blocks.</p>\n<p>Level layout also becomes an issue in Breakout, and in order to have more than one level you will need to come up with a way to save the maps. This deals with another component found in all larger games, which is saving and loading resources and switching levels.</p>\n<h3 id=\"Pac-Man\"><a href=\"#Pac-Man\" class=\"headerlink\" title=\"Pac-Man\"></a>Pac-Man</h3><p>After you finish your Breakout masterpiece you should move on to making Pac-Man.Pac-Man is an evolutionary step because it adds in the element of enemy artificial intelligence (AI). You may not have been aware of this, but in the original Pac-Man the four different ghosts had different goals to trying to defeat you as a team. The aggressor would try to follow the shortest path to you, making you directly avoid him. The interceptor would try to go to a junction that was closest to where you would have to move to avoid the aggressor. A second interceptor would try to stay more towards the middle and try to cut you off from using the tunnel through the sides. The last ghost would sort of wander aimlessly about which often kept him staying in a section you needed to finish the map.</p>\n<p>This kind of detailed AI was quite advanced for games of that time, and should give you a good challenge for your first game with enemy AI.</p>\n<p>Pac-Man also increases the complexity of maps, and adds a good deal more flexibility for using sounds, as sound was certainly a crucial elements to the success of Pac-Man. (After all, what would Pac-Man be without some sort of &quot;wakka-wakka&quot; sound?)</p>\n<h3 id=\"Side-scroller\"><a href=\"#Side-scroller\" class=\"headerlink\" title=\"Side scroller\"></a>Side scroller</h3><p>The last game I suggest you should create is a side scroller, such as Super Mario Brothers, where you can jump on multiple platforms, shoot, duck and interact with enemies. As there is added art involved in this game, I would suggest looking in to using SpriteLib for some free and easy to use artwork, which is available at: ~~(<a href=\"http://www.flyingyog.../spritelib.html\">http://www.flyingyog.../spritelib.html</a>)</p>\n<p>Side scrollers introduce the possibility of added enemy AI complexity through the use of enemy bosses which have patterns you must learn to beat, as well an added screen complexity. Now you must make a screen that is capable of scrolling in at least two directions, if not four, and deal with screen clipping, which can have a bit of a learning curve. You must also work on the physics of any jumping, bouncing of the character or shooting projectiles.</p>\n<p>There will additionally need to be a lot more enemies than before, and you will need to keep track of their current game state (alive/dead, active/inactive), by whether they are on the screen or have already been dealt with. The level complexity and map/character storage complexity will have also increased and you will most certainly need to make a level editor at this point.</p>\n<p>The level editor should be capable of placing tiles, scrolling through tiles, scrolling over the map, choosing tiles as brushes, cycling through the brushes, cutting and pasting, an undo, and placing enemies. If you decide to skip writing any of these, you will most likely feel sorry about it, and if you have an artist or level designer, they will probably not be very happy with you either (how would YOU feel if you had to go through someone&#39;s text files containing a bunch of numbers and commas to edit a level?). I would also suggest making back ups of previously saved maps, as it is often easier to just back things up by versions, than redrawing them.</p>\n<p>Finally, the side scroller has a real victory condition! When you get to the end of the side scroller, you have actually GONE somewhere, so you can add on a story to progress through the game as well (and don&#39;t forget some sort of fireworks on the screen for the end of a level, so that the player has a sense of accomplishment and a REAL show of fireworks for beating the game… merely putting the words &quot;You Have Won!&quot; on the screen when a player has spent endless hours trying to beat your game is anti-climatic).</p>\n<h2 id=\"Get-out-the-Polish\"><a href=\"#Get-out-the-Polish\" class=\"headerlink\" title=\"Get out the Polish...\"></a>Get out the Polish...</h2><hr>\n<p>Finishing a game does not merely mean you get it to a point where it is playable, and then move on, this is not a finished game. A finished game will have an opening screen, a closing screen, menu options (if applicable, at least instructions on how to play and start), introduction screens to playing, reward screens and a score board (where applicable).</p>\n<p>If you couldn&#39;t put your game in an 80&#39;s arcade game and not be able to tell it doesn&#39;t belong just by the modes it goes through (minus the attract mode or demo mode), then your game is not finished.</p>\n<p>There is a big difference between a game that is &quot;bare bones&quot;, and a game you have put all the finishing touches on. This difference will be a matter of a couple of days to two weeks (depending on the size of the game). It will get increasingly (sometimes exponentially) more involved as you move from Tetris to Breakout and so on.</p>\n<p>The result, though, will be very important, both to terms of your understanding game development, and your own pride in your work and satisfaction/fulfillment. (Accomplishment does wonders for self-esteem!)</p>\n<p>It&#39;s not easy to show people your game and have to constantly tell them to overlook different things and feel the same as if they picked it up and had no problems moving through it and everything was well presented and complete feeling. Other game developers are a bit more forgiving, since they know the process.</p>\n<p>Most importantly though, you will learn all the details that go into really finishing a game. If you stop at just working gameplay, you will still miss out on the details of wrapping things up, which will leave a blank spot in your mind when trying to plan larger projects in the future.</p>\n<h2 id=\"But-These-Games-are-Stupid\"><a href=\"#But-These-Games-are-Stupid\" class=\"headerlink\" title=\"But, These Games are Stupid!\"></a>But, These Games are Stupid!</h2><hr>\n<p>Actually, these games clearly show the basis for ALL games&#39; gameplay. Throw a fancy 3D interface over a shooter and it&#39;s still a shooter. You could create the same game in a 2D overhead view and the gameplay would be coded exactly the same.</p>\n<p>Is it stupid to be able to make a game with EXACTLY the same controls, responses and enemies as Quake? If you remove the 3D interface, and look at what is really happening from a directly overhead view, does it still seem as out of reach?</p>\n<p>Even so, this is not a beginning project. There are too many elements that need to be developed and refined for a first project, so I strongly urge you to follow the order of games I suggest to gradually build up your understanding of game development. (When you learned how to swim, did you IMMEDIATELY start out with a high dive into the deep water? NO! You start in the shallow end, you learn to dog paddle, and progress from there.)</p>\n<p>One thing that you need to clarify to yourself before starting anything, is what you want out of it. Do you want to make games, or just duplicate the technology in Quake? If all you are interested in is the technology, then skip all the games stuff and get started on graphics technology.</p>\n<p>If you are really interested in making games, then you need to separate your desire to create the next cutting edge, hard core game, and focus on building your ability to do so. The best way to do that is through actually making and (more importantly) finishing games, which is what following this path (or a similar one) will give you experience in.</p>\n<h2 id=\"Be-proud-of-your-games\"><a href=\"#Be-proud-of-your-games\" class=\"headerlink\" title=\"Be proud of your games!\"></a>Be proud of your games!</h2><hr>\n<p>You don&#39;t hear people in college embarrassed about being in college because they don&#39;t have a job yet. You are learning, and making even a simple game is hard, especially if you want it done WELL. This is shown clearly by all the people who have NOT made even simple games but talk about it constantly. Once you have finished a game, consider yourself to have more of a track record than anyone who has not finished a game even if their idea sounds phenomenal and like it&#39;s up there with the latest cutting edge games. If you can&#39;t play it, it&#39;s not a game.</p>\n<p>When you have a finished product you can show, you need to accept that for what it is, not what it isn&#39;t or compare it to people with 5+ years of experience and million dollar budgets who work on games full time.</p>\n<h2 id=\"I-made-my-game-now-where-39-s-my-Ferrari\"><a href=\"#I-made-my-game-now-where-39-s-my-Ferrari\" class=\"headerlink\" title=\"I made my game, now where&#39;s my Ferrari?\"></a>I made my game, now where&#39;s my Ferrari?</h2><hr>\n<p>Sorry, one game, two games, five games probably won&#39;t cut it. Last year there were 3,500 games released on the PC, and only a few handfuls made back a large portion of cash. Most of those that did weren&#39;t made by small groups who were self-funded, they were funded by large publishers and probably had multi-million dollar budgets, and definitely near or well over million dollar advertising campaigns. This isn&#39;t a world you can&#39;t join though, it just takes a good deal of time and experience and track record of making quality games, that hopefully sell well, to give publishers confidence in your team, so that they will entrust you with this kind of financial responsibility.</p>\n<p>However, there is more to making a living of games than the multi-million dollar budgets and I strongly suggest you take a look at the other things as well. There is nothing bad or embarrassing about making budget games, they can be just as or more fun than the high budget commercial games, and it is a lot easier to get publisher to trust you with smaller budgets. On top of that, you don&#39;t have to spend years working on the same project, and if it doesn&#39;t go over well, you don&#39;t have to feel as much loss with it.</p>\n<p>Just have an understanding of what you really want out of making games and then concentrate on making that come true.</p>\n<hr>\n<p><strong>About the Author(s)</strong><br>Geoff Howland is the owner of Lupine Games as well as being the lead programmer, business manager and handling coordination of development for all projects. He has successfully brought his company from a single person operation to ten people and negotiated two signed games within a year. In addition to developing games he has also been an active member in the game developer community writing a number of articles discussing game design and business issues, as well as being on the Advisory Board for the Independent Games Festival. You can reach him at&lt;&quot;<a href=\"mailto:&#x67;&#104;&#111;&#x77;&#x6c;&#x61;&#110;&#100;&#x40;&#x6c;&#117;&#x70;&#x69;&#110;&#x65;&#103;&#97;&#109;&#101;&#115;&#x2e;&#99;&#x6f;&#x6d;\">&#x67;&#104;&#111;&#x77;&#x6c;&#x61;&#110;&#100;&#x40;&#x6c;&#117;&#x70;&#x69;&#110;&#x65;&#103;&#97;&#109;&#101;&#115;&#x2e;&#99;&#x6f;&#x6d;</a>&quot;&gt; if you have any comments on his article.</p>\n","categories":["NSLog"]},{"title":"丹泽尔·华盛顿：Fall Forward","url":"/2015/05/01/NSLog/Fall%20Forward/","content":"<h4 id=\"Nothing-in-life-is-worthwhile-unless-you-take-risks\"><a href=\"#Nothing-in-life-is-worthwhile-unless-you-take-risks\" class=\"headerlink\" title=\"Nothing in life is worthwhile unless you take risks.\"></a>Nothing in life is worthwhile unless you take risks.</h4><p>Nothing.<br>“There is no passion to be found playing small - in settling for a life that is less than the one you are capable of living&quot;.<br>Make sure you have something to fall back on? NO.<br>If i am going to fall,I dont want to fall back on anything, except my faith.<br>I want to fall forward.<br>i figure at least this way i&#39;ll see what i am about to hit.<br>Fall forward.<br>Every failed experiment is one setp closer to success.<br>You&#39;ve got to take risks.</p>\n<span id=\"more\"></span>\n<h4 id=\"You-will-fail\"><a href=\"#You-will-fail\" class=\"headerlink\" title=\"You will fail.\"></a>You will fail.</h4><p>You will fail at some point in your Life,accepte it.<br>You will lose.<br>You will embarrass yourself.<br>You will  suck  at something.<br>There is no doubt about it.<br>But You will not quit,You will not fall back.<br>DO You have the guts to fail.<br>If You did not fail,You are  not even trying.<br>To get something you never had,you have to do something you  never did.<br>The world need you.<br>You will never see a U-Haul behind a hearse.<br>So,there is nothing to lose.</p>\n<h4 id=\"Failure-is-the-best-way-to-figure-out-where-you-are-going\"><a href=\"#Failure-is-the-best-way-to-figure-out-where-you-are-going\" class=\"headerlink\" title=\"Failure is the best way to  figure out where you are going.\"></a>Failure is the best way to  figure out where you are going.</h4><p>Being taking risks, being  willing to fail.<br>It is about knowing what you know,and what you do not know.<br>It is about open to people,and to idea.<br>Begin from slowly risks,take small steps,to overcome your fears.<br>Ultimately your heart will flood  with love.</p>\n<p>Open to life,Define yourself.</p>\n<blockquote>\n<p>Penn Commencement Address given Monday, May 16, 2011 by Denzel Washington, Academy Award-winning and Tony Award-winning actor and director.</p>\n</blockquote>\n","categories":["NSLog"]},{"title":"the big idea——关于面向对象","url":"/2015/05/14/NSLog/the%20big%20idea%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","content":"<p>编程语言就两种，一种没人用，一种被人骂。<br>在所有社区，论坛，讨论群里，几乎每天都可以看到一些程序员关于XX是最好语言的互喷和自喷<br>为什么大家会边码边骂<br>其他人我不知道，就我自己而言：我觉得多半都起源于码代码的思路的和语言本身的思想不吻合<br>当想实现某功能时，每个程序员脑袋中都有一条思路，或基于知识或基于常识<br>最理想的状况是我们思路中的逻辑和模型都能非常想当然地用语言的特性表达出来，如同生活中说话聊天那么自然<br>然而通常情况下，这一切都是想当然<br>敲出来的代码受限于所使用的语言的特性，也许在我们脑海中一个简单的东西，在某编程语言的特性下需要我们绕很多弯才能达到我们想要的结果<br>而这个实现的过程，因为这些受限于语言的十八弯，给大脑徒增了很多多余的思考<br>这些思考是多余的是因为 它们只是为了填补编程语言和我们的思路中的鸿沟<br>并不是直接解决我们的问题<br>当这种多余的问题在码代码的过程中出现的很多时，边码边喷也很说得过去</p>\n<p>这个问题可能也是无法解决的 只能妥协<br>妥协就是thinking in XX。理解所使用的语言，以它的视角去思考。<br>thinking in C++<br>thinking in Java<br>大概也就是这个意思</p>\n<p>编程语言从面向过程，到面向对象<br>目的当然就是语言的自然化<br>改变的也正是思考的角度<br>想想似乎也很简单<br>“对象”更直接了当地抽象现实生活中的“模型” 更符合思考方式</p>\n<p>学习计算机的时候，每个老师都会强调“面向对象”<br>对象是什么balabala<br>面向对象3要素balabala</p>\n<p>关于什么是“对象” 每个人都有自己的理解<br>前几天我在网上搜关于HTTP的东西，却意外看到一些关于对象的资料，颇为耳目一新，来自Alan kay(面向对象之父)。<br>那么Alan kay概念里的对象是什么呢？用他自己的话来说：</p>\n<blockquote>\n<p>I thought of objects being like biological cells and/or individual computers on a network, only able to communicate with messages (so messaging came at the very beginning -- it took a while to see how to do messaging in a programming language efficiently enough to be useful).</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things.</p>\n</blockquote>\n<p>Alan Kay不止一次强调“对象”只是个lesser idea，真正的big idea在于“消息”<br>消息即对象之间的信息传递。</p>\n<blockquote>\n<p>I’m sorry that I long ago coined the term “objects” for this topic because it gets many people to focus on the lesser idea. The big idea is “messaging” – that is what the kernal of Smalltalk/Squeak is all about ...   </p>\n</blockquote>\n<blockquote>\n<p>The key in making great and growable systems is much more to design how its modules communicate rather than what their internal properties and behaviors should be.</p>\n</blockquote>\n<p>他强调对于可增量的系统而言对象之间信息传递的意义远胜于对象内部的属性如何行为怎样。<br>而我们课堂上所学的却正是：如何定义类，类的属性，类的方法这些less idea。</p>\n<p>消息，消息传递，在加上他之间对对象的举例：<code>I thought of objects being like biological cells and/or individual computers on a network, only able to communicate with messages</code>看到这些，会想到什么呢<br>反正我想到了网络。可能也正因为我是查HTTP才看到这些东西的吧。<br>而事实是，Alan Kay，面向对象之父，SmallTalk(公认的最早的面向对象的语言)的发明人，自己心中真正的面向对象的系统也正是互联网。</p>\n<blockquote><p>To me, one of the nice things about the semantics of real objects is that they are “real computers all the way down (RCATWD)” – this always retains the full ability to represent anything. The old way quickly gets to two things that aren’t computers – data and procedures – and all of a sudden the ability to defer optimizations and particular decisions in favour of behaviours has been lost.<br><br><br>In other words, always having real objects always retains the ability to simulate anything you want, and to send it around the planet. If you send data 1000 miles you have to send a manual and/or a programmer to make use of it. If you send the needed programs that can deal with the data, then you are sending an object (even if the design is poor).<br><br><br>And RCATWD also provides perfect protection in both directions.<em>We can see this in the hardware model of the Internet (possibly the only real object-oriented system in working order).</em><br><br><br>You get language extensibility almost for free by simply agreeing on conventions for the message forms.<br>My thought in the 70s was that the Internet we were all working on alongside personal computing was a really good scalable design, and that we should make a virtual internet of virtual machines that could be cached by the hardware machines. It’s really too bad that this didn’t happen.<br><br><br> If ‘real objects’ are RCATWD, then each object could be implemented using the programming language most appropriate for its intrinsic nature, which would give new meaning to the phrase ‘polyglot programming.’</p><footer><strong>A to Z of programming languages: Smalltalk-80</strong><cite><a href=\"http://www.computerworld.com.au/article/352182/z_programming_languages_smalltalk-80/?\">We talk to Alan Kay, co-inventor of the Smalltalk family of languages, and a hero of personal computing in many respects</a></cite></footer></blockquote>\n\n<p><em>a Web service is like an object</em><br>这些“object”之间的交流依仗的正是the big idea--message<br>网络协议栈（tcp/ip）定义了这些“object”的消息传递方式，而可靠的消息传递是一切网络奇迹的基础<br>这就是the big idea，object皆有不同但是只要有互相可认知的消息传递，其他一切都好商量<br>这就好像人类，语言是基本的信息传递方式，有了语言，有了沟通，那么一切皆有可能</p>\n<p>粗略的类比一下，看看为什么*a Web service is like an object *<br>Objective-C中的消息传递是这样：<br><code>[Jack saySomething:@&quot;hello&quot;];</code><br>向对象jack发送消息saySomething，参数是@“hello”，<br>改成URL的格式可能是这样：<br><code>www.xxx.com/jack/saySomething?say=hello</code><br>发送消息的结果都是得到某响应（获取到返回的数据）<br>不同的是前者对象在内存中某地址处，后者在网络的某主机上</p>\n<p>这么看起来，现在的web service就有点像思想先锋们十几年前关于面向对象的设想，不同的地方，但是因为一致的消息机制（messaging，api），实现不同功能的对象（service）之间相互发送消息，相互转发，以协作完成工作。</p>\n","categories":["NSLog"],"tags":["object"]},{"title":"Android Studio利用Graddle创建Layout子文件夹","url":"/2015/10/26/Android/Graddle/Graddle%E5%88%9B%E5%BB%BALayout%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9/","content":"<p>打开build.graddle</p>\n<figure class=\"highlight sml\"><table><tr><td class=\"code\"><pre><span class=\"line\">sourceSets &#123;</span><br><span class=\"line\">    main &#123;</span><br><span class=\"line\">        res.srcDirs = [</span><br><span class=\"line\">                <span class=\"symbol\">&#x27;src</span>/main/res/layouts/home&#x27;,</span><br><span class=\"line\">                <span class=\"symbol\">&#x27;src</span>/main/res/layouts&#x27;,</span><br><span class=\"line\">                <span class=\"symbol\">&#x27;src</span>/main/res&#x27;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将杂乱无章的</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"code\"><pre><span class=\"line\">layout</span><br><span class=\"line\">  -- personal_detail.xml</span><br><span class=\"line\">  -- personal_other.xml</span><br><span class=\"line\">  -- address1.xml</span><br><span class=\"line\">  -- address2.xml</span><br></pre></td></tr></table></figure>\n<p>转变为：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"code\"><pre><span class=\"line\">layout</span><br><span class=\"line\">-- layout_personal</span><br><span class=\"line\">   -- personal_detail.xml</span><br><span class=\"line\">   -- personal_other.xml</span><br><span class=\"line\">--layout_address</span><br><span class=\"line\">  -- address1.xml</span><br><span class=\"line\">  -- address2.xml</span><br></pre></td></tr></table></figure>\n<p>需要注意的是：</p>\n<ol>\n<li>此目录结构仅在项目的Project View显示。</li>\n<li>每个layout的子文件夹的xml文件都应放在命名为layout的文件夹中。</li>\n</ol>\n<p>所以正确结构为：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"code\"><pre><span class=\"line\">layout</span><br><span class=\"line\">-- layout_personal</span><br><span class=\"line\">   -- layout</span><br><span class=\"line\">       -- personal_detail.xml</span><br><span class=\"line\">       -- personal_other.xml</span><br><span class=\"line\">--layout_address</span><br><span class=\"line\">  -- layout</span><br><span class=\"line\">      -- address1.xml</span><br><span class=\"line\">      -- address2.xml</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://stackoverflow.com/questions/4930398/can-the-android-layout-folder-contain-subfolders\">参考资料</a></p>\n","categories":["Android","Graddle"],"tags":["graddle"]},{"title":"Webpack的简单使用","url":"/2020/10/26/Front/Webpack/webpack/","content":"<blockquote>\n<p>本质上，webpack 是一个现代 <em>JavaScript</em>应用程序的静态模块<em>打包器</em>(module bundler)。当 webpack 处理应用程序时，它会<em>递归地构建一个依赖关系图</em>(dependency graph)，其中包含应用程序需要的每个模块，然后将所有<em>这些模块打包成一个或多个 bundle</em>。</p>\n</blockquote>\n<p>阅读理解：javascript，打包器，递归构建依赖关系图，然后打包成bunlde。<br>简言之：javasript模块 =&gt; 递归处理 =&gt; bundle</p>\n<p>webpack有4个基本的东西，对照着这3个环节</p>\n<ul>\n<li>Entry<br>入口，javasript入口模块，即告诉webpack从哪一个javasript模块来作为递归构建其内部依赖图的开始 </li>\n<li>Output<br>出口，即这些javasript模块打包成的一个或多个bundle</li>\n<li>Loaders<br>在模块的递归处理中，webpack只处理javasript模块。那么非javasript模块呢，则交给loader，loader帮助webpack将其他非js文件转译成webpack可处理的模块</li>\n<li>Plugins<br>webpack只是一个打包器，负责打包的，其他一概不会。但是在递归处理过程中，所有存在依赖关系的模块都被load进了webpack中，这就相当于搭好了一个舞台。plugins就是这个时候登场的，plugins通过监听webpack提供的各种事件API来扩展功能，改变bundle的输出结果。例如minify压缩，chunk切割。</li>\n</ul>\n<h1 id=\"基础配置\"><a href=\"#基础配置\" class=\"headerlink\" title=\"基础配置\"></a>基础配置</h1><p>webpack 的基础配置文件，是导出一个对象的 JavaScript 文件<br>webpack的一般工作模式也就是在配置文件中，配置该对象的entry，output，loader，plugins，然后执行打包命令</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    mode: <span class=\"string\">&#x27;development&#x27;</span>,</span><br><span class=\"line\">    entry: <span class=\"string\">&#x27;./src/index.js&#x27;</span>,</span><br><span class=\"line\">    <span class=\"built_in\">output</span>: &#123;</span><br><span class=\"line\">        <span class=\"built_in\">path</span>: <span class=\"built_in\">path</span>.resolve(__dirname, <span class=\"string\">&#x27;dist&#x27;</span>),</span><br><span class=\"line\">        filename: <span class=\"string\">&#x27;[name].bundle.js&#x27;</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight ada\"><table><tr><td class=\"code\"><pre><span class=\"line\">webpack <span class=\"comment\">--config [FILENAME.js]</span></span><br></pre></td></tr></table></figure>\n<p>如果配置文件使用的是webpack默认配置文件名<code>webpack.config.js</code>的话也可以直接使用webpack命令</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">webpack</span></span><br></pre></td></tr></table></figure>\n<p>通常，我们会有针对不同环境进行区别配置的需求。例如，开发环境时需要配置开发服务器，生成环境时则需要文件压缩。这时候可以选择导出为一个函数，函数中会带入环境信息，和命令行参数信息，方便我们通过env区分环境，或者通过options区分打包的命令参数：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(env, options)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    entry: <span class=\"string\">&#x27;./src/index.js&#x27;</span>,</span><br><span class=\"line\">    <span class=\"built_in\">output</span>: &#123;</span><br><span class=\"line\">        <span class=\"built_in\">path</span>: <span class=\"built_in\">path</span>.resolve(__dirname, <span class=\"string\">&#x27;dist&#x27;</span>),</span><br><span class=\"line\">        filename: <span class=\"string\">&#x27;[name].bundle.js&#x27;</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"entry\"><a href=\"#entry\" class=\"headerlink\" title=\"entry\"></a>entry</h1><p>入口即一次递归处理的起点模块。</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.<span class=\"built_in\">exports</span> = &#123;</span><br><span class=\"line\">    entry: <span class=\"string\">&#x27;./src/index.js&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>是下面的简写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span>.<span class=\"keyword\">exports</span> = &#123;</span><br><span class=\"line\">    entry: &#123;</span><br><span class=\"line\">        <span class=\"comment\">//入口名: 模块路径</span></span><br><span class=\"line\">        main:<span class=\"string\">&#x27;./src/index.js&#x27;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>入口可以是一个或多个，通常是：每个 HTML 页面都有一个入口起点。单页应用(SPA)：一个入口起点，多页应用(MPA)：多个入口起点。</p>\n<h1 id=\"output\"><a href=\"#output\" class=\"headerlink\" title=\"output\"></a>output</h1><p>出口即webpack打包的bundle输出。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    <span class=\"built_in\">output</span>: &#123;</span><br><span class=\"line\">        <span class=\"built_in\">path</span>: <span class=\"built_in\">path</span>.resolve(__dirname, <span class=\"string\">&#x27;dist&#x27;</span>),</span><br><span class=\"line\">        filename: <span class=\"string\">&#x27;[name].bundle.js&#x27;</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们一般会使用webpack提供的占位符来指示output的文件名，以保证输出文件的唯一性。</p>\n<h1 id=\"Loader\"><a href=\"#Loader\" class=\"headerlink\" title=\"Loader\"></a>Loader</h1><p>webpack只处理javasript。<br>但是我们在代码中会引入比如pug，less，vue等文件，webpack就不认识了；loader拓展了webpack处理多种文件类型的能力，将这些文件转换成浏览器能够渲染的js、css。<br>module.rules允许我们配置模块的匹配规则。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attribute\">module</span>: &#123;</span><br><span class=\"line\">        rules: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test: /\\.js$/,</span><br><span class=\"line\">                use: &#123;</span><br><span class=\"line\">                    loader: <span class=\"string\">&#x27;babel-loader&#x27;</span>,</span><br><span class=\"line\">                    options: &#123;&#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"attribute\">test</span>: /\\.css$/,</span><br><span class=\"line\">                use: [</span><br><span class=\"line\">                    &#123; loader: <span class=\"string\">&#x27;style-loader&#x27;</span> &#125;,</span><br><span class=\"line\">                    &#123; <span class=\"attribute\">loader</span>: <span class=\"string\">&#x27;css-loader&#x27;</span> &#125;</span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>test是一个正则表达式，匹配不同的文件类型；<br>use表示匹配了这个文件后调用什么loader来处理，当有多个loader的时候，use就需要用到数组。<br>多个loader支持链式传递，能够对资源进行流水线处理，上一个loader处理的结果传递给下一个loader继续处理；采用编写时从右到左，从下到上的优先级顺序；在上面配置代码中对css的处理就遵从了这个优先级，css-loader先处理，处理好了再给style-loader；因此我们写loader的时候也要注意前后顺序。</p>\n<p>常用的loader及文档可见<a href=\"https://webpack.js.org/loaders/\">webpack官网</a>。</p>\n<h1 id=\"Plugins\"><a href=\"#Plugins\" class=\"headerlink\" title=\"Plugins\"></a>Plugins</h1><p>插件，扩展webpack的功能。</p>\n<p>通常每一个plugin都有一个自己的配置文档。使用也很简单，例如<code>clean-webpack-plugin</code>插件<br>安装，</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">npm</span> i -D clean-webpack-plugin</span><br></pre></td></tr></table></figure>\n<p>然后在plugins属性中配置，</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; CleanWebpackPlugin &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">module</span>.<span class=\"built_in\">exports</span> = &#123;</span><br><span class=\"line\">    plugins: [</span><br><span class=\"line\">        <span class=\"keyword\">new</span> CleanWebpackPlugin(),</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>常用的有<br><code>html-webpack-plugin</code>用于生成html页面；<br><code>clean-webpack-plugin</code>用于在打包前清理上一次项目生成的bundle文件，它会根据output.path自动清理文件夹；<br><code>webpack-bundle-analyzer</code>用于生成 bundle 的模块组成图，显示所占体积;</p>\n<p>常用的Plugins及文档可见<a href=\"https://webpack.js.org/plugins/\">webpack官网</a>。</p>\n<p>这里是对webpack4个配置概念的最基础认识。更多的认识还有待实践和学习。</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/147787134\">Webpack配置全解析（基础篇）</a><br><a href=\"https://zhuanlan.zhihu.com/p/176840425\">Webpack配置全解析（优化篇）</a><br><a href=\"https://juejin.cn/post/6844904094281236487#heading-2\">再来一打Webpack面试题</a><br><a href=\"https://zhuanlan.zhihu.com/p/30669007\">Webpack HMR 原理解析</a></p>\n","categories":["Front","Webpack"],"tags":["webpack"]},{"title":"Webpack传统多页面应用","url":"/2020/11/03/Front/Webpack/%E4%BB%8E0%E6%90%AD%E5%BB%BA%E4%BC%A0%E7%BB%9F%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%B7%A5%E7%A8%8B/","content":"<p>要开发一个传统多页面应用，使用webpack工程化。</p>\n<h1 id=\"项目新建\"><a href=\"#项目新建\" class=\"headerlink\" title=\"项目新建\"></a>项目新建</h1><figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    mode: <span class=\"string\">&#x27;development&#x27;</span>,</span><br><span class=\"line\">    entry: <span class=\"string\">&#x27;./src/index.js&#x27;</span>,</span><br><span class=\"line\">    <span class=\"built_in\">output</span>: &#123;</span><br><span class=\"line\">        <span class=\"built_in\">path</span>: <span class=\"built_in\">path</span>.resolve(__dirname, <span class=\"string\">&#x27;dist&#x27;</span>),</span><br><span class=\"line\">        filename: <span class=\"string\">&#x27;[name].bundle.js&#x27;</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>开始扩展。</p>\n<h1 id=\"多页面\"><a href=\"#多页面\" class=\"headerlink\" title=\"多页面\"></a>多页面</h1><h1 id=\"Pug\"><a href=\"#Pug\" class=\"headerlink\" title=\"Pug\"></a>Pug</h1><h2 id=\"pug-loader\"><a href=\"#pug-loader\" class=\"headerlink\" title=\"pug-loader\"></a>pug-loader</h2><h2 id=\"pug-html-loader\"><a href=\"#pug-html-loader\" class=\"headerlink\" title=\"pug-html-loader\"></a>pug-html-loader</h2><p>区别，pug-loader，载入图片资源等需要<code>require(&#39;./image.png&#39;)</code><br>而pug-html-loader,可以配合html-loader直接处理资源载入，html-loader会将<code>&lt;img src=&quot;image.png&quot;&gt;</code>，替换为<code>require(&#39;./image.png&#39;)</code>地址。</p>\n<h1 id=\"去除未使用的css\"><a href=\"#去除未使用的css\" class=\"headerlink\" title=\"去除未使用的css\"></a>去除未使用的css</h1><p><a href=\"https://purgecss.com/plugins/postcss.html#installation\">https://purgecss.com/plugins/postcss.html#installation</a></p>\n<h1 id=\"dev-server\"><a href=\"#dev-server\" class=\"headerlink\" title=\"dev-server\"></a>dev-server</h1><p>dev-server hot-reload只监听入口文件，根据入口js的依赖来热更新，因此，想要热更新的都必须引入entry文件。<br>例如，js，css<br>但是通过webpack-html-plugin生成的html文件往往没有引入entry之中，<br>想要监听html的变化并实施刷新浏览器，</p>\n<h2 id=\"解决1-reload-html-webpack-plugin\"><a href=\"#解决1-reload-html-webpack-plugin\" class=\"headerlink\" title=\"解决1.reload-html-webpack-plugin\"></a>解决1.reload-html-webpack-plugin</h2><h2 id=\"解决2-html-webpack-harddisk-plugin\"><a href=\"#解决2-html-webpack-harddisk-plugin\" class=\"headerlink\" title=\"解决2.html-webpack-harddisk-plugin\"></a>解决2.html-webpack-harddisk-plugin</h2><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">plugins:</span> [</span><br><span class=\"line\">  <span class=\"string\">new</span> <span class=\"string\">HtmlWebpackPlugin(</span>&#123;</span><br><span class=\"line\">    <span class=\"attr\">alwaysWriteToDisk:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;<span class=\"string\">)</span>,</span><br><span class=\"line\">  <span class=\"string\">new</span> <span class=\"string\">HtmlWebpackPlugin(</span>&#123;</span><br><span class=\"line\">    <span class=\"attr\">alwaysWriteToDisk:</span> <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">filename:</span> <span class=\"string\">&#x27;demo.html&#x27;</span></span><br><span class=\"line\">  &#125;<span class=\"string\">)</span>,</span><br><span class=\"line\">  <span class=\"string\">new</span> <span class=\"string\">HtmlWebpackPlugin(</span>&#123;</span><br><span class=\"line\">    <span class=\"attr\">alwaysWriteToDisk:</span> <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"attr\">filename:</span> <span class=\"string\">&#x27;test.html&#x27;</span></span><br><span class=\"line\">  &#125;<span class=\"string\">)</span>,</span><br><span class=\"line\">  <span class=\"string\">new</span> <span class=\"string\">HtmlWebpackHarddiskPlugin()</span></span><br><span class=\"line\">]  </span><br></pre></td></tr></table></figure>\n<h2 id=\"解决3\"><a href=\"#解决3\" class=\"headerlink\" title=\"解决3.\"></a>解决3.</h2><p>So while I was testing I realized that index.html would not hot reload! After searching for a bit I finally came across this helpful answer, which will require one more loader to make our hacky solution come to life, and one more plugin to prevent our hacky solution from going into production.</p>\n<p>Basically to make Webpack hot reload our HTML we need to make it part of our dependency tree by requiring it in one of our files. In order to do this, we will be using the raw-loader loader, which pulls our HTML into javascript as a string, but additionally will do exactly what we need: add the HTML to the dependency tree.</p>\n<p>So lets add the loader to our dev config:</p>\n<p>First we install with</p>\n<figure class=\"highlight q\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --<span class=\"built_in\">save</span>-<span class=\"built_in\">dev</span> raw-loader</span><br></pre></td></tr></table></figure>\n<p>Then we can add it:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"attribute\">loaders</span>: [&#123;</span><br><span class=\"line\">      test: /\\.css$/,</span><br><span class=\"line\">      loaders: [<span class=\"string\">&#x27;style&#x27;</span>, <span class=\"string\">&#x27;css&#x27;</span>]</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">      <span class=\"attribute\">test</span>: /\\.html$/,</span><br><span class=\"line\">      loader: <span class=\"string\">&quot;raw-loader&quot;</span> // loaders: [<span class=\"string\">&#x27;raw-loader&#x27;</span>] is also perfectly acceptable.</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"selector-tag\">devServer</span>: &#123;</span><br><span class=\"line\">    <span class=\"attribute\">contentBase</span>: <span class=\"string\">&#x27;./dist&#x27;</span>,</span><br><span class=\"line\">    hot: true</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>This time, when you run webpack, if we require a file that ends in .html, then we will apply the raw-loader loader to it, which adds the HTML to the bundle.</p>\n<p>Now in our currently empty index.js file we can do.</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">require</span><span class=\"params\">(<span class=\"string\">&#x27;./index.html&#x27;</span>)</span></span></span><br></pre></td></tr></table></figure>\n<p>If you were to check now, hot reloading should be working, but also you should realize we just required index.html in our index.js, and then did absolutely nothing with it. We don&#39;t want to do that in production, which is why we will be using the handy dandy DefinePlugin.</p>\n<p>The plugin lets us create a global constant for our entire bundle, which we could name anything, such as DONT_USE_IN_PRODUCTION: true, but more practically, a popular choice that looks a bit more familiar is process.env.NODE_ENV: JSON.stringify(&#39;production&#39;). Why JSON.stringify? Because according to the docs:</p>\n<blockquote>\n<p>If the value is a string it will be used as a code fragment.</p>\n</blockquote>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</span><br><span class=\"line\">      <span class=\"string\">&#x27;process.env.NODE_ENV&#x27;</span>: <span class=\"built_in\">JSON</span>.stringify(<span class=\"string\">&#x27;production&#x27;</span>)</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>and in our index.js we will add a condition</p>\n<figure class=\"highlight isbl\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\"><span class=\"keyword\">if</span></span> (<span class=\"variable\">process.env.NODE_ENV</span> <span class=\"variable\">!</span>== <span class=\"string\">&#x27;production&#x27;</span>) &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">require</span>(<span class=\"string\">&#x27;./index.html&#x27;</span>)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Phew problem solved. In a production build, when we don&#39;t need the index.html as part of the dependency tree, we won&#39;t require index.html, which also means we don&#39;t need the raw-loader.</p>\n<h2 id=\"我的解决\"><a href=\"#我的解决\" class=\"headerlink\" title=\"我的解决\"></a>我的解决</h2><p><a href=\"https://github.com/jantimon/html-webpack-plugin/issues/100\">解决</a><br><a href=\"https://github.com/webpack/webpack-dev-server/issues/426\">解决</a><br>或者</p>\n<p>参考了方案1：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">...</span></span><br><span class=\"line\"> <span class=\"attr\">devServer:</span> &#123;</span><br><span class=\"line\">   <span class=\"attr\">port:</span> <span class=\"number\">8080</span>,</span><br><span class=\"line\">   <span class=\"attr\">contentBase:</span> <span class=\"string\">&#x27;./src&#x27;</span>,</span><br><span class=\"line\">   <span class=\"attr\">watchContentBase:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>直接设置dev-server服务文件监听源代码文件夹的变化，这个可以解决html热更新，但是js，css的热更新会导致图片等资源文件引用的路径问题。</p>\n<p>扩展一下这个方案，监听的还是输出文件夹，只是把html的更新变化，让dev-server写进硬盘</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">devServer</span>: &#123;</span><br><span class=\"line\">    <span class=\"attribute\">contentBase</span>: path.<span class=\"built_in\">join</span>(__dirname, <span class=\"string\">&#x27;dist&#x27;</span>),</span><br><span class=\"line\">    hot: true,</span><br><span class=\"line\">    watchContentBase: true,</span><br><span class=\"line\">    writeToDisk: (filePath) =&gt; &#123;</span><br><span class=\"line\">        return /\\.html$/.<span class=\"built_in\">test</span>(filePath);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>或者：</p>\n<blockquote>\n<p>Warning<br>webpack-dev-server doesn&#39;t write any output files after compiling. Instead, it keeps bundle files in memory and serves them as if they were real files mounted at the server&#39;s root path. If your page expects to find the bundle files on a different path, you can change this with the publicPath option in the dev server&#39;s configuration.</p>\n</blockquote>\n<h1 id=\"外部引用\"><a href=\"#外部引用\" class=\"headerlink\" title=\"外部引用\"></a>外部引用</h1><h1 id=\"全局引用\"><a href=\"#全局引用\" class=\"headerlink\" title=\"全局引用\"></a>全局引用</h1><p>src/index.js</p>\n<figure class=\"highlight capnproto\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> $ <span class=\"keyword\">from</span> <span class=\"string\">&quot;jquery&quot;</span>;</span><br></pre></td></tr></table></figure>\n<p>webpack.config.js</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\"><span class=\"symbol\">  module:</span> &#123;</span><br><span class=\"line\"><span class=\"symbol\">    rules:</span> [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\"><span class=\"symbol\">        test:</span> require.resolve(<span class=\"string\">&quot;jquery&quot;</span>),</span><br><span class=\"line\"><span class=\"symbol\">        loader:</span> <span class=\"string\">&quot;expose-loader&quot;</span>,</span><br><span class=\"line\"><span class=\"symbol\">        options:</span> &#123;</span><br><span class=\"line\"><span class=\"symbol\">          exposes:</span> [<span class=\"string\">&quot;$&quot;</span>, <span class=\"string\">&quot;jQuery&quot;</span>],</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\"><span class=\"symbol\">        test:</span> require.resolve(<span class=\"string\">&quot;underscore&quot;</span>),</span><br><span class=\"line\"><span class=\"symbol\">        loader:</span> <span class=\"string\">&quot;expose-loader&quot;</span>,</span><br><span class=\"line\"><span class=\"symbol\">        options:</span> &#123;</span><br><span class=\"line\"><span class=\"symbol\">          exposes:</span> [</span><br><span class=\"line\">            <span class=\"string\">&quot;_.map|map&quot;</span>,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\"><span class=\"symbol\">              globalName:</span> <span class=\"string\">&quot;_.reduce&quot;</span>,</span><br><span class=\"line\"><span class=\"symbol\">              moduleLocalName:</span> <span class=\"string\">&quot;reduce&quot;</span>,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\"><span class=\"symbol\">              globalName:</span> [<span class=\"string\">&quot;_&quot;</span>, <span class=\"string\">&quot;filter&quot;</span>],</span><br><span class=\"line\"><span class=\"symbol\">              moduleLocalName:</span> <span class=\"string\">&quot;filter&quot;</span>,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">          ],</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>The require.resolve call is a Node.js function (unrelated to require.resolve in webpack processing). require.resolve gives you the absolute path to the module (&quot;/.../app/node_modules/jquery/dist/jquery.js&quot;). So the expose only applies to the jquery module. And it&#39;s only exposed when used in the bundle.</p>\n<h1 id=\"自动引用\"><a href=\"#自动引用\" class=\"headerlink\" title=\"自动引用\"></a>自动引用</h1><p>ProvidePlugin<br>Automatically load modules instead of having to import or require them everywhere.</p>\n","categories":["Front","Webpack"],"tags":["webpack"]},{"title":"Hexo填坑小记","url":"/2020/10/26/Front/Hexo/hexo%E5%B0%8F%E5%9D%91/","content":"<p>一些hexo在升级路上的小坑。</p>\n<span id=\"more\"></span>\n<h2 id=\"hexo-tag-bootstrap-引起的警告\"><a href=\"#hexo-tag-bootstrap-引起的警告\" class=\"headerlink\" title=\"hexo-tag-bootstrap 引起的警告\"></a>hexo-tag-bootstrap 引起的警告</h2><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">SyntaxError</span>: Unexpected token <span class=\"string\">&#x27;&lt;&#x27;</span>                                                                                     </span><br><span class=\"line\">      at wrapSafe (internal/modules/cjs/loader.js:<span class=\"number\">979</span>:<span class=\"number\">16</span>)                                                               </span><br><span class=\"line\">      at Module._compile (internal/modules/cjs/loader.js:<span class=\"number\">1027</span>:<span class=\"number\">27</span>)                                                       </span><br><span class=\"line\">      at <span class=\"built_in\">Object</span>.Module._extensions..js (internal/modules/cjs/loader.js:<span class=\"number\">1092</span>:<span class=\"number\">10</span>)                                         </span><br><span class=\"line\">      at Module.load (internal/modules/cjs/loader.js:<span class=\"number\">928</span>:<span class=\"number\">32</span>)                                                            </span><br><span class=\"line\">      at <span class=\"built_in\">Function</span>.Module._load (internal/modules/cjs/loader.js:<span class=\"number\">769</span>:<span class=\"number\">14</span>)                                                  </span><br><span class=\"line\">      at Module.require (internal/modules/cjs/loader.js:<span class=\"number\">952</span>:<span class=\"number\">19</span>)                                                         </span><br><span class=\"line\">      at <span class=\"built_in\">require</span> (C:\\Users\\Administrator\\blog\\node_modules\\hexo\\lib\\hexo\\index.js:<span class=\"number\">292</span>:<span class=\"number\">23</span>)                                      </span><br><span class=\"line\">      at C:\\Users\\Administrator\\blog\\node_modules\\hexo-tag-bootstrap\\index.js:<span class=\"number\">14</span>:<span class=\"number\">23</span>                                            </span><br><span class=\"line\">      at C:\\Users\\Administrator\\blog\\node_modules\\hexo\\lib\\hexo\\index.js:<span class=\"number\">305</span>:<span class=\"number\">14</span>                                                </span><br><span class=\"line\">      at tryCatcher (C:\\Users\\Administrator\\blog\\node_modules\\bluebird\\js\\release\\util.js:<span class=\"number\">16</span>:<span class=\"number\">23</span>)                               </span><br><span class=\"line\">      at <span class=\"built_in\">Promise</span>._settlePromiseFromHandler (C:\\Users\\Administrator\\blog\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">547</span>:<span class=\"number\">31</span>)    </span><br><span class=\"line\">      at <span class=\"built_in\">Promise</span>._settlePromise (C:\\Users\\Administrator\\blog\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">604</span>:<span class=\"number\">18</span>)               </span><br><span class=\"line\">      at <span class=\"built_in\">Promise</span>._settlePromise0 (C:\\Users\\Administrator\\blog\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">649</span>:<span class=\"number\">10</span>)              </span><br><span class=\"line\">      at <span class=\"built_in\">Promise</span>._settlePromises (C:\\Users\\Administrator\\blog\\node_modules\\bluebird\\js\\release\\promise.js:<span class=\"number\">729</span>:<span class=\"number\">18</span>)              </span><br><span class=\"line\">      at _drainQueueStep (C:\\Users\\Administrator\\blog\\node_modules\\bluebird\\js\\release\\<span class=\"keyword\">async</span>.js:<span class=\"number\">93</span>:<span class=\"number\">12</span>)                         </span><br><span class=\"line\">      at _drainQueue (C:\\Users\\Administrator\\blog\\node_modules\\bluebird\\js\\release\\<span class=\"keyword\">async</span>.js:<span class=\"number\">86</span>:<span class=\"number\">9</span>)                              </span><br><span class=\"line\">      at Async._drainQueues (C:\\Users\\Administrator\\blog\\node_modules\\bluebird\\js\\release\\<span class=\"keyword\">async</span>.js:<span class=\"number\">102</span>:<span class=\"number\">5</span>)                      </span><br><span class=\"line\">      at Immediate.Async.drainQueues [<span class=\"keyword\">as</span> _onImmediate] (C:\\Users\\Administrator\\blog\\node_modules\\bluebird\\js\\release\\<span class=\"keyword\">async</span>.js:<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">5</span>:<span class=\"number\">14</span>)                                                                                                                   </span><br><span class=\"line\">      at processImmediate (internal/timers.js:<span class=\"number\">461</span>:<span class=\"number\">21</span>)                                                                   </span><br><span class=\"line\">&#125; Plugin load failed: %s hexo-tag-bootstrap   </span><br></pre></td></tr></table></figure>\n<p>原因：版本不兼容<br>解决参考<a href=\"https://github.com/wzpan/hexo-tag-bootstrap/issues/8\">github issues</a></p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-tag-<span class=\"symbol\">bootstrap@</span><span class=\"number\">0.1</span><span class=\"number\">.2</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"升级最新的-hexo-版本后报-Cannot-read-property-‘groupBy’-of-undefined\"><a href=\"#升级最新的-hexo-版本后报-Cannot-read-property-‘groupBy’-of-undefined\" class=\"headerlink\" title=\"升级最新的 hexo 版本后报 Cannot read property ‘groupBy’ of undefined\"></a>升级最新的 hexo 版本后报 Cannot read property ‘groupBy’ of undefined</h2><p>原因：最新的Hexo版本移除内部的 lodash 依赖，所有使用了 lodash 函数的情况下可能会报类似的错误，可参考以下解决方式：</p>\n<ol>\n<li>在 hexo 文件目录下安装 loadsh npm install lodash</li>\n<li>进入 scripts 目录（不存在则创建），新建一个 js 文件（名称无所谓），写入如下内容:<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> _ = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;lodash&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">hexo.extend.filter.register(<span class=\"string\">&#x27;template_locals&#x27;</span>, <span class=\"function\"><span class=\"params\">locals</span> =&gt;</span> &#123;</span><br><span class=\"line\">  locals._ = _;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/issues/111\">参考：github Issues</a></p>\n<h2 id=\"stylus-warning\"><a href=\"#stylus-warning\" class=\"headerlink\" title=\"stylus warning\"></a>stylus warning</h2><figure class=\"highlight crmsh\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">node</span><span class=\"title\">:3908</span>) Warning: Accessing non-existent <span class=\"keyword\">property</span><span class=\"title\"> </span>&#x27;lineno&#x27; of module exports inside circular dependency</span><br><span class=\"line\">(Use `<span class=\"keyword\">node</span> <span class=\"title\">--trace-warnings</span> ...` to show where the warning was created)</span><br><span class=\"line\">(<span class=\"keyword\">node</span><span class=\"title\">:3908</span>) Warning: Accessing non-existent <span class=\"keyword\">property</span><span class=\"title\"> </span>&#x27;column&#x27; of module exports inside circular dependency</span><br><span class=\"line\">(<span class=\"keyword\">node</span><span class=\"title\">:3908</span>) Warning: Accessing non-existent <span class=\"keyword\">property</span><span class=\"title\"> </span>&#x27;filename&#x27; of module exports inside circular dependency</span><br><span class=\"line\">(<span class=\"keyword\">node</span><span class=\"title\">:3908</span>) Warning: Accessing non-existent <span class=\"keyword\">property</span><span class=\"title\"> </span>&#x27;lineno&#x27; of module exports inside circular dependency</span><br><span class=\"line\">(<span class=\"keyword\">node</span><span class=\"title\">:3908</span>) Warning: Accessing non-existent <span class=\"keyword\">property</span><span class=\"title\"> </span>&#x27;column&#x27; of module exports inside circular dependency</span><br><span class=\"line\">(<span class=\"keyword\">node</span><span class=\"title\">:3908</span>) Warning: Accessing non-existent <span class=\"keyword\">property</span><span class=\"title\"> </span>&#x27;filename&#x27; of module exports inside circular dependency</span><br></pre></td></tr></table></figure>\n\n<p>使用npm-check把所有的 npm 依赖更新为最新版本，hexo 新版已经对兼容问题做了处理。</p>\n","categories":["Front","Hexo"],"tags":["Hexo"]},{"title":"npm常用辅助包","url":"/2020/11/26/Node.js/npm/npm%E6%8D%A2%E6%BA%90/","content":"<h1 id=\"npm源切换\"><a href=\"#npm源切换\" class=\"headerlink\" title=\"npm源切换\"></a>npm源切换</h1><p>一般使用config命令设置源，但是需要去网上查询源地址，不方便。<br>npm官方源地址：<a href=\"https://registry.npmjs.org/\">https://registry.npmjs.org</a><br>淘宝源地址：<a href=\"https://registry.npm.taobao.org/\">https://registry.npm.taobao.org/</a></p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查看</span></span><br><span class=\"line\">npm <span class=\"built_in\">config</span> <span class=\"built_in\">get</span> registry</span><br><span class=\"line\"><span class=\"comment\">//更新 </span></span><br><span class=\"line\">npm <span class=\"built_in\">config</span> <span class=\"built_in\">set</span> registry https:<span class=\"comment\">//registry.npm.taobao.org/</span></span><br></pre></td></tr></table></figure>\n<p>现在有nrm来维护源地址</p>\n<h2 id=\"辅助包nrm\"><a href=\"#辅助包nrm\" class=\"headerlink\" title=\"辅助包nrm\"></a>辅助包nrm</h2><p>安装nrm</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">npm</span> i -g nrm</span><br></pre></td></tr></table></figure>\n\n<p>查看可用源</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">nrm ls</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\">  npm ---- https:<span class=\"regexp\">//</span>registry.npmjs.org/</span><br><span class=\"line\">  cnpm --- http:<span class=\"regexp\">//</span>r.cnpmjs.org/</span><br><span class=\"line\">* taobao - https:<span class=\"regexp\">//</span>registry.npm.taobao.org/</span><br><span class=\"line\">  nj ----- https:<span class=\"regexp\">//</span>registry.nodejitsu.com/</span><br><span class=\"line\">  npmMirror  https:<span class=\"regexp\">//</span>skimdb.npmjs.com<span class=\"regexp\">/registry/</span></span><br><span class=\"line\">  edunpm - http:<span class=\"regexp\">//</span>registry.enpmjs.org/</span><br></pre></td></tr></table></figure>\n<p>切换源</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">nrm <span class=\"keyword\">use</span> taobao</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"npm包更新\"><a href=\"#npm包更新\" class=\"headerlink\" title=\"npm包更新\"></a>npm包更新</h1><figure class=\"highlight coffeescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">npm</span> i -g <span class=\"built_in\">npm</span>-check</span><br></pre></td></tr></table></figure>\n\n<p>在项目根目录运行</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">npm</span>-check -u</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">? Choose which packages <span class=\"keyword\">to</span> <span class=\"keyword\">update</span>. (Press <span class=\"symbol\">&lt;space&gt;</span> <span class=\"keyword\">to</span> select)</span><br><span class=\"line\"></span><br><span class=\"line\"> Non-Semver Versions less than <span class=\"number\">1.0</span>.<span class=\"number\">0</span>, caution.</span><br><span class=\"line\">&gt;( ) hexo-<span class=\"keyword\">tag</span>-bootstrap  <span class=\"number\">0.1</span>.<span class=\"number\">2</span>  ❯  <span class=\"number\">0.2</span>.<span class=\"number\">1</span>  http<span class=\"variable\">s:</span>//github.<span class=\"keyword\">com</span>/wzpan/hexo-<span class=\"keyword\">tag</span>-bootstrap</span><br><span class=\"line\"></span><br><span class=\"line\"> Space <span class=\"keyword\">to</span> select. Enter <span class=\"keyword\">to</span> start upgrading. Control-C <span class=\"keyword\">to</span> cancel.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>npm-check列出更新包，空格切换包是否更新，Control + C 取消更新，回车就是执行更新。</p>\n","categories":["Node-js","npm"],"tags":["NODE_PATH"]},{"title":"修改npm包默认安装路径","url":"/2020/11/26/Node.js/npm/%E4%BF%AE%E6%94%B9npm%E5%8C%85%E7%9A%84%E9%BB%98%E8%AE%A4%E5%AE%89%E8%A3%85%E4%BD%8D%E7%BD%AE/","content":"<p><code>npm install -g XXXX</code>时下载的全局包默认是放在C盘的用户目录下，奈何我C盘实在空间有限，今天花点时间来修改一下安装路径</p>\n<span id=\"more\"></span>\n<ol>\n<li><p>查看当前根路径。</p>\n <figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm root -g</span><br><span class=\"line\"><span class=\"comment\">//或者</span></span><br><span class=\"line\">npm <span class=\"built_in\">config</span> <span class=\"built_in\">get</span> prefix</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在目标文件夹新建<code>包目录</code>和<code>cache目录</code></p>\n <figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm<span class=\"built_in\"> config </span><span class=\"builtin-name\">set</span><span class=\"built_in\"> prefix </span><span class=\"string\">&quot;d:\\node_modules &quot;</span></span><br><span class=\"line\">npm<span class=\"built_in\"> config </span><span class=\"builtin-name\">set</span> cache <span class=\"string\">&quot;d:\\node_cache&quot;</span></span><br></pre></td></tr></table></figure>\n<p> 其中包目录存放，<code>npm -g</code>命令下载的包和命令，cache目录则是npm的缓存文件夹</p>\n</li>\n<li><p>现在起，执行<code>npm -g</code>包已经下载到新建立的文件夹里了，但是当执行全局命令时，比如全局<code>hexo</code>,<code>npm-check</code>等命令时，会出现找不到命令的错误。比如：</p>\n <figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">hexo :</span> 无法将“hexo”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。</span><br><span class=\"line\">所在位置 行:<span class=\"number\">1</span> 字符: <span class=\"number\">1</span></span><br><span class=\"line\">+ hexo</span><br><span class=\"line\">+ ~~~~~</span><br><span class=\"line\">    + <span class=\"attr\">CategoryInfo          :</span> <span class=\"attr\">ObjectNotFound:</span> (<span class=\"attr\">hexo:</span>String) [], CommandNotFoundException</span><br><span class=\"line\">    + <span class=\"attr\">FullyQualifiedErrorId :</span> CommandNotFoundException</span><br></pre></td></tr></table></figure>\n<p> 原因是系统不知道咱们修改了命令存放地址，所以还需要修改环境变量<code>path</code>。</p>\n<ol>\n<li>在系统设置中为PATH新增<code>path=d:\\node_modules</code></li>\n<li>新增一个环境变量<code>NODE_PATH=d:\\node_modules\\node_modules</code>,</li>\n</ol>\n</li>\n</ol>\n<p>NODE_PATH是NODE中用来寻找模块所提供的路径注册环境变量。我们可以指定NODE_PATH环境变量。并且用;分割多个不同的目录。</p>\n<p>当NODE加载包时，首先从项目的根位置递归搜寻 node_modules 目录，直到文件系统根目录的 node_modules，如果还没有查找到指定模块的话，就会去 NODE_PATH中注册的路径中查找。</p>\n","categories":["Node-js","npm"],"tags":["NODE_PATH"]},{"title":"Github删除tag","url":"/2015/10/16/iOS/Cocoapods/git_delete_tag/","content":"<figure class=\"highlight elixir\"><table><tr><td class=\"code\"><pre><span class=\"line\">git -d TAG</span><br><span class=\"line\">git push origin <span class=\"symbol\">:refs/tags/TAG</span></span><br></pre></td></tr></table></figure>\n\n","categories":["iOS","Cocoapods"],"tags":["cocoapods"]},{"title":"Cocoapods个人仓库","url":"/2015/10/16/iOS/Cocoapods/cocoapods/","content":"<p>CocoaPods上托管着大量第三方库和项目。<br>PROJECT.podspec是CocoaPods中每个被管理项目的配置文件。<br>PROJECT.podspec文件详细罗列项目的简介，作者，版权信息，以及最根本的：代码文件，资源文件的所在和依赖。</p>\n<p>PROJECT.podspec文件与其PROJECT是一一对应的关系，CocoaPods通过.podspec掌管着该PROJECT。</p>\n<p>CocoaPods使用仓库<a href=\"https://github.com/CocoaPods/Specs\">Specs Repo</a>管理其所有公共第三方项目的.podspec文件。<br>这个仓库中可以查看到所有发布到CocoaPods的第三方库的.podspec文件。</p>\n<p>当使用CocoaPods使用第三方库时，CocoaPods根据Specs Repo里所对应项目的podspec提供的信息进行验证和配置项目。</p>\n<p>在日常的学习与工作过程中，可能已经积累出一些常用的组件或者库。<br>我们可以创建个人的Specs Repo来管理这些组件，免得每次新建项目时的拖拖拽拽。</p>\n<h2 id=\"创建个人Specs-Repo仓库\"><a href=\"#创建个人Specs-Repo仓库\" class=\"headerlink\" title=\"创建个人Specs Repo仓库\"></a>创建个人Specs Repo仓库</h2><p>首先要做的是创建一个仓库，用作CocoaPods管理.podspec文件的基地。<br>这个仓库对应于CocoaPods的公用Spec Repo。</p>\n<p>在github中创建一个Repo，例如此处取名：Specs，取得其gitURL。<br>在终端：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">pod repo add Specs [gitURL]</span><br></pre></td></tr></table></figure>\n\n<p>运行后，CocoaPods将在本地创建并维护Specs这个目录，并链接github远程仓库。<br>Specs本地目录可以<code>~/.cocoapods/repos</code>进行查看。</p>\n<h2 id=\"为项目配置-podspec\"><a href=\"#为项目配置-podspec\" class=\"headerlink\" title=\"为项目配置.podspec\"></a>为项目配置.podspec</h2><h3 id=\"为已有项目配置-podspec\"><a href=\"#为已有项目配置-podspec\" class=\"headerlink\" title=\"为已有项目配置.podspec\"></a>为已有项目配置.podspec</h3><p>项目需要已发布到github。</p>\n<p>cd到项目目录</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\">pod spec create [NAME|https:<span class=\"regexp\">//gi</span>thub.com<span class=\"regexp\">/USER/</span>REPO]</span><br></pre></td></tr></table></figure>\n<p>该命令将创建NAME.podspec文件,按文档或者相关示例完成配置即可：</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#  Be sure to run `pod spec lint test.podspec&#x27; to ensure this is a</span></span><br><span class=\"line\"><span class=\"comment\">#  valid spec and to remove all comments including this before submitting the spec.</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#  To learn more about Podspec attributes see http://docs.cocoapods.org/specification.html</span></span><br><span class=\"line\"><span class=\"comment\">#  To see working Podspecs in the CocoaPods repo see https://github.com/CocoaPods/Specs/</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"></span><br><span class=\"line\">Pod::Spec.new do |s|</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># ―――  Spec Metadata  ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class=\"line\">  <span class=\"comment\">#</span></span><br><span class=\"line\">  <span class=\"comment\">#  These will help people to find your library, and whilst it</span></span><br><span class=\"line\">  <span class=\"comment\">#  can feel like a chore to fill in it&#x27;s definitely to your advantage. The</span></span><br><span class=\"line\">  <span class=\"comment\">#  summary should be tweet-length, and the description more in depth.</span></span><br><span class=\"line\">  <span class=\"comment\">#</span></span><br><span class=\"line\"></span><br><span class=\"line\">  s.<span class=\"attr\">name</span>         = <span class=\"string\">&quot;Library&quot;</span></span><br><span class=\"line\">  s.<span class=\"attr\">version</span>      = <span class=\"string\">&quot;0.0.1&quot;</span></span><br><span class=\"line\">  s.<span class=\"attr\">summary</span>      = <span class=\"string\">&quot;A short description of Library.&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># This description is used to generate tags and improve search results.</span></span><br><span class=\"line\">  <span class=\"comment\">#   * Think: What does it do? Why did you write it? What is the focus?</span></span><br><span class=\"line\">  <span class=\"comment\">#   * Try to keep it short, snappy and to the point.</span></span><br><span class=\"line\">  <span class=\"comment\">#   * Write the description between the DESC delimiters below.</span></span><br><span class=\"line\">  <span class=\"comment\">#   * Finally, don&#x27;t worry about the indent, CocoaPods strips it!</span></span><br><span class=\"line\">  s.<span class=\"attr\">description</span>  = &lt;&lt;-DESC</span><br><span class=\"line\">                   DESC</span><br><span class=\"line\"></span><br><span class=\"line\">  s.<span class=\"attr\">homepage</span>     = <span class=\"string\">&quot;http://EXAMPLE/test&quot;</span></span><br><span class=\"line\">  <span class=\"comment\"># s.screenshots  = &quot;www.example.com/screenshots_1.gif&quot;, &quot;www.example.com/screenshots_2.gif&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># ―――  Spec License  ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class=\"line\">  <span class=\"comment\">#</span></span><br><span class=\"line\">  <span class=\"comment\">#  Licensing your code is important. See http://choosealicense.com for more info.</span></span><br><span class=\"line\">  <span class=\"comment\">#  CocoaPods will detect a license file if there is a named LICENSE*</span></span><br><span class=\"line\">  <span class=\"comment\">#  Popular ones are &#x27;MIT&#x27;, &#x27;BSD&#x27; and &#x27;Apache License, Version 2.0&#x27;.</span></span><br><span class=\"line\">  <span class=\"comment\">#</span></span><br><span class=\"line\"></span><br><span class=\"line\">  s.<span class=\"attr\">license</span>      = <span class=\"string\">&quot;MIT (example)&quot;</span></span><br><span class=\"line\">  <span class=\"comment\"># s.license      = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;FILE_LICENSE&quot; &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># ――― Author Metadata  ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class=\"line\">  <span class=\"comment\">#</span></span><br><span class=\"line\">  <span class=\"comment\">#  Specify the authors of the library, with email addresses. Email addresses</span></span><br><span class=\"line\">  <span class=\"comment\">#  of the authors are extracted from the SCM log. E.g. $ git log. CocoaPods also</span></span><br><span class=\"line\">  <span class=\"comment\">#  accepts just a name if you&#x27;d rather not provide an email address.</span></span><br><span class=\"line\">  <span class=\"comment\">#</span></span><br><span class=\"line\">  <span class=\"comment\">#  Specify a social_media_url where others can refer to, for example a twitter</span></span><br><span class=\"line\">  <span class=\"comment\">#  profile URL.</span></span><br><span class=\"line\">  <span class=\"comment\">#</span></span><br><span class=\"line\"></span><br><span class=\"line\">  s.<span class=\"attr\">author</span>             = &#123; <span class=\"string\">&quot;Author&quot;</span> =&gt; <span class=\"string\">&quot;Author@github.com&quot;</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># ――― Platform Specifics ――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class=\"line\">  <span class=\"comment\">#</span></span><br><span class=\"line\">  <span class=\"comment\">#  If this Pod runs only on iOS or OS X, then specify the platform and</span></span><br><span class=\"line\">  <span class=\"comment\">#  the deployment target. You can optionally include the target after the platform.</span></span><br><span class=\"line\">  <span class=\"comment\">#</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># s.platform     = :ios</span></span><br><span class=\"line\">  <span class=\"comment\"># s.platform     = :ios, &quot;5.0&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">#  When using multiple platforms</span></span><br><span class=\"line\">  <span class=\"comment\"># s.ios.deployment_target = &quot;5.0&quot;</span></span><br><span class=\"line\">  <span class=\"comment\"># s.osx.deployment_target = &quot;10.7&quot;</span></span><br><span class=\"line\">  <span class=\"comment\"># s.watchos.deployment_target = &quot;2.0&quot;</span></span><br><span class=\"line\">  <span class=\"comment\"># s.tvos.deployment_target = &quot;9.0&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># ――― Source Location ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class=\"line\">  <span class=\"comment\">#</span></span><br><span class=\"line\">  <span class=\"comment\">#  Specify the location from where the source should be retrieved.</span></span><br><span class=\"line\">  <span class=\"comment\">#  Supports git, hg, bzr, svn and HTTP.</span></span><br><span class=\"line\">  <span class=\"comment\">#</span></span><br><span class=\"line\"></span><br><span class=\"line\">  s.<span class=\"attr\">source</span>       = &#123; :<span class=\"attr\">git</span> =&gt; <span class=\"string\">&quot;http://EXAMPLE/Library.git&quot;</span>, :<span class=\"attr\">tag</span> =&gt; <span class=\"string\">&quot;#&#123;s.version&#125;&quot;</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># ――― Source Code ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class=\"line\">  <span class=\"comment\">#</span></span><br><span class=\"line\">  <span class=\"comment\">#  CocoaPods is smart about how it includes source code. For source files</span></span><br><span class=\"line\">  <span class=\"comment\">#  giving a folder will include any swift, h, m, mm, c &amp; cpp files.</span></span><br><span class=\"line\">  <span class=\"comment\">#  For header files it will include any header in the folder.</span></span><br><span class=\"line\">  <span class=\"comment\">#  Not including the public_header_files will make all headers public.</span></span><br><span class=\"line\">  <span class=\"comment\">#</span></span><br><span class=\"line\"></span><br><span class=\"line\">  s.<span class=\"attr\">source_files</span>  = <span class=\"string\">&quot;Classes&quot;</span>, <span class=\"string\">&quot;Classes/**/*.&#123;h,m&#125;&quot;</span></span><br><span class=\"line\">  s.<span class=\"attr\">exclude_files</span> = <span class=\"string\">&quot;Classes/Exclude&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># s.public_header_files = &quot;Classes/**/*.h&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># ――― Resources ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class=\"line\">  <span class=\"comment\">#</span></span><br><span class=\"line\">  <span class=\"comment\">#  A list of resources included with the Pod. These are copied into the</span></span><br><span class=\"line\">  <span class=\"comment\">#  target bundle with a build phase script. Anything else will be cleaned.</span></span><br><span class=\"line\">  <span class=\"comment\">#  You can preserve files from being cleaned, please don&#x27;t preserve</span></span><br><span class=\"line\">  <span class=\"comment\">#  non-essential files like tests, examples and documentation.</span></span><br><span class=\"line\">  <span class=\"comment\">#</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># s.resource  = &quot;icon.png&quot;</span></span><br><span class=\"line\">  <span class=\"comment\"># s.resources = &quot;Resources/*.png&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># s.preserve_paths = &quot;FilesToSave&quot;, &quot;MoreFilesToSave&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># ――― Project Linking ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class=\"line\">  <span class=\"comment\">#</span></span><br><span class=\"line\">  <span class=\"comment\">#  Link your library with frameworks, or libraries. Libraries do not include</span></span><br><span class=\"line\">  <span class=\"comment\">#  the lib prefix of their name.</span></span><br><span class=\"line\">  <span class=\"comment\">#</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># s.framework  = &quot;SomeFramework&quot;</span></span><br><span class=\"line\">  <span class=\"comment\"># s.frameworks = &quot;SomeFramework&quot;, &quot;AnotherFramework&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># s.library   = &quot;iconv&quot;</span></span><br><span class=\"line\">  <span class=\"comment\"># s.libraries = &quot;iconv&quot;, &quot;xml2&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># ――― Project Settings ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span></span><br><span class=\"line\">  <span class=\"comment\">#</span></span><br><span class=\"line\">  <span class=\"comment\">#  If your library depends on compiler flags you can set them in the xcconfig hash</span></span><br><span class=\"line\">  <span class=\"comment\">#  where they will only apply to your library. If you depend on other Podspecs</span></span><br><span class=\"line\">  <span class=\"comment\">#  you can include multiple dependencies to ensure it works.</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># s.requires_arc = true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># s.xcconfig = &#123; &quot;HEADER_SEARCH_PATHS&quot; =&gt; &quot;$(SDKROOT)/usr/include/libxml2&quot; &#125;</span></span><br><span class=\"line\">  <span class=\"comment\"># s.dependency &quot;JSONKit&quot;, &quot;~&gt; 1.4&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n\n<p>配置之后，使用验证命令验证配置的合法性：</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"code\"><pre><span class=\"line\">pod <span class=\"class\"><span class=\"keyword\">lib</span> <span class=\"title\">lint</span> <span class=\"title\">NAME</span>.<span class=\"title\">podspec</span></span></span><br></pre></td></tr></table></figure>\n\n<p>通过验证后，即可向本地Specs Repo推送NAME.podspec了：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">pod repo push Specs <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">NAME</span>.</span></span>podspec</span><br></pre></td></tr></table></figure>\n<p>完成后，这个NAME.podsepc就被添加到了本地~/.cocoapods/repos/库里，并也提交到github上的个人Spec Repo上。</p>\n<p>自此，就可以利用cocoapods在其他项目里使用这个项目了。</p>\n<h3 id=\"新创建项目\"><a href=\"#新创建项目\" class=\"headerlink\" title=\"新创建项目\"></a>新创建项目</h3><p>另外也可以新创建一个专门的项目进行库维护。<br><a href=\"http://guides.cocoapods.org/making/using-pod-lib-create\">Using Pod Lib Create</a><br>CocoaPods提供了Pod Lib Create工具进行库创建工作。<br>使用这个工具创建的库拥有一个比较清晰的库结构，方便维护：</p>\n<p>cd到要创建项目的目录：</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"code\"><pre><span class=\"line\">pod <span class=\"class\"><span class=\"keyword\">lib</span> <span class=\"title\">create</span> <span class=\"title\">Library</span></span></span><br></pre></td></tr></table></figure>\n<p>CocoaPods将在目录下生产项目Library：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\">Library</span><br><span class=\"line\">├── Example                                  <span class=\"meta\">#Example</span></span><br><span class=\"line\">│   ├── PodTestLibrary</span><br><span class=\"line\">│   ├── PodTestLibrary.xcodeproj</span><br><span class=\"line\">│   ├── PodTestLibrary.xcworkspace</span><br><span class=\"line\">│   ├── Podfile                              <span class=\"meta\">#Example的依赖描述文件</span></span><br><span class=\"line\">│   ├── Podfile.<span class=\"keyword\">lock</span></span><br><span class=\"line\">│   ├── Pods                                 <span class=\"meta\">#Example的依赖文件</span></span><br><span class=\"line\">│   └── Tests</span><br><span class=\"line\">├── LICENSE                                  <span class=\"meta\">#开源协议</span></span><br><span class=\"line\">├── Pod                                      <span class=\"meta\">#组件的目录</span></span><br><span class=\"line\">│   ├── Assets                               <span class=\"meta\">#资源文件</span></span><br><span class=\"line\">│   └── Classes                              <span class=\"meta\">#类文件</span></span><br><span class=\"line\">├── Library.podspec                          <span class=\"meta\">#.podspec文件</span></span><br><span class=\"line\">└── README.md                                <span class=\"meta\">#README文件</span></span><br></pre></td></tr></table></figure>\n\n<p>其中，Example是一个示例工程，可以用来为你的开源项目添加示例程序。<br>LICENSE是开源协议文件，<br>Pod文件夹存放项目的资源和代码文件，<br>.podspec是需要配置的.podspec文件，<br>README是项目发布到github上的描述文件。</p>\n<p>需要注意的是：使用<code>pod lib create</code>命令创建的库需连接到github并发布才能使用。<br>因此，在创建了上面的Library库之后，需要去github上创建一个repo，取得@git,然后执行：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"keyword\">add</span><span class=\"bash\"> -A</span></span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;MESSAGE&quot;</span></span><br><span class=\"line\">git remote <span class=\"keyword\">add</span><span class=\"bash\"> origin [@git]</span></span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n\n<p>在发布项目时，需要注意维护项目的版本信息。<br>版本可以用tag或者branch来进行管理：<br>CocoaPod默认使用tag：<br>.podspec文件中的源信息，默认针对tag号：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"code\"><pre><span class=\"line\">s.source       = &#123; :<span class=\"function\"><span class=\"params\">git</span> =&gt;</span> <span class=\"string\">&quot;http://EXAMPLE/Library.git&quot;</span>, :<span class=\"function\"><span class=\"params\">tag</span> =&gt;</span> <span class=\"string\">&quot;#&#123;s.version&#125;&quot;</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>因此，在发布时需要为commit打上tag,如：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">git</span> tag <span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attribute\">git</span> push origin <span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>要不然CocoaPods是找不到源的。</p>\n<p>当然，如果是在维护一个不太稳定的库，也可以用分支来进行管理：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"code\"><pre><span class=\"line\">s.source       = &#123; :<span class=\"function\"><span class=\"params\">git</span> =&gt;</span> <span class=\"string\">&quot;http://EXAMPLE/Library.git&quot;</span>, :<span class=\"function\"><span class=\"params\">branch</span> =&gt;</span> <span class=\"string\">&quot;BRANCH_NAME&quot;</span> &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>接下来，就和上文一样，之后需要做的就是项目的迭代维护：<br>每次的使用迭代差不多是这样：</p>\n<ol>\n<li>维护Pod文件夹的资源和代码文件</li>\n<li><code>pod update</code>更新Example项目的项目依赖</li>\n<li>Example项目进行测试</li>\n<li>维护文档，如README.md</li>\n<li>配置.podspec文件</li>\n<li><code>pod lib lint NAME.podspec</code>验证</li>\n<li><code>pod repo push [SPECS_NAME] NAME.podspec</code>在个人Specs Repo提交</li>\n<li>发布</li>\n<li>使用CocoaPods</li>\n</ol>\n<h2 id=\"使用咱们的Pod\"><a href=\"#使用咱们的Pod\" class=\"headerlink\" title=\"使用咱们的Pod\"></a>使用咱们的Pod</h2><p>在完成.podspec配置，并发布后。我们就可以使用制作完成的Pod了。<br>在使用Pod时，在Podfile文件中添加上源信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> <span class=\"string\">&#x27;https://github.com/USERNAME/Specs.git&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> <span class=\"string\">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>这样CocoaPods就知道优先从何处寻找.podspec文件了。</p>\n","categories":["iOS","Cocoapods"],"tags":["cocoapods"]},{"title":"Quartz2D笔记-序","url":"/2015/10/26/iOS/Draw/iOS_Draw_preview/","content":"<p>Quartz2D是iOS的一套绘图引擎。<br>简言之，画画的。</p>\n<p>平时画画的过程是怎么样的：</p>\n<ol>\n<li>架上工作台</li>\n<li>铺好画纸</li>\n<li>准备画笔，调配颜料</li>\n<li>涂涂画画</li>\n<li>收纸搞定</li>\n</ol>\n<p>用Quartz2D绘画也是一样。</p>\n<h1 id=\"画纸\"><a href=\"#画纸\" class=\"headerlink\" title=\"画纸\"></a>画纸</h1><p>首先，要有画纸。对于Quartz而言，Graphics Context可以想象成我们的画纸。即我们绘画的地方。<br>Quartz2D绘制的目标输出设备有很多，包括window，Layer，PDF，printer，Bitmap等。<br>这些不同的目标设备都可以视为目标画纸，有着各自设备相关的特性。<br>Quartz并没有为每一个目标设备都定义一个数据类型来表示各个画纸，而是用CGContextRef来隐藏画纸（目标设备）信息，使得不同设备所代表的画板信息统一，让画家可以把所有注意力集中在绘制上，而不需要为画板等分神。</p>\n<p>在iOS平台，比较常用的“画纸”是：view，Bitmap和PDF。</p>\n<p>（以下例子都用的UIKit函数，其都有对应Core Graphics函数完成相同工作，需要时可查阅。另外，UIKit提供的函数创建的Context都自动进行了符合UIKit坐标系的转换，而不是使用CG坐标体系，因此，在iOS平台进行绘制工作时应优先采用UIKit函数）</p>\n<h2 id=\"view-context\"><a href=\"#view-context\" class=\"headerlink\" title=\"view context\"></a>view context</h2><p>每一个view对象都会自动创建一个graphics context。 </p>\n<p>UIView对象在调用自定义的<code>drawRect:</code>方法前，将自动完成对绘图环境的配置，其中就包括生成画板CGContextRef。<br>在<code>drawRect:</code>方法中，我们直接可以获取之：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)drawRect:(<span class=\"built_in\">CGRect</span>)rect &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CGContextRef</span> context = <span class=\"built_in\">UIGraphicsGetCurrentContext</span>();</span><br><span class=\"line\">    <span class=\"comment\">//drawing...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"bitmap-context\"><a href=\"#bitmap-context\" class=\"headerlink\" title=\"bitmap context\"></a>bitmap context</h2><p>在需要时可以利用以下UIKit函数创建位图绘制上下文：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">UIGraphicsBeginImageContext</span>(<span class=\"built_in\">CGSize</span> size);</span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">UIGraphicsBeginImageContextWithOptions</span>(<span class=\"built_in\">CGSize</span> size, <span class=\"built_in\">BOOL</span> opaque, <span class=\"built_in\">CGFloat</span> scale);</span><br></pre></td></tr></table></figure>\n<p>在绘画完毕后，记得清理工作台面：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">UIGraphicsEndImageContext</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>例如：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (void)drawBitmap:(CGSize)size&#123;</span><br><span class=\"line\">    <span class=\"regexp\">//</span>获取画纸</span><br><span class=\"line\">    UIGraphicsBeginImageContext(size);</span><br><span class=\"line\">    <span class=\"regexp\">//</span>绘制</span><br><span class=\"line\">    <span class=\"regexp\">//</span>drawing code</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"regexp\">//</span>清理</span><br><span class=\"line\">    UIGraphicsEndImageContext();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"PDF-context\"><a href=\"#PDF-context\" class=\"headerlink\" title=\"PDF context\"></a>PDF context</h2><p>UIKit也提供了创建PDF绘制上下文的函数：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">UIGraphicsBeginPDFContextToData</span>(<span class=\"built_in\">NSMutableData</span> *data, <span class=\"built_in\">CGRect</span> bounds, <span class=\"built_in\">NSDictionary</span> *documentInfo);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> <span class=\"built_in\">UIGraphicsBeginPDFContextToFile</span>(<span class=\"built_in\">NSString</span> *path, <span class=\"built_in\">CGRect</span> bounds, <span class=\"built_in\">NSDictionary</span> *documentInfo);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"工作台\"><a href=\"#工作台\" class=\"headerlink\" title=\"工作台\"></a>工作台</h1><p>实际上，Graphics Context不仅仅是绘制目标（画纸），它还持有很多绘制信息，比如当前的填充颜色，变换信息，线条属性，色彩混合模式等。<br>因此，把Context引申成工作台——一个画纸旁摆放着诸多绘画工具和颜料的工作台面，可能更加恰当。</p>\n<h2 id=\"context-stack\"><a href=\"#context-stack\" class=\"headerlink\" title=\"context stack\"></a>context stack</h2><p>在上文中，<code>UIGraphicsGetCurrentContext</code>这个当前上下文可以理解为当前的工作台面。</p>\n<p>事实上，iOS的UIKit维护着一个Graphics Context Stack。这个栈可以持有很多工作台面，让画家可以在不同工作台面中切换。<br>可以把这个栈想象成摆放着多个工作台的工作室，画家在各个工作台中来回切换，同时作画。尽管这在物理属性看起来似乎很不“栈”，但是你明白就好。</p>\n<p>current graphics context默认为nil。<br>当使用UIView进行屏幕绘制时，UIKit会在调用<code>drawRect:</code>方法前生成view context并压入栈中使其成为current graphics context。<br>因此：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)drawRect:(<span class=\"built_in\">CGRect</span>)rect &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CGContextRef</span> context = <span class=\"built_in\">UIGraphicsGetCurrentContext</span>();</span><br><span class=\"line\">    <span class=\"comment\">//drawing...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>就完成了对view画布的获取。</p>\n<p>在使用Bitmap，PDF Context时也同理,<code> UIBeginImageContext(size);</code>也在创建完成后，进行了压栈工作。<br>因此可以使用<code> CGContextRef context = UIGraphicsGetCurrentContext();</code>获取。</p>\n<p>当需要在多个工作台切换时，需要使用：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">UIGraphicsPushContext</span> ( <span class=\"built_in\">CGContextRef</span> context );</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">UIGraphicsPopContext</span> <span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>;</span><br></pre></td></tr></table></figure>\n<p>进行台面切换。</p>\n<h2 id=\"Graphics-state-stack\"><a href=\"#Graphics-state-stack\" class=\"headerlink\" title=\"Graphics state stack\"></a>Graphics state stack</h2><p>除了当前工作台面外，每个工作台（Graphics Context）自己还维护着一个状态栈（Graphics state stack).<br>这也很好理解。<br>试想，画家在绘画一开始为了绘制某个图像已经调好了颜料，设置好了画笔粗细，和画笔类型。<br>此时，他想画另一个图像，需要调试新的颜色，使用其他的画笔。<br>而context只能保持一份这些设置信息。<br>为了在使用新颜色新画笔等新状态的时候不丢失之前的设置状态，每个Context又都维护了一份自己的状态栈（Graphics state stack)。</p>\n<p>可以使用：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"code\"><pre><span class=\"line\">CGContextSaveGState()<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">CGContextRestoreGState()<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>进行压栈，出栈工作<br>Graphics state保存的信息有：</p>\n<ul>\n<li>Current transformation matrix (CTM)</li>\n<li>Clipping area</li>\n<li>Line: width, join, cap, dash, miter limit</li>\n<li>Accuracy of curve estimation (flatness)</li>\n<li>Anti-aliasing setting</li>\n<li>Color: fill and stroke settings</li>\n<li>Alpha value (transparency)</li>\n<li>Rendering intent</li>\n<li>Color space: fill and stroke settings</li>\n<li>Text: font, font size, character spacing, text drawing mode</li>\n<li>Blend mode</li>\n</ul>\n<p>可以看到，其中不包括path等路径信息。<br>这也很好理解，因为路径信息描述的是对图画形状的勾勒，这应该是无状态的。<br>每次想画什么图形就勾勒什么路径。<br>而Graphics state保存的应该是有状态的信息，比如当前的颜色，当前线条的粗细，样式，当前的混合模式等。</p>\n<h1 id=\"画笔\"><a href=\"#画笔\" class=\"headerlink\" title=\"画笔\"></a>画笔</h1><p>实际的绘画过程中，画家用不同的画笔来勾勒不同质感和形状。<br>这里，我们可以把Quartz2D中的很多工具想象成画笔。它们的作用也是勾勒和绘制。<br>例如：<br>CGPathRef<br>CGImageRef<br>CGLayerRef<br>CGPatternRef<br>CGShadingRef、CGGradientRef<br>CGFunctionRef<br>CGColorRef, CGColorSpaceRef<br>CGFontRef</p>\n<h1 id=\"颜料\"><a href=\"#颜料\" class=\"headerlink\" title=\"颜料\"></a>颜料</h1><p>有了画板和各种画笔，接下来是颜料了。<br>Quartz用数字来表示色彩。色彩空间则是描述这一组数字如何描述色彩的数学模型。<br>在调配颜料时，需要为CGContextRef设置色彩空间，然后设置色彩。<br>对于iOS而言，RGB色彩空间是默认的设置。<br>UIColor也默认采用RGB色彩空间，并提供了各种方法包括RGB, HSB, 和灰度值来获取颜色。</p>\n<p>如果希望采用其他色彩空间，可以<a href=\"https://developer.apple.com/library/prerelease/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_color/dq_color.html#//apple_ref/doc/uid/TP30001066-CH205-TPXREF101\">参考链接</a></p>\n<h1 id=\"Coordinate-Systems\"><a href=\"#Coordinate-Systems\" class=\"headerlink\" title=\"Coordinate Systems\"></a>Coordinate Systems</h1><p>工作台，画纸，画笔，颜料，万事俱备。可以开画了。<br>然而，还有一点小问题：画纸的摆放。<br>Quartz的默认坐标系是LLO（lower-left-origin）的。坐标起点在左下。<br>而UIKit的坐标系是ULO（upper-left-origin）。坐标起点在左上。<br>如果不进行转换工作，就相当于把画纸摆错了位置。</p>\n<p>因此在iOS平台上利用Quartz进行绘制时，一般需要进行坐标系的转换：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">CGContextTranslateCTM</span>(graphicsContext, <span class=\"number\">0</span>.<span class=\"number\">0</span>, imageHeight);</span><br><span class=\"line\"><span class=\"attribute\">CGContextScaleCTM</span>(graphicsContext, <span class=\"number\">1</span>.<span class=\"number\">0</span>, -<span class=\"number\">1</span>.<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<ol>\n<li>上移坐标原点至左上</li>\n<li>颠倒y坐标轴</li>\n</ol>\n<p>UIView创建的context和UIKit函数<code> UIGraphicsBeginImageContextWithOptions</code>创建的context都自动进行了坐标系的转换。</p>\n<p>但是绘图上下文如果是用CG函数进行创建，就需要利用上述方法手动修改。</p>\n","categories":["iOS","Draw"],"tags":["draw"]},{"title":"关于this","url":"/2019/11/26/Node.js/JavaScript/Essentials/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E4%B8%80%E5%88%87/","content":"<p>今天，从ECMA标准规范的角度来学习this。<br>注意，是ECMA规范，不是具体实现，不同javascript引擎对ECMA规范的具体实现，取决于引擎开发者，但是不管具体实现如何，他们既然都遵循ECMA标准，那么其算法和行为都是一致的。</p>\n<h1 id=\"从-quot-关键字-quot-这3个中文字开始\"><a href=\"#从-quot-关键字-quot-这3个中文字开始\" class=\"headerlink\" title=\"从&quot;关键字&quot;这3个中文字开始\"></a>从&quot;关键字&quot;这3个中文字开始</h1><p>每一种编程语言都有关键字，如数据类型int，float，如结构控制if，else，for，如内存分配new。编译器，或解释器在解析到关键字时会将其转译为语言相关或平台相关的特定功能。<br>如变量类型关键字转译为分配特定的数据类型，如结构控制关键字转译为执行相应的控制结构，如new关键字转译为执行内存分配和对象初始化等操作。</p>\n<p><code>this</code>是javascript中的一个关键字。 既然是关键字，就意味着javascript引擎，在解释<code>this</code>时会将其转译为该关键字的具体实现。<br>更确切的说，当解释器遇到：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>;</span><br></pre></td></tr></table></figure>\n<p>会执行的是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">ResolveThisBinding();</span><br></pre></td></tr></table></figure>\n<p>当解释器遇到：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.bar;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>会执行的是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    ResolveThisBinding().bar;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题来了，ResolveThisBinding-是什么？\"><a href=\"#问题来了，ResolveThisBinding-是什么？\" class=\"headerlink\" title=\"问题来了，ResolveThisBinding()是什么？\"></a>问题来了，<code>ResolveThisBinding()</code>是什么？</h2><p><code>ResolveThisBinding()</code>是javascript引擎中执行上下文(Execution Context)规范的一个抽象操作。执行的操作是从当前执行上下文(running execution context)的词法环境(LexicalEnvironment)中取出this。<br>伪代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ResolveThisBinding</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    Let envRec be GetThisEnvironment().</span><br><span class=\"line\">    Return ? envRec.GetThisBinding().</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题又来了，Execution-Context是什么？\"><a href=\"#问题又来了，Execution-Context是什么？\" class=\"headerlink\" title=\"问题又来了，Execution Context是什么？\"></a>问题又来了，<code>Execution Context</code>是什么？</h2><p>跟其他程序语言一样，javascript也是以调用栈（call-stack）的逻辑形式进行函数调用。<br>不同的是，javascript调用栈中的单元对象是Execution Context。<br><a href=\"https://tc39.es/ecma262/#sec-execution-contexts\"><code>Execution Context</code></a>是引擎中的一个内部抽象数据结构，其与函数是一一对应的，每一个函数在调用时都会创建一个对应的执行上下文execution context，用来记录该函数调用的runtime状态和该函数对应的数据。<br>其中就包括记录函数变量和标示符信息的<code>Environment</code>属性，另外<code>Execution Context</code>也有自己的方法，从概念上看，执行上下文基本是这样一个抽象对象：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">ExecutionContext = &#123;</span><br><span class=\"line\">    state               <span class=\"comment\">//当前代码的执行状态code evaluation state </span></span><br><span class=\"line\">    <span class=\"built_in\">Function</span>,           <span class=\"comment\">//执行上下文对应的函数对象            </span></span><br><span class=\"line\">    LexicalEnvironment, <span class=\"comment\">//执行上下文词法环境的环境记录</span></span><br><span class=\"line\">    VariableEnvironment,<span class=\"comment\">//执行上下文变量环境的环境记录</span></span><br><span class=\"line\">    PrivateEnvironment,</span><br><span class=\"line\">    Reaml,              <span class=\"comment\">//当前javascript程序的领域，上下文通过此引用访问领域资源</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ResolveThisBinding</span>(<span class=\"params\"></span>);//解析绑定的<span class=\"title\">this</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">function</span> <span class=\"title\">GetThisEnvironment</span>(<span class=\"params\"></span>);//查找绑定<span class=\"title\">this</span>的环境记录</span></span><br><span class=\"line\"><span class=\"function\">    ...</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>其中一个方法就是上文中的解析绑定的this：<code>ResolveThisBinding()</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ResolveThisBinding</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    Let envRec be GetThisEnvironment().</span><br><span class=\"line\">    Return ? envRec.GetThisBinding().</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用栈通过出/入栈的方式来管理函数执行顺序。<br>每次调用一个函数，Javascript引擎都会为该函数创建一个执行上下文（execution context），然后压入执行上下文栈（execution context stack）中。而函数返回时，Javascript引擎会将执行上下文栈栈顶的执行上下文execution context弹出。<br>调用栈的底部永远都是全局上下文(global context)，这个全局上下文对应的函数是Javascript运行时生成一个匿名的函数<code>&lt;main&gt;</code>。</p>\n<p>现在再来看<code>ResolveThisBinding()</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ResolveThisBinding</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    Let envRec be GetThisEnvironment().</span><br><span class=\"line\">    Return ? envRec.GetThisBinding().</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其执行的是:<br>    1. 查找绑定this的环境记录（Environment）<br>    2. 返回环境记录绑定的this<br>可见，执行上下文是通过Environment间接获取this，Environment才是持有this的对象。</p>\n<p>是的，从功能划分上看，执行上下文只负责函数的状态信息，而函数作用域内关于<em>标识符</em>和变量的一切都委托给了环境记录Environment，this对象也不例外，说到底，关键字this也只是一个特殊的标示符。</p>\n<h2 id=\"ok-那Environment又是什么？\"><a href=\"#ok-那Environment又是什么？\" class=\"headerlink\" title=\"ok, 那Environment又是什么？\"></a>ok, 那<code>Environment</code>又是什么？</h2><p>Environment即<a href=\"https://tc39.es/ecma262/#sec-environment-records\">环境记录Environment Record</a>，<br>环境记录是一个javascript引擎内部的抽象对象结构，其作用是记录<em>标识符</em>与<em>该标示符相对应的值/地址</em>,可以视作一个一对一映射表。<br>这里的标识符指的是变量名称或函数名，而该标示符相对应的变量则是实际变量原始值或者对象/函数的引用地址，<br>环境记录由词法分析器根据代码的词法结构生成。比如代码块（Block），比如函数声明（FunctionDeclaration）。例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"comment\">//block</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> y = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Environment Record = &#123;</span><br><span class=\"line\">    x : <span class=\"number\">1</span>,</span><br><span class=\"line\">    y : <span class=\"number\">2</span>,</span><br><span class=\"line\">    foo : <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">fun</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我们的代码词法结构和作用域一般都是嵌套的，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因此生成的环境记录也是嵌套的，这是通过让内部环境记录持有 [[OuterEnv]]属性来实现:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Global Environment Record = &#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        x: <span class=\"number\">1</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    [[OuterEnv]]: <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">null</span>&gt;</span>,</span></span><br><span class=\"line\">    [[GlobalThisValue]]: &lt;globalObject&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">declarative Environment Record = &#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        x: 2,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    [[OuterEnv]]: &lt;GlobalEnvironment&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>环境记录根据作用域不同，分为不同的类型:</p>\n<ol>\n<li>声明环境记录（declarative Environment Record ）</li>\n<li>全局环境记录（global Environment Record）</li>\n<li>对象环境记录（object Environment Record）</li>\n<li>函数环境记录（function Environment Record）</li>\n<li>模块环境记录（module Environment Record）</li>\n</ol>\n<p>他们之间的结构类似于这样一个继承链（伪代码）：<br>基类：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 环境记录，Environment Record</span></span><br><span class=\"line\">abstract <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Environment</span> <span class=\"title\">Record</span></span>&#123;</span><br><span class=\"line\">    [[OuterEnv]],       <span class=\"comment\">//指向外部Environment Record或者null.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> 变量解析(<span class=\"params\"></span>), //相关函数...</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">function</span> 变量绑定(<span class=\"params\"></span>),</span></span><br><span class=\"line\"><span class=\"function\">    ...  </span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>子类：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明环境记录（declarative Environment Record ），</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 声明环境记录 <span class=\"keyword\">extends</span> <span class=\"title\">Environment</span> <span class=\"title\">Record</span></span>&#123;</span><br><span class=\"line\">    &#123;<span class=\"attr\">identifier</span> : ref&#125;, <span class=\"comment\">//标示符映射表</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象环境记录（object Environment Record）</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>  对象环境记录 <span class=\"keyword\">extends</span> <span class=\"title\">Environment</span> <span class=\"title\">Record</span></span>&#123;</span><br><span class=\"line\">    &#123;<span class=\"attr\">identifier</span> : ref&#125;, <span class=\"comment\">//标示符映射表</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 全局环境记录（global Environment Record）</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 全局环境 <span class=\"keyword\">extends</span> <span class=\"title\">Environment</span> <span class=\"title\">Record</span></span>&#123;</span><br><span class=\"line\">    &#123;<span class=\"attr\">identifier</span> : ref&#125;, <span class=\"comment\">//标示符映射表</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    [[OuterEnv]] = <span class=\"literal\">null</span>,<span class=\"comment\">//全局环境[[OuterEnv]]指向null</span></span><br><span class=\"line\">    [[GlobalThisValue]],<span class=\"comment\">//global this</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">GetThisBinding</span>(<span class=\"params\"></span>)... ,</span></span><br><span class=\"line\"><span class=\"function\">    ...</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>其中声明环境记录declarative Environment Record又有两个子类型：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数环境记录（function Environment Record）</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 函数环境记录 <span class=\"keyword\">extends</span> 声明环境记录</span>&#123;</span><br><span class=\"line\">    [[ThisValue]] ,</span><br><span class=\"line\">    [[ThisBindingStatus]],</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">GetThisBinding</span>(<span class=\"params\"></span>),</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">function</span> <span class=\"title\">BindThisValue</span>(<span class=\"params\">V</span>),</span></span><br><span class=\"line\"><span class=\"function\">    ...</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 模块环境记录（<span class=\"title\">module</span> <span class=\"title\">Environment</span> <span class=\"title\">Record</span>）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">class</span> 模块环境记录 <span class=\"title\">extends</span> 声明环境记录</span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而此刻，我们只关注，全局环境和函数环境，因为只有他们提供了<code>GetThisBinding()</code>,<br>全局环境拥有额外属性：<code>[[GlobalThisValue]]</code>，其<code>GetThisBinding()</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">GetThisBinding</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[GlobalThisValue]]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数环境拥有额外属性：<code>[[ThisValue]]</code>,其<code>GetThisBinding()</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">GetThisBinding</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    Assert([[ThisBindingStatus]] !=  lexical); <span class=\"comment\">//箭头函数没有this value</span></span><br><span class=\"line\">    If [[ThisBindingStatus]] == uninitialized  <span class=\"comment\">//this未初始化，抛出引用错误异常</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> a <span class=\"built_in\">ReferenceError</span> exception. </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[ThisValue]];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说this的值只有两种情况：</p>\n<ol>\n<li>全局环境下的<code>[[GlobalThisValue]]</code></li>\n<li>函数环境下的<code>[[ThisValue]]</code></li>\n</ol>\n<p>现在再回过头来看，当解释器遇到全局this:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>;</span><br></pre></td></tr></table></figure>\n<p>实际是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//this =&gt; ResolveThisBinding() =&gt; GetThisBinding() =&gt; [[GlobalThisValue]]</span></span><br><span class=\"line\">[[GlobalThisValue]];</span><br></pre></td></tr></table></figure>\n<p>函数中的this：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.bar;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//this =&gt; ResolveThisBinding() =&gt; GetThisBinding() =&gt; [[ThisValue]]</span></span><br><span class=\"line\">    [[ThisValue]].bar;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上，只是this的获取（get）过程，仅仅获取，不能让我们明确this的值具体是什么。<br>只有了解this的设置（set）过程，才能真正对this了如指掌。</p>\n<h1 id=\"ok，那这个-GlobalThisValue-是什么值呢？\"><a href=\"#ok，那这个-GlobalThisValue-是什么值呢？\" class=\"headerlink\" title=\"ok，那这个[[GlobalThisValue]]是什么值呢？\"></a>ok，那这个[[GlobalThisValue]]是什么值呢？</h1><blockquote>\n<p>Before it is evaluated, all ECMAScript code must be associated with a realm. Conceptually, a realm consists of a set of intrinsic objects, an ECMAScript global environment, all of the ECMAScript code that is loaded within the scope of that global environment, and other associated state and resources.</p>\n</blockquote>\n<p><a href=\"https://tc39.es/ecma262/#sec-code-realms\">JavaScript realm</a>，代表javascript程序执行的全局领域。领域realm的[[GlobalObject]]属性，即reaml的global object，<br>这个global object是宿主相关的，比如浏览器中的global object是window,node.js中的global object是node。<br>javascript程序执行的第一步就是宿主创建并且初始化领域realm:<a href=\"https://tc39.es/ecma262/#sec-initializehostdefinedrealm\"><code>InitializeHostDefinedRealm()</code></a> ，<br>包括 <code>SetRealmGlobalObject</code>，即设置global this，使用gloabal this创建全局环境Global Environment：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">InitializeHostDefinedRealm</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    create <span class=\"keyword\">new</span> execution context;<span class=\"comment\">//创建全局执行上下文</span></span><br><span class=\"line\">    create <span class=\"built_in\">global</span> object <span class=\"comment\">//创建对象</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span> = <span class=\"built_in\">global</span> object <span class=\"comment\">//设置global this</span></span><br><span class=\"line\">    create <span class=\"keyword\">new</span> Global Environment;<span class=\"comment\">//创建全局环境</span></span><br><span class=\"line\">    Global Environment.[[GlobalThisValue]] = <span class=\"built_in\">this</span> <span class=\"comment\">//设置[[GlobalThisValue]]</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，[[GlobalThisValue]]的值是javascript一开始就创建的领域Realm相关的全局对象：window，node等。</p>\n<h1 id=\"那-ThisValue-呢？\"><a href=\"#那-ThisValue-呢？\" class=\"headerlink\" title=\"那[[ThisValue]]呢？\"></a>那[[ThisValue]]呢？</h1><p>this被认为复杂是因为其动态性，意思是this是在函数调用的时候才绑定的一个值，而不是代码静态绑定的。<br>而理解了javascript引擎如何处理函数后，又会发现this的动态绑定其实也很直观。</p>\n<p>跟this一样，函数调用也是一个特殊的语法结构，引擎解析器在解析到函数调用时会转译为真正调用这个函数的内部方法：<br>例如函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">add();</span><br><span class=\"line\">foo.add(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>实际执行的是：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Call( add, null);</span><br><span class=\"line\">Call( add, foo, <span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://tc39.es/ecma262/#sec-call\"><code> Call ( F, V [ , argumentsList ] )</code></a>这个函数是规范中定义的抽象方法，<br>接受3个参数：</p>\n<ol>\n<li>调用的[函数]，</li>\n<li>调用该函数的对象，即我们关心的this，</li>\n<li>可选的参数列表</li>\n</ol>\n<p>其执行伪代码是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Call ( F, thisArgument [ , argumentsList ] )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> execution Context, <span class=\"comment\">//创建执行上下文</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span> Environment,<span class=\"comment\">//创建函数环境记录</span></span><br><span class=\"line\">    push execution Context on Stack,<span class=\"comment\">//压入执行上下文栈</span></span><br><span class=\"line\">    OrdinaryCallBindThis(F, calleeContext, thisArgument )<span class=\"comment\">//绑定this</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    execute code</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中绑定this:<a href=\"https://tc39.es/ecma262/#sec-ordinarycallbindthis\"><code>OrdinaryCallBindThis</code></a>就是[[ThisValue]]的绑定规则，<br>其按照以下逻辑严格顺序执行：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">OrdinaryCallBindThis(F, calleeContext, thisArgument ):</span><br><span class=\"line\">       <span class=\"keyword\">if</span>( 箭头函数 ) <span class=\"keyword\">return</span></span><br><span class=\"line\">       <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>( 严格模式 )&#123;</span><br><span class=\"line\">           [[ThisValue]] = thisArgument</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span>( thisArgument 是 <span class=\"literal\">undefined</span> || <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">               [[ThisValue]] = [[GlobalThisValue]]</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">               [[ThisValue]] = thisArgument</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<p>这样看，[[ThisValue]]的取值可以说是很明了了。<br>那么用函数对象的apply，call调用的函数呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">obj.myFun.call(foo);</span><br><span class=\"line\">obj.myFun.apply(foo,<span class=\"number\">1</span>,<span class=\"number\">2</span>);     </span><br></pre></td></tr></table></figure>\n<p>实际执行的依旧是:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Call( obj.myFun, foo);</span><br><span class=\"line\">Call( obj.myFun, foo, <span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<p>因此，call,apply的this绑定跟上文中的this绑定规则是统一的，一招鲜，很直观。</p>\n<p>区别出现在function，用作构造函数的时候:<br>构造函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Bar();</span><br></pre></td></tr></table></figure>\n<p>实际执行的是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Construct( Bar )</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://tc39.es/ecma262/#sec-construct\"><code>Construct ( F [ , argumentsList [ , newTarget ] ] )</code></a>是规范中定义的构造函数调用的抽象方法。<br>处理构造函数时，[[ThisValue]]的绑定规则是:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (是构造函数)&#123;</span><br><span class=\"line\">   thisArgument = &#123;&#125;;<span class=\"comment\">//this = 新建对象</span></span><br><span class=\"line\">   OrdinaryCallBindThis( F, calleeContext, thisArgument );<span class=\"comment\">//调用绑定this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>又回到普通函数的this绑定过程<code>OrdinaryCallBindThis</code>了，不过在调用之前新建了空对象{}作为thisArgument传入：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">OrdinaryCallBindThis(F, calleeContext, thisArgument):</span><br><span class=\"line\">       <span class=\"keyword\">if</span>( 箭头函数 ) <span class=\"keyword\">return</span></span><br><span class=\"line\">       <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>( 严格模式 )&#123;</span><br><span class=\"line\">           [[ThisValue]] = thisArgument</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span>( thisArgument 是 <span class=\"literal\">undefined</span> || <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">               [[ThisValue]] = [[GlobalThisValue]]</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">               [[ThisValue]] = thisArgument</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<p>代入绑定规则里跑下来，构造函数的[[ThisValue]]={}</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>现在可以结束了。</p>\n<p>总结一下，this只有两种情况：</p>\n<ol>\n<li>全局环境下的<code>[[GlobalThisValue]]</code></li>\n<li>函数环境下的<code>[[ThisValue]]</code></li>\n</ol>\n<p><code>[[GlobalThisValue]]</code>就是Realm领域相关的global object，<br><code>[[ThisValue]]</code>则可以总结为通用规则:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">bindThis( thisArgument) :</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( 箭头函数 ) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (构造函数)&#123;</span><br><span class=\"line\">        [[ThisValue]] = &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>( 严格模式 )&#123;</span><br><span class=\"line\">        [[ThisValue]] = thisArgument</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( thisArgument 是 <span class=\"literal\">undefined</span> || <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            [[ThisValue]] = [[GlobalThisValue]]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            [[ThisValue]] = thisArgument</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>或者描述为:</p>\n<ul>\n<li>是箭头函数，则不绑定this</li>\n<li>是构造函数，<code>&#123;&#125;</code></li>\n<li>是通过call/apply调用，则<code>[[ThisValue]]</code> = 调用的第一个参数</li>\n<li>作为对象方法的调用，则<code>[[ThisValue]]</code> = 该对象</li>\n<li>非作为对象方法，而是纯粹的函数调用：<ul>\n<li><code>strict mode</code>，则<code>[[ThisValue]]</code> = <code>undefined</code></li>\n<li>非<code>strict mode</code>， 则<code>[[ThisValue]]</code> = <code>[[GlobalThisValue]]</code></li>\n</ul>\n</li>\n</ul>\n","categories":["Node-js","JavaScript","Essentials"],"tags":["this"]},{"title":"Prototypes, objects","url":"/2020/11/26/Node.js/JavaScript/Object/protptype/","content":"<p>aaa</p>\n","categories":["Node-js","JavaScript","Object"],"tags":["prototype"]},{"title":"目录结构","url":"/2015/10/24/iOS/Persistence/Bundle/iOS_Persistence_file_structure/","content":"<h3 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h3> <img src=\"http://ww4.sinaimg.cn/mw690/bfecc6a2gw1f728jvdecsj20la0n6gnm.jpg\" width = \"383\" height = \"417\"  align=center />\n\n\n<table>\n<thead>\n<tr>\n<th>Directory</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>MyApp.app</td>\n<td>应用程序的Bundle，包括应用程序本身和其所有资源。不可写，其中资源文件可读。<br>这个目录不会被iTunes同步</td>\n</tr>\n<tr>\n<td>Documents/</td>\n<td>使用这个目录来保存用户文件，文档。<br>这个目录会被iTunes同步</td>\n</tr>\n<tr>\n<td>Library/</td>\n<td>非用户文件。如应用程序需要的支持文件，配置文件。<br><em>Library/Application support/</em> 配置文件和支持文件。<br><em>Library/Preferences/</em>  NSUserDefaults的首选项数据。<br><em>Library/Caches/</em> 用以提高性能表现的缓存数据，比如网络数据。<br>这个目录（除了Library/Caches外）会被iTunes同步</td>\n</tr>\n<tr>\n<td>tmp/</td>\n<td>临时数据。当系统需要更多空间时，会选择将此目录清空。<br>这个目录不会被iTunes同步</td>\n</tr>\n</tbody></table>\n<h3 id=\"路径获取\"><a href=\"#路径获取\" class=\"headerlink\" title=\"路径获取\"></a>路径获取</h3><p>可以用两种方式来获取以上常用路径：</p>\n<ol>\n<li>Foundation提供的路径查询函数</li>\n<li>NSFileManager</li>\n</ol>\n<p>效果都一样，只是一个是Foundation层的C函数，一个是更友好的文件操作OC对象提供的方法。</p>\n<h4 id=\"Foundation函数\"><a href=\"#Foundation函数\" class=\"headerlink\" title=\"Foundation函数\"></a>Foundation函数</h4><p>沙盒根目录:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> * <span class=\"built_in\">NSHomeDirectory</span>(<span class=\"keyword\">void</span>);</span><br></pre></td></tr></table></figure>\n\n<p>tem目录：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> * <span class=\"built_in\">NSTemporaryDirectory</span>(<span class=\"keyword\">void</span>);</span><br></pre></td></tr></table></figure>\n<p>Document和Library</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt; * <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSSearchPathDirectory</span> directory,</span><br><span class=\"line\">                                                          <span class=\"built_in\">NSSearchPathDomainMask</span> domainMask, </span><br><span class=\"line\">                                                          <span class=\"built_in\">BOOL</span> expandTilde);</span><br></pre></td></tr></table></figure>\n<p>如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *paths = <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>);</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *docPath = [paths objectAtIndex:<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *paths = <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSLibraryDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>);</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *libPath = [paths objectAtIndex:<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"NSFileManager\"><a href=\"#NSFileManager\" class=\"headerlink\" title=\"NSFileManager\"></a>NSFileManager</h4><p>官方更推荐使用NSFileManager的方法来获取目录：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSURL</span> *&gt; *)URLsForDirectory:(<span class=\"built_in\">NSSearchPathDirectory</span>)directory inDomains:(<span class=\"built_in\">NSSearchPathDomainMask</span>)domainMask;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *URLs = [[<span class=\"built_in\">NSFileManager</span> defaultManager] URLsForDirectory:<span class=\"built_in\">NSDocumentDirectory</span> inDomains:<span class=\"built_in\">NSUserDomainMask</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSURL</span> *documentsURL = URLs[<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *URLs = [[<span class=\"built_in\">NSFileManager</span> defaultManager] URLsForDirectory:<span class=\"built_in\">NSLibraryDirectory</span> inDomains:<span class=\"built_in\">NSUserDomainMask</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSURL</span> *documentsURL = URLs[<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n\n<p>以上的NSFileManager和NSSearchPathForDirectoriesInDomains函数中的参数<em>NSSearchPathDirectory</em>是一个标示需要获取目录的常数。<br>常用的有：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>位置</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NSDocumentDirectory</td>\n<td>Document/</td>\n</tr>\n<tr>\n<td>NSLibraryDirectory</td>\n<td>Library/</td>\n</tr>\n<tr>\n<td>NSCachesDirectory</td>\n<td>Library/Caches</td>\n</tr>\n<tr>\n<td>NSApplicationSupportDirectory</td>\n<td>Library/Application Support</td>\n</tr>\n</tbody></table>\n","categories":["iOS","Persistence","Bundle"],"tags":["file"]},{"title":"Preferences","url":"/2015/10/26/iOS/Persistence/Preferences/iOS_Persistence_Preferences/","content":"<p>首选项可能是目的最明确的持久化方式了。<br>保存用户配置和数据。简单明了。</p>\n<p>首选项文件保存在Library/Preferences/目录下。<br>使用类NSUserDefaults读取和写入。</p>\n","categories":["iOS","Persistence","Preferences"],"tags":["file"]},{"title":"Plist","url":"/2015/10/26/iOS/Persistence/plist/iOS_Persistence_plist/","content":"<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>plist是比较简单的结构化持久化方案。</p>\n<p>所能表达的基本类型包括：</p>\n<table>\n<thead>\n<tr>\n<th>Abstract type</th>\n<th>XML element</th>\n<th>Cocoa class</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>array</td>\n<td>&lt;array&gt;</td>\n<td>NSArray</td>\n</tr>\n<tr>\n<td>dictionary</td>\n<td>&lt;dict&gt;</td>\n<td>NSDictionary</td>\n</tr>\n<tr>\n<td>string</td>\n<td>&lt;string&gt;</td>\n<td>NSString</td>\n</tr>\n<tr>\n<td>data</td>\n<td>&lt;data&gt;</td>\n<td>NSData</td>\n</tr>\n<tr>\n<td>date</td>\n<td>&lt;date&gt;</td>\n<td>NSDate</td>\n</tr>\n<tr>\n<td>number - integer</td>\n<td>&lt;integer&gt;</td>\n<td>NSNumber (intValue)</td>\n</tr>\n<tr>\n<td>number - floating point</td>\n<td>&lt;real&gt;</td>\n<td>NSNumber (floatValue)</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>&lt;true/&gt; or &lt;false/&gt;</td>\n<td>NSNumber (boolValue == YES or boolValue == NO)</td>\n</tr>\n</tbody></table>\n<p>除以上类型之外的一些复制对象可以通过遵从NSCoding协议,利用NSKeyedArchiver转化为NSData类型来表达。<br>例如：UIColor对象：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//to data</span></span><br><span class=\"line\"><span class=\"built_in\">NSData</span> *theData = [<span class=\"built_in\">NSKeyedArchiver</span> archivedDataWithRootObject:aColor];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//to uicolor</span></span><br><span class=\"line\"><span class=\"built_in\">UIColor</span>* aColor = (<span class=\"built_in\">UIColor</span>*)[<span class=\"built_in\">NSKeyedUnarchiver</span> unarchiveObjectWithData:theData] ;  </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"存储格式\"><a href=\"#存储格式\" class=\"headerlink\" title=\"存储格式\"></a>存储格式</h2><p>plist有三种静态存储格式。</p>\n<ul>\n<li>XML</li>\n<li>Binary</li>\n<li>ASCII format</li>\n</ul>\n<p>其中XML具有更佳的可读性和移植性，binary的空间要求最低，ASCII仅可读。<br>平时使用中，一般为了可读性和方便编辑就使用XML格式。<br>为了速度和空间就使用binary格式。ASCII很少使用。<br>所以大家普遍认为的plist就是XML是不正确的。</p>\n<h2 id=\"利用NSPropertyListSerialization进行plist读写\"><a href=\"#利用NSPropertyListSerialization进行plist读写\" class=\"headerlink\" title=\"利用NSPropertyListSerialization进行plist读写\"></a>利用NSPropertyListSerialization进行plist读写</h2><p>NSPropertyListSerialization类可以方便地序列化和反序列化plist对象。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//序列化</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSData</span> *)dataWithPropertyList:(<span class=\"keyword\">id</span>)plist </span><br><span class=\"line\">                          format:(<span class=\"built_in\">NSPropertyListFormat</span>)format </span><br><span class=\"line\">                         options:(<span class=\"built_in\">NSPropertyListWriteOptions</span>)opt </span><br><span class=\"line\">                           error:(<span class=\"keyword\">out</span> <span class=\"built_in\">NSError</span> * _Nullable *)error;</span><br><span class=\"line\">                           </span><br><span class=\"line\"><span class=\"comment\">//反序列化</span></span><br><span class=\"line\">+ (<span class=\"keyword\">id</span>)propertyListWithData:(<span class=\"built_in\">NSData</span> *)data </span><br><span class=\"line\">                   options:(<span class=\"built_in\">NSPropertyListReadOptions</span>)opt </span><br><span class=\"line\">                    format:(<span class=\"built_in\">NSPropertyListFormat</span> *)format </span><br><span class=\"line\">                     error:(<span class=\"keyword\">out</span> <span class=\"built_in\">NSError</span> * _Nullable *)error;</span><br></pre></td></tr></table></figure>\n\n<p>其中：<br>序列化时：NSPropertyListFormat参数可以指定序列化所使用的存储格式，如：XML,binary，ASCII。<br>反序列化时：NSPropertyListReadOptions参数可以控制反序列化之后的plist对象的mutability。</p>\n<h3 id=\"plist写\"><a href=\"#plist写\" class=\"headerlink\" title=\"plist写\"></a>plist写</h3><ol>\n<li>将plist对象序列化为NSData对象</li>\n<li>利用NSData对象进行文件写入</li>\n</ol>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.获取路径</span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *path = [[<span class=\"built_in\">NSBundle</span> mainBundle] pathForResource:<span class=\"string\">@&quot;Data&quot;</span> ofType:<span class=\"string\">@&quot;plist&quot;</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *error;</span><br><span class=\"line\"><span class=\"comment\">//2.序列化</span></span><br><span class=\"line\"><span class=\"built_in\">NSData</span> *xmlData; = [<span class=\"built_in\">NSPropertyListSerialization</span> dataFromPropertyList:plist</span><br><span class=\"line\">                                       format:<span class=\"built_in\">NSPropertyListXMLFormat_v1_0</span></span><br><span class=\"line\">                                       errorDescription:&amp;error];</span><br><span class=\"line\"><span class=\"comment\">//3.写文件</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(xmlData) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;No error creating XML data.&quot;</span>);</span><br><span class=\"line\">    [xmlData writeToFile:path atomically:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"plist读\"><a href=\"#plist读\" class=\"headerlink\" title=\"plist读\"></a>plist读</h3><ol>\n<li>利用NSData进行文件读</li>\n<li>将NSData反序列化为plist对象</li>\n</ol>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.获取路径</span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *path = [[<span class=\"built_in\">NSBundle</span> mainBundle] pathForResource:<span class=\"string\">@&quot;Data&quot;</span> ofType:<span class=\"string\">@&quot;plist&quot;</span>];</span><br><span class=\"line\"><span class=\"comment\">//2.读文件</span></span><br><span class=\"line\"><span class=\"built_in\">NSData</span> *plistData = [<span class=\"built_in\">NSData</span> dataWithContentsOfFile:path];</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *error;</span><br><span class=\"line\"><span class=\"built_in\">NSPropertyListFormat</span> format;</span><br><span class=\"line\"><span class=\"comment\">//3.反序列化</span></span><br><span class=\"line\"><span class=\"keyword\">id</span> plist; = [<span class=\"built_in\">NSPropertyListSerialization</span> propertyListFromData:plistData</span><br><span class=\"line\">                                mutabilityOption:<span class=\"built_in\">NSPropertyListImmutable</span></span><br><span class=\"line\">                                format:&amp;format</span><br><span class=\"line\">                                errorDescription:&amp;error];</span><br><span class=\"line\">                                </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"利用NSDictionary，NSArray进行plist读写\"><a href=\"#利用NSDictionary，NSArray进行plist读写\" class=\"headerlink\" title=\"利用NSDictionary，NSArray进行plist读写\"></a>利用NSDictionary，NSArray进行plist读写</h2><p>NSDictionary，NSArray都有专为Plist设计的类方法和实例方法。</p>\n<p>以NSDictionary为例：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//读</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSDictionary</span>&lt;KeyType,ObjectType&gt; *)dictionaryWithContentsOfFile:(<span class=\"built_in\">NSString</span> *)path;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSDictionary</span>&lt;KeyType,ObjectType&gt; *)dictionaryWithContentsOfURL:(<span class=\"built_in\">NSURL</span> *)url;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//写</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)writeToFile:(<span class=\"built_in\">NSString</span> *)path </span><br><span class=\"line\">         atomically:(<span class=\"built_in\">BOOL</span>)useAuxiliaryFile;</span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)writeToURL:(<span class=\"built_in\">NSURL</span> *)url </span><br><span class=\"line\">        atomically:(<span class=\"built_in\">BOOL</span>)atomically;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>读方法，将从文件中序列化plist对象，但是所生产的plist对象都为immutable，如果需要对mutability进行更多的控制，则还是需要利用NSPropertyListSerialization来进行plist对象的序列化操作。</p>\n</li>\n<li><p>写方法，将逐一递归检查plist对象中的所有对象都是合法的plist类型，如果检查失败，将返回NO，表示写文件失败。如果检查通过，将plist对象序列化后写入文件中。</p>\n</li>\n</ol>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/PropertyLists/Introduction/Introduction.html#//apple_ref/doc/uid/10000048-CJBGDEGD\">Property List Programming Guide</a></p>\n","categories":["iOS","Persistence","Plist"],"tags":["file"]},{"title":"->[ Runtime ]","url":"/2015/09/01/iOS/Objective-C/runtime/Something%20i%20should%20know%20about-Runtime/","content":"<h1 id=\"About\"><a href=\"#About\" class=\"headerlink\" title=\"About\"></a>About</h1><p>今天在看文档，翻到了Runtime。</p>\n<blockquote><p>An object-oriented approach to application development makes programs more intuitive to design, faster to develop, more amenable to modification, and easier to understand. Most object-oriented development environments consist of at least three parts:<br>● A library of objects<br>● A set of development tools<br>● An object-oriented programming language and support library</p><footer><strong>IOS Developer Library</strong><cite><a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/OOP_ObjC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40005149\">Object-Oriented Programming with Objective-C</a></cite></footer></blockquote>\n\n<span id=\"more\"></span>\n\n<p>以上提到面向对象开发环境至少由3部分组成：</p>\n<ul>\n<li>A library of objects</li>\n<li>A set of development tools</li>\n<li>An object-oriented programming <em>language</em> and <em>support library</em></li>\n</ul>\n<p>关于这3部分我是这样想的：</p>\n<ul>\n<li>A library of objects <em>Cocoa丰富的 Framework.</em></li>\n<li>A set of development tools <em>Xcode,Clang,Instruments...</em></li>\n<li>An object-oriented programming language and support library <em>Objective-C和Runtime。</em></li>\n</ul>\n<p>这里的“support library”我想大概离不开Runtime Library。<br>Objective-C是在C的基础上进行的面向对象特性的扩展。<br>而Runtime system是Objective-C的基石，Objective-C语言的动态特性和面向对象功能和消息机制都由它来完成，被视作 Objective-C的操作系统。    </p>\n<blockquote>\n<p>The Objective-C language defers as many decisions as it can from compile time and link time to runtime. Whenever possible, it does things dynamically. This means that the language requires not just a compiler, but also a runtime system to execute the compiled code. The runtime system acts as a kind of operating system for the Objective-C language; it’s what makes the language work.</p>\n</blockquote>\n<p>这里是关于runtime的学习笔记，方便查阅：</p>\n<h1 id=\"首先，为什么需要Runtime\"><a href=\"#首先，为什么需要Runtime\" class=\"headerlink\" title=\"首先，为什么需要Runtime\"></a>首先，为什么需要Runtime</h1><p>学习一个东西之前，我觉得最好先学习为什么这个东西存在。<br>所谓，“存在即合理”，那么，先了解一下这个合理性？<br>笔记：<br><i class=\"fa fa-book\"></i> <a href=\"/2015/09/04/iOS/Objective-C/runtime/iOS_objc_runtime_explanation/\">笔记——Runtime：Why runtime?</a></p>\n<h1 id=\"Runtime之前的compile-time\"><a href=\"#Runtime之前的compile-time\" class=\"headerlink\" title=\"Runtime之前的compile time\"></a>Runtime之前的compile time</h1><p>Objective-C 是一个动态语言，它需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。<br>而与此同时，Runtime的正确工作也需要编译器支持：</p>\n<ul>\n<li>在编译阶段：编译器生成用于运行阶段数据结构，改写源代码为支持runtime工作的代码，给runtime system提供运行时支持。</li>\n<li>在runtime阶段：Objective-C<span class=\"text-success\">运行时系统（runtime system）</span>根据编译器在编译阶段提供的数据结构和方法为程序提供运行时支持，支持程序正确运行。</li>\n</ul>\n<p>学习runtime，我觉得最好从编译阶段开始，看一看编译器，对Objective-C的源码做了些什么准备。</p>\n<p>笔记：<br><i class=\"fa fa-book\"></i> <a href=\"/2015/09/04/iOS/Objective-C/runtime/iOS_objc_runtime_compiler/\">关于编译阶段。</a></p>\n<h1 id=\"After-Lauch-Before-main\"><a href=\"#After-Lauch-Before-main\" class=\"headerlink\" title=\"After Lauch,Before main()\"></a>After Lauch,Before main()</h1><p>当程序启动后，系统调用fork为程序创建进程，调用execve将可执行文件载入内存，并执行。<br>由于我们可执行程序的执行还依赖许多其他的系统库或第三方库。在将可执行文件载入内存的同时，系统根据Mach-head中的依赖信息同时展开库的动态加载工作。<br>在这个阶段，runtime库与其他系统库被载入内存，各自引导初始化后，做好执行的准备。这一切都由dyld来完成。<br>关于dyld，大概了解一下：</p>\n<p>笔记：<br><i class=\"fa fa-book\"></i> <a href=\"/2015/09/11/iOS/Objective-C/runtime/iOS_objc_runtime_lauch/\">Runtime：After lauch，关于dyld</a></p>\n<h1 id=\"Runtime数据结构\"><a href=\"#Runtime数据结构\" class=\"headerlink\" title=\"Runtime数据结构\"></a>Runtime数据结构</h1><p>首先，Objective-C即面向对象的C语言，是在C的基础上给C提供了面向对象支持。<br>如何提供的呢。Objective-C在支持所有C特性的同时，将C语法进行了一个面向对象的包装。<br>比如说提供了面向对象层的数据结构：如Class，Object。<br>另外，C语言的方法调用（method call）也用消息（message sending）来包装。<br>之所以用“包装”这个词，是因为,本质上，Class、Object还是C结构体，消息传递本质还是方法调用。</p>\n<p>在link阶段，每个app都会链接运行时库runtime library(libobjc.A.dylib)，运行时库libobjc.A.dylib是Objective-C动态性和面向对象的基础，提供了一系列数据结构和与runtime System交互的api函数，比如上文提到的Class，Object，消息传递等。</p>\n<p>笔记：<br><i class=\"fa fa-book\"></i> <a href=\"/2015/09/15/iOS/Objective-C/runtime/iOS_objc_runtime_class_object/\">笔记——class &amp; obejct</a><br><i class=\"fa fa-book\"></i> <a href=\"/2015/09/25/iOS/Objective-C/runtime/iOS_objc_runtime_class_metaclass/\">笔记——class &amp; metaclass</a><br><i class=\"fa fa-book\"></i> <a href=\"/2015/10/15/iOS/Objective-C/runtime/iOS_objc_runtime_self_super/\">笔记——self &amp; super</a></p>\n","categories":["iOS","Objective-C","Runtime"],"tags":["runtime"]},{"title":"Runtime：Class & metaclass","url":"/2015/09/25/iOS/Objective-C/runtime/iOS_objc_runtime_class_metaclass/","content":"<h1 id=\"about\"><a href=\"#about\" class=\"headerlink\" title=\"about\"></a>about</h1><p>关于class结构：<br><a href=\"http://opensource.apple.com/source/objc4/objc4-647/runtime/objc.h\">/runtime/objc.h</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// An opaque type that represents an Objective-C class.</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_class</span> *<span class=\"title\">Class</span>;</span></span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_class</span> &#123;</span></span><br><span class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> !__OBJC2__</span></span><br><span class=\"line\">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name                                         OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_ivar_list</span> *<span class=\"title\">ivars</span>                             <span class=\"title\">OBJC2_UNAVAILABLE</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_method_list</span> **<span class=\"title\">methodLists</span>                    <span class=\"title\">OBJC2_UNAVAILABLE</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_cache</span> *<span class=\"title\">cache</span>                                 <span class=\"title\">OBJC2_UNAVAILABLE</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_protocol_list</span> *<span class=\"title\">protocols</span>                     <span class=\"title\">OBJC2_UNAVAILABLE</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125; OBJC2_UNAVAILABLE;</span><br><span class=\"line\"><span class=\"comment\">/* Use `Class` instead of `struct objc_class *` */</span></span><br></pre></td></tr></table></figure>\n<p>之前学习过了，Class类型的表示是一个指向objc_class结构体的指针，objc_class结构体存储了描述类的对象的所有信息。<br>有趣的是：这个类结构体的第一个数据居然是指向另一个Class的isa指针。</p>\n<p>对象的<code>Class isa</code>是为了找到其说明书：Class所在的位置。<br>那么类的<code>Class isa</code>又是干什么的。<br>事实是：类也是对象</p>\n<h1 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a>class</h1><p>每个Objective-C的类也是一个对象，类也有isa指针，也可以响应消息。</p>\n<p>在方法定义时的<code>+</code>(加号)表示定义的正是类方法。如<code>[NSObject alloc]</code>就是向类发送一条消息;事实上，最常见的<code>alloc</code>什么的就是类方法：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> object = [[<span class=\"built_in\">NSObject</span> alloc]init];</span><br></pre></td></tr></table></figure>\n<p>我们是向NSObject类发送的消息，而不是对象。<br>那问题来了，<strong>之前说对象代表一个类的实例；既然类也是对象，它是什么的实例呢？</strong><br>另外，<strong>类解释对象的数据，持有对象的方法；既然类也有方法，那么类的方法被什么持有呢？</strong></p>\n<p>答案是：Class是metaclass的实例,metaclass持有类方法。</p>\n<h1 id=\"metaclass\"><a href=\"#metaclass\" class=\"headerlink\" title=\"metaclass\"></a>metaclass</h1><blockquote>\n<p>The compiler also builds a ``meta-class object&#39;&#39; for each class. It describes the class object just as the class object describes instances of the class. But while you can send messages to instances and to the class object, the meta-class object is used only internally by the run-time system.</p>\n</blockquote>\n<p>对象和类通过<code>Class isa</code>指针，在概念上神奇地相同了。同为对象。<br>metaclass 是类对象的类,由runtime system创建及维护。它拥有和其他类一样的数据结构，也是<code>struct objc_class</code>也有isa，super_class,方法列表。</p>\n<p>正如类描述了对象；metaclass（元类）描述了类。<br>正如类为对象描述了实例方法；同理：metaclass元类的方法列表描述的正是类的类方法。<br>正如当向对象发送消息时<code>objc_msgSend</code>查找类的方法列表（实例方法）以决定方法调用；同理：当向类发送消息时，<code>objc_msgSend</code>查找metaclass的方法列表（类方法）以决定方法调用。</p>\n<p>在<a href=\"/2015/09/04/iOS/Objective-C/runtime/iOS_objc_runtime_compiler/#%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%EF%BC%88Semantic_Analysis%EF%BC%89%EF%BC%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%94%AF%E6%8C%81\">关于compiler的笔记</a>中，有这样一个关于编译器会为方法声明添加2个隐藏参数的例子，现在在来重新看一下：<br>首先，编译器会对消息传递进行objc_msgSend改写，会为方法声明添加2个隐藏参数：</p>\n<ol>\n<li>self  代表当前消息的接收者</li>\n<li>_cmd  代表当前消息的selector</li>\n</ol>\n<p>如下例：给NSObject增加2个方法：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSObject</span>(<span class=\"title\">MyObject</span>)</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)sayHello;</span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)sayHello;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)sayHello&#123;&#125;;</span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)sayHello&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>使用命令<code>clang -Xclang -ast-dump main.m</code>后可以看到：</p>\n<figure class=\"highlight x86asm\"><table><tr><td class=\"code\"><pre><span class=\"line\">|-ObjCCategoryDecl <span class=\"number\">0x1055d20c0</span> &lt;main<span class=\"number\">.</span>m:<span class=\"number\">15</span>:<span class=\"number\">1</span>, line:<span class=\"number\">20</span>:<span class=\"number\">2</span>&gt; line:<span class=\"number\">15</span>:<span class=\"number\">12</span> MyObject</span><br><span class=\"line\">| |-ObjCInterface <span class=\"number\">0x1033ab3b0</span> <span class=\"string\">&#x27;NSObject&#x27;</span></span><br><span class=\"line\">| |-ObjCCategoryImpl <span class=\"number\">0x1055d2290</span> <span class=\"string\">&#x27;NSObject&#x27;</span></span><br><span class=\"line\">| |-ObjCMethodDecl <span class=\"number\">0x1055d2160</span> &lt;line:<span class=\"number\">17</span>:<span class=\"number\">1</span>, col:<span class=\"number\">17</span>&gt; col:<span class=\"number\">1</span> - sayHello <span class=\"string\">&#x27;void&#x27;</span></span><br><span class=\"line\">| <span class=\"string\">`-ObjCMethodDecl 0x1055d2200 &lt;line:18:1, col:17&gt; col:1 + sayHello &#x27;void&#x27;</span></span><br><span class=\"line\"><span class=\"string\">|-ObjCCategoryImplDecl 0x1055d2290 &lt;line:22:1, line:33:1&gt; line:22:17 NSObject</span></span><br><span class=\"line\"><span class=\"string\">| |-ObjCInterface 0x1033ab3b0 &#x27;NSObject&#x27;</span></span><br><span class=\"line\"><span class=\"string\">| |-ObjCCategory 0x1055d20c0 &#x27;MyObject&#x27;</span></span><br><span class=\"line\"><span class=\"string\">| |-ObjCMethodDecl 0x1055d2310 &lt;line:24:1, line:26:1&gt; line:24:1 - sayHello &#x27;void&#x27;</span></span><br><span class=\"line\"><span class=\"string\">| | |-ImplicitParamDecl 0x1055d2440 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit self &#x27;NSObject *&#x27;</span></span><br><span class=\"line\"><span class=\"string\">| | |-ImplicitParamDecl 0x1055d24a0 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit _cmd &#x27;SEL&#x27;:&#x27;SEL *&#x27;</span></span><br><span class=\"line\"><span class=\"string\">| | `</span>-CompoundStmt <span class=\"number\">0x1055d24f8</span> &lt;col:<span class=\"number\">17</span>, line:<span class=\"number\">26</span>:<span class=\"number\">1</span>&gt;</span><br><span class=\"line\">| <span class=\"string\">`-ObjCMethodDecl 0x1055d23b0 &lt;line:28:1, line:30:1&gt; line:28:1 + sayHello &#x27;void&#x27;</span></span><br><span class=\"line\"><span class=\"string\">|   |-ImplicitParamDecl 0x1055d2510 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit self &#x27;Class&#x27;:&#x27;Class&#x27;</span></span><br><span class=\"line\"><span class=\"string\">|   |-ImplicitParamDecl 0x1055d2570 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit _cmd &#x27;SEL&#x27;:&#x27;SEL *&#x27;</span></span><br><span class=\"line\"><span class=\"string\">|   `</span>-CompoundStmt <span class=\"number\">0x1055d25c8</span> &lt;col:<span class=\"number\">17</span>, line:<span class=\"number\">30</span>:<span class=\"number\">1</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>仔细看一下：<br>在9-11行，NSObject实例方法<code>- (void)sayHello</code>增添的两个隐藏参数是：</p>\n<figure class=\"highlight x86asm\"><table><tr><td class=\"code\"><pre><span class=\"line\">implicit self <span class=\"string\">&#x27;NSObject *&#x27;</span></span><br><span class=\"line\">implicit _cmd <span class=\"string\">&#x27;SEL&#x27;</span>:<span class=\"string\">&#x27;SEL *&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>在13-15行，NSObject类方法<code>+ (void)sayHello</code>增添的两个隐藏参数是：</p>\n<figure class=\"highlight x86asm\"><table><tr><td class=\"code\"><pre><span class=\"line\">implicit self <span class=\"string\">&#x27;Class&#x27;</span>:<span class=\"string\">&#x27;Class&#x27;</span></span><br><span class=\"line\">implicit _cmd <span class=\"string\">&#x27;SEL&#x27;</span>:<span class=\"string\">&#x27;SEL *&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>可以看到:<br>NSObject中实例方法<code>- (void)sayHello</code>：</p>\n<ul>\n<li>其消息接收者——<code>self</code>是<code>NSObject*</code> 是指向NSObject对象的指针，即实例对象。</li>\n<li>方法<code>- (void)sayHello</code>的信息和实现被NSObject Class持有。</li>\n<li>NSObject object收到消息后，通过对象结构中的<code>Class isa</code>找到NSObject Class搜索方法列表。</li>\n</ul>\n<p>NSObject中类方法<code>+ (void)sayHello</code>：</p>\n<ul>\n<li>NSObject类方法消息接收者——<code>self</code>是<code>Class</code>,这个<code>Class</code>是NSObject类对象，是NSObject-metaclass的实例。</li>\n<li>方法<code>+ (void)sayHello&#123;&#125;;</code>的信息和实现被NSObject的metaclass持有。</li>\n<li>NSObject Class收到消息后，通过类结构中的<code>Class isa</code>找到metaclass搜索方法列表。</li>\n</ul>\n<h1 id=\"metaclass-39-s-Class-isa\"><a href=\"#metaclass-39-s-Class-isa\" class=\"headerlink\" title=\"metaclass&#39;s Class isa\"></a>metaclass&#39;s <code>Class isa</code></h1><p>刚才已经说了metaclass 是类对象的类,拥有和其他类一样的数据结构，也是<code>struct objc_class</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_class</span> &#123;</span></span><br><span class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> !__OBJC2__</span></span><br><span class=\"line\">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name                                         OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_ivar_list</span> *<span class=\"title\">ivars</span>                             <span class=\"title\">OBJC2_UNAVAILABLE</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_method_list</span> **<span class=\"title\">methodLists</span>                    <span class=\"title\">OBJC2_UNAVAILABLE</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_cache</span> *<span class=\"title\">cache</span>                                 <span class=\"title\">OBJC2_UNAVAILABLE</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_protocol_list</span> *<span class=\"title\">protocols</span>                     <span class=\"title\">OBJC2_UNAVAILABLE</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125; OBJC2_UNAVAILABLE;</span><br><span class=\"line\"><span class=\"comment\">/* Use `Class` instead of `struct objc_class *` */</span></span><br></pre></td></tr></table></figure>\n<p>那么metaclass又有一个<code>Class isa</code>，这意味着，其实meta-class也是一个对象。那么问题来了，<strong>无止境了吗？</strong><br>鉴于<code>Class isa</code>其实是用来描述对象的数据信息和方法的。我们要用到对象，实例方法，要用到类，类方法，但是元类的信息和方法我们用不到也不存在，它只是被runtime利用和维护。所以元类的信息其实我们并不关心。<br>鉴于此，基类的metaclass的isa指向自己来完成闭环。这里说的是__基类__而不是__父类__。</p>\n<p>看看runtime源码：</p>\n<p><a href=\"http://opensource.apple.com/source/objc4/objc4-647/runtime/objc-runtime-new.h\">/runtime/objc-runtime-new.h</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isMetaClass</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    assert(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    assert(isRealized());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data()-&gt;ro-&gt;flags &amp; RO_META;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// NOT identical to this-&gt;ISA when this is a metaclass</span></span><br><span class=\"line\"><span class=\"function\">Class <span class=\"title\">getMeta</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isMetaClass()) <span class=\"keyword\">return</span> (Class)<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;ISA();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isRootClass</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> superclass == nil;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isRootMetaclass</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ISA() == (Class)<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>什么是根元类：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isRootMetaclass</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ISA() == (Class)<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>元类是自己的就是根元类。这就是：<em>基类的metaclass的isa指向自己来完成闭环</em><br>结合代码，再引用一篇博客中看到的图：<br><img id=\"fancybox\" src=\"/img/class_metaclass.png\"></p>\n<h1 id=\"metaclass‘s-super-class\"><a href=\"#metaclass‘s-super-class\" class=\"headerlink\" title=\"metaclass‘s super_class\"></a>metaclass‘s super_class</h1><p>鉴于metaclass也是<code>struct objc_class</code>，metaclass的<code>struct objc_class</code>中的superclass也和类，对象的superclass一样用于指向其超类。<br>然而，看了上面的代码和上图之后有点疑惑：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isRootClass</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> superclass == nil;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果没有超类，则是根类。<br>NSObject的超类指向nil，其是根类；<br>按理说NSObject的metaclass的应该是超级根类（元根类）啊，而为什么其superclass不但不是nil，还指向NSObject呢？</p>\n<p>试想：NSObject作为继承链上的基类，定义了Objective-C对象所必须的共有行为：如内存管理，等等。<br>还记得吗。实例对象是对象，类对象是对象，metaclass也是对象，意思是metaclass在一定程度上也需要这些作为对象的基本能力。<br>对象的这些基本行为中的实例方法描述在NSObject中，类方法描述在NSObject’s metaclass中；NSObject’s metaclass作为对象的基本行为也应该是从NSObject’s metaclass‘s metaclass来获取吗？然而并不是！因为上文已经说了：NSObject’s metaclass‘s metaclass是它自己，它自己没有这些信息。怎么办呢？<br>它采取了继承自NSObject这样的一个简单的方式，其结果是NSObject‘s metaclass同所有Objective-C对象一样都是从NSObject根类中获取自己作为对象的基本能力。<br>所以，可以肯定的是，在Mach-O中的<code>__OBJC segment</code>中，NSObject是作为对象的一个基本的存在。<br>这也正好解释了NSObject的重要性和为什么我们的对象基本都要继承自NSObject。</p>\n<p>NSObject’s metaclass的superclass指向NSObject的结果是：<br><em>NSObject的继承链下，所有对象，类，元类都可以响应NSObject的实例方法。</em><br>因为，当进行方法查找时：</p>\n<ul>\n<li>对象：isa到NSOject查找，bingo</li>\n<li>类：isa到NSObject’s metaclass查找，找不到，追溯到superclass——NSObject，bingo</li>\n<li>metaclass：isa到了自己，找不到，追溯到superclass——NSObject，bingo</li>\n</ul>\n<p><em>NSObject的继承链下，所有类，元类都可以响应NSObject的类方法。</em><br>因为，当进行方法查找时：</p>\n<ul>\n<li>类：isa到NSObject’s metaclass查找，bingo</li>\n<li>metaclass：isa到了自己，bingo</li>\n</ul>\n<h1 id=\"end\"><a href=\"#end\" class=\"headerlink\" title=\"end\"></a>end</h1><p>就一句话：<br>实例对象是对象，类对象是对象，metaclass也是对象。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"http://opensource.apple.com/source/objc4/objc4-647/runtime/objc\">/runtime/objc-Source</a><br><a href=\"http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html\">what-is-meta-class-in-objective-c</a><br><a href=\"http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html\">Classes and metaclasses</a></p>\n","categories":["iOS","Objective-C","Runtime"],"tags":["runtime","metaclass"]},{"title":"Runtime：Why runtime?","url":"/2015/09/04/iOS/Objective-C/runtime/iOS_objc_runtime_explanation/","content":"<p>学习一个东西之前，我觉得最好先想想为什么这个东西存在。<br>所谓，“存在即合理”，那么，先了解一下这个合理性？</p>\n<h1 id=\"So-why-Runtime\"><a href=\"#So-why-Runtime\" class=\"headerlink\" title=\"So, why Runtime?\"></a>So, why Runtime?</h1><p>每个人都在教科书上看到过：“面向过程编程”，“面向对象编程”。<br>有好多好多的书阐释什么是面向过程，什么是面向对象分析，什么是面向对象设计。<br>在我看来：它们只是两种不同的思维方式。<br>编写程序时，这2种不同的思维方式，产生出的是的两种不同代码组织形式。<br>就好像2个思路不同的作者讲述同一个故事：一个流水账般地从故事的开始讲到结束。一个把故事组织成从不同主人翁的角度来徐徐道出。<br>然而，他们讲的都是同一个故事。</p>\n<p>程序是码农讲述给CPU听的故事。<br>只要CPU能听懂，那么程序就是OK的。CPU不管这个故事是以什么方式讲述的，它不care故事的叙事结构。<br>如何讲述这个故事，纯粹是码农自己的事。</p>\n<p>然而，CPU的头脑是简单的，只接受流水式的故事。所以在以前，码农们为了CPU能听懂，都流水式地讲故事。<br>有些码农发现这个方式，很累，不符合自己的思考方式。想用更符合思考方式的方法来有组织，分对象地讲。<br>他们在既有的叙事结构上增加了对象，消息等概念。但可惜，CPU不明白你在说什么。<br>因为CPU只听得懂简单的流水式故事，鉴于此，码农在叙述故事的同时，还必须增加对象，方法列表等额外的信息来进行必要的的阐释和说明：对象是什么，消息怎么处理，这个对象你可以去哪里哪里查到，这个类在内存哪里哪里。反正不懂的你去那里查就行了。</p>\n<p>runtime干的就是这个工作，是对面向过程和面向对象2种叙事风格转换过程中的起承转合。<br>这大概就是runtime的意义了。</p>\n<h1 id=\"Still-Why\"><a href=\"#Still-Why\" class=\"headerlink\" title=\"Still Why?\"></a>Still Why?</h1><p>综上，所谓：“面向过程编程”，“面向对象编程”，不过是程序编写时的2种不同思维方式。<br>并没有硬性的非要用哪一种？<br>因为不管用哪一种方式讲这个故事。讲的都是同一个故事。也就是说：用面向对象完成的讲述的故事，面向过程一样可以讲述出来。反之亦然。<br>C就是面向过程的语言，不支持所谓的面向对象特性。但是我们一样可以用C来面向对象。<br>所需要做的就是把我们希望表达的概念和工作机制用合适的方式表达出来而已。</p>\n<p>举个栗子：<br>面向对象，首先我们有Class的概念。怎么表达呢？<br>可以用struct来表达一个封装的Class(事实上，C++，Objective-C也是这么做的):</p>\n<p>用一个类来表达人类，增添3个基本属性：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Human</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> gender;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>  age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它在内存中是这样：</p>\n<pre><code>           Human\n\n           +-------------+\n           |name         | 10bytes\n           |             |\n           +-------------+\n           |gender       | 1bytes\n           +-------------+\n           |age          | 4bytes\n           +-------------+\n</code></pre>\n<p>结构很明晰，我们只要只要对象的起始地址，结束地址，各属性所占大小，就可以根据起始地址访问各个属性。</p>\n<p>现在，再来表达一下继承：</p>\n<p>新增加男孩，女孩类，它们都是人类，但有各自的独有属性。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Boy</span>&#123;</span></span><br><span class=\"line\">    Human human;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> powerValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Girl</span>&#123;</span></span><br><span class=\"line\">    Human human;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> beautyValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>它们在内存中也只是在原Human结构上再增加了自己的变量：</p>\n<pre><code>Boy                          Girl\n\n+-------------+              +-------------+\n|name         | 10bytes      |name         | 10bytes\n|             |              |             |\n+-------------+              +-------------+\n|gender       | 1bytes       |gender       | 1bytes\n+-------------+              +-------------+\n|age          | 4bytes       |age          | 4bytes\n+-------------+              +-------------+\n|powerValue   | 4bytes       |beautyValue  | 4bytes\n+-------------+              +-------------+\n</code></pre>\n<p>从内存来看，父类Human和子类，Girl，Boy在前面的字节都是完全一样的。我们可以用Human的指针引用其子类Boy，Girl，在需要的时候在强制转换来表达特定的类型。</p>\n<p>下面在来表达一下类的行为（方法）：<br>Boy和Girl都有玩的行为。但是它们所玩的内容不一样，如何表示Boy和Girl子类对同一个行为的不同实现（多态）：</p>\n<p>新增加一个play函数，它接受对象为参数，根据对象的不同调用不同的玩的方法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">(Human* human,<span class=\"keyword\">int</span> hour)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( human-&gt;gender == BOY ) </span><br><span class=\"line\">        playFootball(hour);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        playDoll(hour);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Play方法只是简单地针对不同的对象选择不同的方法实现。</p>\n<p>接下来，我们希望不但要为不同对象调用不同的实现，我们还想在它们各自玩的方法中访问对象的实例进行操作，或者在方法中在调用对象的其他行为。<br>需要做的就是在方法调用中，增加一个对象参数：</p>\n<p>让 playFootball和playDoll也接受所要操作的对象参数。让它们可以针对特定对象进行操作：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">(Human* human,<span class=\"keyword\">int</span> hour)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( human-&gt;gender == BOY ) </span><br><span class=\"line\">        playFootball((Boy*)human,hour);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        playDoll((Girl*)human,hour);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后这样调用这个Play方法让一个Boy的实例对象玩2个小时，一个Girl实例对象玩3个小时：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">play(boy,<span class=\"number\">2</span>);   </span><br><span class=\"line\">play(girl,<span class=\"number\">3</span>); </span><br></pre></td></tr></table></figure>\n<p>在这里，我们通过在第一个参数传入对象指针来明确是对具体哪一个对象调用方法和该对象的类型。<br>例如：可以在方法中这样访问对象的实例变量：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">playFootball</span><span class=\"params\">(Human *human,<span class=\"keyword\">int</span> hour)</span></span>&#123;</span><br><span class=\"line\">    human-&gt;powerValue = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"comment\">//....</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了更明确这个参数的目的。可以把它取名为：<code>self</code>或者<code>this</code>。（事实上，Objective-C的消息机制也是这么做的）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">playFootball</span><span class=\"params\">(Human *self,<span class=\"keyword\">int</span> hour)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(self-&gt;powerValue &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    self-&gt;age = <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"comment\">//....</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们还只是在对象外部定义了方法，然后去针对对象而调用不同的方法实现。<br>如何表达面向对象中成员函数的概念呢？<br>只需要在类结构中添加函数指针成员变量，让它们分别指向函数的实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Human</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> gender;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>  age;</span><br><span class=\"line\">    <span class=\"comment\">//function</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span>(*play)(Human *self,<span class=\"keyword\">int</span> hour);</span><br><span class=\"line\">    <span class=\"keyword\">void</span>(*rest)(Human *self);</span><br><span class=\"line\">&#125;\t</span><br></pre></td></tr></table></figure>\n<p>然后在实例化对象时，让方法指向对象的特有实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">Human human;</span><br><span class=\"line\">Boy jack;</span><br><span class=\"line\">Girl rose;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">human.play = super_play;</span><br><span class=\"line\">human.rest = super_rest;</span><br><span class=\"line\"></span><br><span class=\"line\">jack.play = playFootBall;</span><br><span class=\"line\">jack.rest = watchTV;</span><br><span class=\"line\"></span><br><span class=\"line\">rose.play = playDoll;</span><br><span class=\"line\">rose.rest = bath;</span><br></pre></td></tr></table></figure>\n<p>之后就可以这样来调用成员函数让它们分别玩起来：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">jack.play(&amp;jack,<span class=\"number\">2</span>);</span><br><span class=\"line\">rose.play(&amp;rose,<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n<p>这样的确实现了对成员函数的调用。但是却很不方便：</p>\n<ol>\n<li>如果我们为一个类创建多个对象，则需要为每个对象赋值其成员函数指针。这样，每个对象都持有其所有成员函数指针。对象的成员函数实现是一致的，在此前提下，每个对象都对一个相同的函数指针持有引用会产生很多问题。明显的就有：初始化复杂的，维护困难，空间浪费巨大。</li>\n<li>没有办法调用父类的成员函数。因为函数指针在初始化时被绑定了，且没有针对父类函数的引用。</li>\n</ol>\n<p>所以，最好是把成员函数剥离出来，让一个类的所有对象共享函数实现。<br>具体做法是设计一个结构保存函数列表（事实上 ，Objective-C也是这么做的。当然，我是说大体上）：</p>\n<p>新建一个结构表达Human类的所有行为，包括的信息有它的方法，方法数，方法所在空间。<br>依例也建立一个Boy子类的行为结构，表达子类的方法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Human superclass&#x27;s method</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HumanClassMethod</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> method_count;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> method_size;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*play)(Human* self,<span class=\"keyword\">int</span> hour);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*rest)(Human* self);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//Boy subclass&#x27;s method</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BoyClassMethod</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> method_count;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> method_size;</span><br><span class=\"line\">    <span class=\"comment\">//super&#x27;s method first</span></span><br><span class=\"line\">    HumanClassMethod *super_method_list,</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*play)(Human* self,<span class=\"keyword\">int</span> hour);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*rest)(Human* self);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数列表结构中保存有</p>\n<ol>\n<li>函数个数，</li>\n<li>函数列表结构所占大小的信息，</li>\n<li>函数列表——每一个函数指针指向函数的具体实现。</li>\n</ol>\n<p>其中1,2这两个信息足以让我访问到结构中保存的每一个函数指针。<br>函数列表所罗列的则是每个行为的具体实现。<br>类的每个对象都可以根据这些信息在内存中找到函数实现，并予以调用。</p>\n<p>在使用类和对象前，提前准备好这些含有类成员函数信息的结构数据结构，让所有类对象可以共享：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">HumanClassMethod human_method_list = &#123;</span><br><span class=\"line\">    super_play,</span><br><span class=\"line\">    super_rest</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">BoyClassMethod boy_method_list = &#123;</span><br><span class=\"line\">    &amp;human_method_list,</span><br><span class=\"line\">    playFootBall,</span><br><span class=\"line\">    watchTV</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>最后，在类的成员中添加指向函数列表结构的指针，使其表达为类的成员函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Human</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> gender;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>  age;</span><br><span class=\"line\">    <span class=\"comment\">//function</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HumanClassMethod</span> *<span class=\"title\">method_list</span>;</span></span><br><span class=\"line\">&#125;\t</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Boy</span>&#123;</span></span><br><span class=\"line\">    Human human;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> powerValue;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BoyClassMethod</span> *<span class=\"title\">method_list</span>;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，当我们实例化对象时，让对象的函数列表指针指向之前准备好的类的函数列表：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">Boy jack;</span><br><span class=\"line\">Boy tom;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">jack.method_list = &amp;boy_method_list;</span><br><span class=\"line\">tom.method_list =  &amp;boy_method_list;</span><br></pre></td></tr></table></figure>\n<p>对象成员函数的调用就变成调用类函数表中的函数实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">jack.method_list-&gt;play(&amp;jack,<span class=\"number\">2</span>);</span><br><span class=\"line\">tom.method_list-&gt;play(&amp;tom,<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n<p>甚至还可以调用父类的函数实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">jack.method_list-&gt;super_method_list-&gt;play(&amp;jack,<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<p>到这里看起来，似乎越来越面向对象了。<br>接下来，我们还可以设计更好的方法调用机制：比如为方法增加方法名和方法实现的映射，在方法调用时，先搜索方法结构中是否存在这个方法，再进行调用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">method</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span>* method_name;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (IMP*)(id* self,...);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看上去越来越眼熟了。<br>当然，以上结构和方法只是尽量进行概念的表达。要完成完整的面向对象，还需要很多工作和设计：我们可以为类结构加入super指针，用来引用类的父类。可以为类结构的方法列表设计其他方法查找机制。。。等等等等。<br>总之，一切需要的特性。其实都可以用面向过程的C来实现。<br>因为：就像本文一开始提到的：“面向对象”和“面向过程”仅仅是2种不同的思维方式：<br>不管用哪一种方式讲故事。讲的都是同一个故事。</p>\n<h1 id=\"Answer\"><a href=\"#Answer\" class=\"headerlink\" title=\"Answer\"></a>Answer</h1><p>现在回到咱们的问题上：为什么要存在这个runtime system。<br>如上所述我们知道：面向过程的语言也可以用面向对象的思维来进行编程。需要转换的只是数据的抽象，方法调用机制的转换以及其他一些概念的转变。<br>这些仅仅是思维概念的不同和逻辑的改变。</p>\n<ol>\n<li><p>为了改变故事的叙事结构，我们不需要重新设计一门外语来讲这个故事。<br>增加面向对象特性，我们也不需要非得将一个既有语言彻底颠覆，或者重新设计一个语言(当然，你也可以这么做）。如果比较懒的话，只需要在原有语言的基础上，清楚地抽象出我们需要的数据模型，实现需要的特性和机制就可以达到目的。<br>（比如在C的基础上增加面向对象的概念和机制而由来的Objective-C）</p>\n</li>\n<li><p>再者，没人会在每次编写的时候，都重新抽象一套数据，设计一套方法调用机制，或将之前的设计重新在写一次。这一套概念的转陈肯定是一个一劳永逸的系统。编写一次就好。</p>\n</li>\n</ol>\n<p>综上，Objective-C把其面向对象的数据抽象，类特性，方法查找机制，协议，分类等它的设计哲学都统一放在了runtime中，供每一个用C来讲面向对象故事的程序使用。<br>我想这就是runtime的由来。</p>\n<p>所以，把runtime形容成面向过程C的面向对象概念转换说明书，也不为过。<br>你按你喜欢的面向对象来讲故事就好了，其他CPU什么的听不懂的，runtime来帮你解决。<br>这大概就是runtime起承转合的意义。</p>\n","categories":["iOS","Objective-C","Runtime"],"tags":["runtime"]},{"title":"Runtime：After lauch，关于dyld","url":"/2015/09/11/iOS/Objective-C/runtime/iOS_objc_runtime_lauch/","content":"<h1 id=\"续上文\"><a href=\"#续上文\" class=\"headerlink\" title=\"续上文\"></a>续上文</h1><p>在前面的笔记的最后引出了新问题：<br>在a.out之后，程序正式开始之前（main函数开始执行），Runtime又是如何加载进来的呢？</p>\n<p>这里以加载runtime为例来展开，笔记一下dyld：</p>\n<h1 id=\"about\"><a href=\"#about\" class=\"headerlink\" title=\"about\"></a>about</h1><p>汇编后的目标文件与与其他需要的目标文件链接以生成可执行文件。<br>在前面的学习中，在链接阶段看到示例程序与Foundation框架链接后的可执行文件中的符号表：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">(undefined) <span class=\"function\">external <span class=\"title\">_NSLog</span> <span class=\"params\">(from Foundation)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(undefined)</span> external _OBJC_CLASS_$<span class=\"title\">_NSObject</span> <span class=\"params\">(from CoreFoundation)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(undefined)</span> external _OBJC_METACLASS_$<span class=\"title\">_NSObject</span> <span class=\"params\">(from CoreFoundation)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(undefined)</span> external <span class=\"title\">___CFConstantStringClassReference</span> <span class=\"params\">(from CoreFoundation)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(undefined)</span> external <span class=\"title\">__objc_empty_cache</span> <span class=\"params\">(from libobjc)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(undefined)</span> external <span class=\"title\">_objc_autoreleasePoolPop</span> <span class=\"params\">(from libobjc)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(undefined)</span> external <span class=\"title\">_objc_autoreleasePoolPush</span> <span class=\"params\">(from libobjc)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(undefined)</span> external <span class=\"title\">_objc_msgSend</span> <span class=\"params\">(from libobjc)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(undefined)</span> external <span class=\"title\">dyld_stub_binder</span> <span class=\"params\">(from libSystem)</span></span></span><br></pre></td></tr></table></figure>\n<p>可以看到，经过链接后可执行文件中的符号表已经发生了变化：<br>所有 <code>(undefined)</code>的符号后都添加了来源信息。<br>1-4行：<code>Foundation</code>,<code>CoreFoundation</code>框架因<code>-framework Foundation</code>指令添加了链接信息。指示<code>_NSLog</code>,<code>_OBJC_CLASS_$_NSObject</code>等符号在<code>Foundation</code>,<code>CoreFoundation</code>框架中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">(undefined) <span class=\"function\">external <span class=\"title\">_NSLog</span> <span class=\"params\">(from Foundation)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(undefined)</span> external _OBJC_CLASS_$<span class=\"title\">_NSObject</span> <span class=\"params\">(from CoreFoundation)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(undefined)</span> external _OBJC_METACLASS_$<span class=\"title\">_NSObject</span> <span class=\"params\">(from CoreFoundation)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(undefined)</span> external <span class=\"title\">___CFConstantStringClassReference</span> <span class=\"params\">(from CoreFoundation)</span></span></span><br></pre></td></tr></table></figure>\n<p>5-8行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">(undefined) <span class=\"function\">external <span class=\"title\">__objc_empty_cache</span> <span class=\"params\">(from libobjc)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(undefined)</span> external <span class=\"title\">_objc_autoreleasePoolPop</span> <span class=\"params\">(from libobjc)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(undefined)</span> external <span class=\"title\">_objc_autoreleasePoolPush</span> <span class=\"params\">(from libobjc)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(undefined)</span> external <span class=\"title\">_objc_msgSend</span> <span class=\"params\">(from libobjc)</span></span></span><br></pre></td></tr></table></figure>\n\n<p><code>_objc_empty_cache</code>，<code>_objc_msgSend</code> 等符号都来源于<code>libobjc</code>。<br>这里的libobjc正是运行时支持库，这里的<code>__objc_empty_cache</code>,<code>_objc_msgSend</code>等都是runtime中的函数或者符号。</p>\n<p>当启动程序时，系统将可执行文件载入内存开始执行。但依上所见，程序中很多符号都源自其他系统库或第三方库，仅是在可执行文件中记录了符号的来源信息而已。<br>这意味着程序中还有很多“坑”需要填。</p>\n<h1 id=\"dyld\"><a href=\"#dyld\" class=\"headerlink\" title=\"dyld\"></a>dyld</h1><blockquote>\n<p>Most Mac apps need to load and use dynamic shared libraries or bundles at runtime. The dynamic loader, dyld, is a shared library that programs use to gain access to other shared libraries. The dynamic loader locates Mach-O files on disk and maps them into the memory space of the current program.</p>\n</blockquote>\n<p>dyld是一个用于动态链接其他动态库的库。为系统中程序所共享。<br>关于动态链接的介绍，优点可参考链接：<br><a href=\"http://ddeville.me/2014/04/dynamic-linking/\">Dynamic linking on iOS</a><br><a href=\"http://newosxbook.com/articles/DYLD.html\">DYLD Detailed</a><br><a href=\"https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html\">MikeAsh——dyld: Dynamic Linking On OS X</a>.<br><a href=\"http://blog.sunnyxx.com/2014/08/30/objc-pre-main/\">iOS程序main函数之前发生了什么</a></p>\n<p>dyld的工作很多也很复杂。而我的主要理解就是：dyld负责填“坑”。<br>如何填坑呢？</p>\n<ol>\n<li>定位需要的库文件</li>\n<li>将需要的库文件载入内存</li>\n<li>映射库文件位置到程序的地址空间，完成符号绑定。</li>\n</ol>\n<h1 id=\"load-runtime\"><a href=\"#load-runtime\" class=\"headerlink\" title=\"load runtime\"></a>load runtime</h1><p>下面，以动态载入runtime库（/usr/lib/libobjc.A.dylib）为线索，看看dyld是如何工作的。<br><a href=\"http://opensource.apple.com/source/dyld/dyld-360.18/\">dyld opensource</a></p>\n<h2 id=\"lauch\"><a href=\"#lauch\" class=\"headerlink\" title=\"lauch\"></a>lauch</h2><p>启动程序，系统调用<code>fork</code>为程序创建进程，调用<code>execve</code>将可执行文件载入内存，并执行。<br>在Mach-O可执行文件中，文件记录了可执行程序的一切信息。其中mach_header记录了程序的加载命令，其中一条就是动态链接器的位置：<code> /usr/lib/dyld</code>。在静态链接阶段，链接器在Mach-O文件中添加了链接信息，指明了：<code>_objc_msgSend</code>这些符号要从<code>libobjc</code>库中查找。<br>因此系统根据mach_header中的加载指令，启动dyld，将dyld载入内存，开始执行dyld库，让dyld去处理其他需要的库。</p>\n<h2 id=\"dyld-start\"><a href=\"#dyld-start\" class=\"headerlink\" title=\"__dyld_start\"></a>__dyld_start</h2><p>开始吧。<br><code>dyldStartup.s</code>，中用汇编实现了名为<code>__dyld_start</code>的方法（看不懂，利用注释来连猜带理解。)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># call dyldbootstrap::start(app_mh, argc, argv, slide, dyld_mh, &amp;startGlue)</span><br><span class=\"line\"># clean up stack and jump to &quot;start&quot; in main executable</span><br><span class=\"line\"># LC_MAIN case, set up stack for call to main() </span><br><span class=\"line\"># jump to main(argc,argv,env,apple) with return address set to _start</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>调用dyld的引导方法，<code>dyldbootstrap::start</code>引导dyld库。</li>\n<li>dyld引导和初始化完成后，清理栈，准备执行main。（main函数地址由<code>dyldbootstrap::start</code>返回）</li>\n<li>为main函数创建栈帧</li>\n<li>执行main</li>\n</ol>\n<!--*Notice：这里的main函数是dyld库的入口，dyld自己的main，不是我们程序的main*-->\n<h2 id=\"dyldbootstrap-start\"><a href=\"#dyldbootstrap-start\" class=\"headerlink\" title=\"dyldbootstrap::start\"></a>dyldbootstrap::start</h2><p>所以，其实<a href=\"http://opensource.apple.com/source/dyld/dyld-360.18/src/dyldInitialization.cpp\"><code>dyldbootstrap::start</code></a>中。<br>完成是对自己引导和初始化工作，不管怎么样，先从这里入手吧：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">uintptr_t</span> <span class=\"title\">start</span><span class=\"params\">(<span class=\"keyword\">const</span> struct macho_header* appsMachHeader, <span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* argv[], </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t<span class=\"keyword\">intptr_t</span> slide, <span class=\"keyword\">const</span> struct macho_header* dyldsMachHeader,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t<span class=\"keyword\">uintptr_t</span>* startGlue)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> DYLD_INITIALIZER_SUPPORT</span></span><br><span class=\"line\">  <span class=\"comment\">// run all C++ initializers inside dyld</span></span><br><span class=\"line\">  runDyldInitializers(dyldsMachHeader, slide, argc, argv, envp, apple);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// now that we are done bootstrapping dyld, call dyld&#x27;s main</span></span><br><span class=\"line\">  <span class=\"keyword\">uintptr_t</span> appsSlide = slideOfMainExecutable(appsMachHeader);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>以上源码只保留了我觉得能80%猜得到是干嘛的，其余不明白的也不打算深究。因为我比较笨。<br>总之<code>dyldbootstrap::start</code>干了：</p>\n<ol>\n<li>一堆准备工作</li>\n<li><code>runDyldInitializers</code>初始化自己</li>\n<li>执行<code>dyld::_main</code></li>\n<li><code>dyld::_main</code>完成后返回了程序main函数地址</li>\n</ol>\n<h2 id=\"dyld-main\"><a href=\"#dyld-main\" class=\"headerlink\" title=\"dyld::_main\"></a>dyld::_main</h2><p>那么我们已经可以确定dyld对动态库的处理都在<a href=\"http://opensource.apple.com/source/dyld/dyld-360.18/src/dyld.cpp\"><code>dyld::_main</code></a>中了，进去瞄一眼：<br>恩，头大。看不懂，按惯例删减一下,还是挑点关心的：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Entry point for dyld.  The kernel loads dyld and jumps to __dyld_start which</span></span><br><span class=\"line\"><span class=\"comment\">// sets up some registers and call this function.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Returns address of main() in target program which __dyld_start jumps to</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"keyword\">uintptr_t</span></span><br><span class=\"line\">_main(<span class=\"keyword\">const</span> macho_header* mainExecutableMH, <span class=\"keyword\">uintptr_t</span> mainExecutableSlide, </span><br><span class=\"line\">    <span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* argv[], <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* envp[], <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* apple[], </span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span>* startGlue)</span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">    <span class=\"comment\">//....</span></span><br><span class=\"line\">    <span class=\"comment\">//1.cache</span></span><br><span class=\"line\">    mapSharedCache();</span><br><span class=\"line\">    <span class=\"comment\">//2.load any inserted libraries</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>\t( sEnv.DYLD_INSERT_LIBRARIES != <span class=\"literal\">NULL</span> ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class=\"literal\">NULL</span>; ++lib) </span><br><span class=\"line\">            loadInsertedDylib(*lib);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//3.link main executable</span></span><br><span class=\"line\">    link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, <span class=\"literal\">true</span>, ImageLoader::RPathChain(<span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//4.link any inserted libraries</span></span><br><span class=\"line\">    <span class=\"comment\">// do this after linking main executable so that any dylibs pulled in by inserted </span></span><br><span class=\"line\">    <span class=\"comment\">// dylibs (e.g. libSystem) will not be in front of dylibs the program uses</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( sInsertedDylibCount &gt; <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class=\"line\">            ImageLoader* image = sAllImages[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">            link(image, sEnv.DYLD_BIND_AT_LAUNCH, <span class=\"literal\">true</span>, ImageLoader::RPathChain(<span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>));</span><br><span class=\"line\">            image-&gt;setNeverUnloadRecursive();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// only INSERTED libraries can interpose</span></span><br><span class=\"line\">        <span class=\"comment\">// register interposing info after all inserted libraries are bound so chaining works</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class=\"line\">            ImageLoader* image = sAllImages[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">            image-&gt;registerInterposing();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//5.run all initializers</span></span><br><span class=\"line\">    initializeMainExecutable(); </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//6.find entry point for main executable</span></span><br><span class=\"line\">    <span class=\"comment\">// main executable uses LC_UNIXTHREAD, dyld needs to let &quot;start&quot; in program set up for main()</span></span><br><span class=\"line\">    result = (<span class=\"keyword\">uintptr_t</span>)sMainExecutable-&gt;getMain();\t\t</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>_main</code>至少完成了以下工作：</p>\n<ol>\n<li><code>mapSharedCache();</code>,映射动态库cache</li>\n<li><code>loadInsertedDylib(*lib);</code>,从环境变量中取出所有添加的动态库信息，逐个load这些库</li>\n<li>链接可执行程序</li>\n<li>链接所有添加的库</li>\n<li>初始化所有链接之后的可执行程序。</li>\n<li>返回可执行程序的<code>main</code>函数准备执行</li>\n</ol>\n<p>之前说过dyld的工作就是填坑。这1,2,3,4就是定位坑，和填坑的过程。<br>以runtime库为例：</p>\n<ol>\n<li>dyld查看libobjc.A.dylib是否在cache中，是就绑定映射。</li>\n<li>没有，就根据环境变量获取libobjc.A.dylib的路径：<code>/usr/lib/libobjc.A.dylib</code>,将其定位然后载入内存。</li>\n<li>完成载入后，将载入的libobjc.A.dylib与可执行程序进行连接。（符号绑定）</li>\n<li>如果在载入runtime的libobjc.A.dylib的过程中因为依赖关系载入了其他动态库，也一起链接。</li>\n<li>对runtime库：<code>libobjc.A.dylib</code>中和程序中其他的可执行程序进行初始化。</li>\n<li>执行程序。</li>\n</ol>\n<p>自此，之前的坑：比如runtime库中的<code>_msgSend</code>等符号，就已经填好了。<br>不仅如此，runtime（libobjc.A.dylib）以及其他载入的库都已经完成了初始化，做好了执行的准备。<br>最后跳转至可执行程序的main开始执行。</p>\n<h1 id=\"附：有关于-void-load\"><a href=\"#附：有关于-void-load\" class=\"headerlink\" title=\"附：有关于+(void)load;\"></a>附：有关于<code>+(void)load;</code></h1><p>所以，这里才是runtime真正的载入过程。<em>事实上:NSObject的<code>+(void)load;</code>方法也正是在这个阶段进行的调用。</em><br>在这里，dyld才将runtime进行了载入和初始化，runtime在初始化之后，与被载入的Mach-O文件中的<code>__OBJC segment</code>字段中存储的类，分类，方法等符号进行了映射绑定，完成了对运行时所需要的数据结构的管理。<br>在这个过程中，所有class和category信息载入了runtime库，runtime库进而调用了它们的<code>+(void)load;</code>。</p>\n<p>既然都到这里了，就继续下去。<br>看看动态库的初始化过程。以runtime（libobjc.A.dylib）为线索，确认一下runtime初始化时对NSObject的<code>+(void)load</code>的调用。<br>在上文的第5步，dyld将调用<code>initializeMainExecutable();</code>对所有可执行库进行初始化： </p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">void initialize<span class=\"constructor\">MainExecutable()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// run initialzers for any inserted dylibs</span></span><br><span class=\"line\">  const size_t rootCount = sImageRoots.size<span class=\"literal\">()</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( rootCount &gt; <span class=\"number\">1</span> ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(size_t i=<span class=\"number\">1</span>; i &lt; rootCount; ++i) &#123;</span><br><span class=\"line\">      sImageRoots<span class=\"literal\">[<span class=\"identifier\">i</span>]</span>-&gt;run<span class=\"constructor\">Initializers(<span class=\"params\">gLinkContext</span>, <span class=\"params\">initializerTimes</span>[0])</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// run initializers for main executable and everything it brings up </span></span><br><span class=\"line\">  sMainExecutable-&gt;run<span class=\"constructor\">Initializers(<span class=\"params\">gLinkContext</span>, <span class=\"params\">initializerTimes</span>[0])</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>initializeMainExecutable</code>的主要工作：</p>\n<ol>\n<li>调用每一个添加的动态库的初始化工作。</li>\n<li>为main可执行文件调用初始化工作。</li>\n</ol>\n<p>为添加的动态库进行初始化工作是一个递归的过程，因为添加的库可能也存在所依赖的库，必须也添加并完成初始化。dyld使用<code>ImageLoader::recursiveInitialization</code>方法来进行这个工作。</p>\n<p>具体流程比较复杂，简单描述一下，以runtime（libobjc.A.dylib）为例：</p>\n<ol>\n<li><p>dyld通过<code>ImageLoader::recursiveInitialization</code>追述到runtime（libobjc.A.dylib）库，然后获取runtime库中Mach-O文件中载入指令（load_command）。</p>\n</li>\n<li><p>dyld执行这些load_command, 根据runtime的load_command开始了runtime的载入和初始化过程。</p>\n</li>\n<li><p>根据dyld的调用,runtime的<code>_objc_init</code>方法开始执行。程序暂时由dyld库进入runtime库，由runtime（libobjc.A.dylib）接管。</p>\n</li>\n<li><p>在runtime的<code>_objc_init</code>函数中，runtime向dyld进行了回调函数注册：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/***********************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">* _objc_init</span></span><br><span class=\"line\"><span class=\"comment\">* Bootstrap initialization. Registers our image notifier with dyld.</span></span><br><span class=\"line\"><span class=\"comment\">* Old ABI: called by dyld as a library initializer</span></span><br><span class=\"line\"><span class=\"comment\">* New ABI: called by libSystem BEFORE library initialization time</span></span><br><span class=\"line\"><span class=\"comment\">**********************************************************************/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> !__OBJC2__</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> __attribute__((constructor))</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"keyword\">void</span> _objc_init(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> initialized = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialized) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    initialized = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// fixme defer initialization until an objc-using image is found?</span></span><br><span class=\"line\">    environ_init();</span><br><span class=\"line\">    tls_init();</span><br><span class=\"line\">    lock_init();</span><br><span class=\"line\">    exception_init();</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">// Register for unmap first, in case some +load unmaps something</span></span><br><span class=\"line\">    _dyld_register_func_for_remove_image(&amp;unmap_image);</span><br><span class=\"line\">    dyld_register_image_state_change_handler(dyld_image_state_bound,</span><br><span class=\"line\">                                             <span class=\"number\">1</span><span class=\"comment\">/*batch*/</span>, &amp;map_images);</span><br><span class=\"line\">    dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, <span class=\"number\">0</span><span class=\"comment\">/*not batch*/</span>, &amp;load_images);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 其中最后一行：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, </span><br><span class=\"line\">                                         <span class=\"number\">0</span><span class=\"comment\">/*not batch*/</span>, </span><br><span class=\"line\">                                        &amp;load_images);</span><br></pre></td></tr></table></figure>\n<p> runtime注册了dyld完成初始化后的回调函数<code>&amp;load_images</code>。</p>\n</li>\n<li><p>在库镜像初始化完成后，程序又runtime回到dyld，再次由dyld库接管。dyld改变库状态为已完成初始化，进而调用之前runtime注册的完成初始化后的函数回调：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// let anyone know we finished initializing this image</span></span><br><span class=\"line\">      fState = dyld_image_state_initialized;</span><br><span class=\"line\">      oldState = fState;</span><br><span class=\"line\">      context.notifySingle(dyld_image_state_initialized, <span class=\"keyword\">this</span>);</span><br></pre></td></tr></table></figure></li>\n<li><p>程序由再次进入runtime，开始runtime的回调函数<code>load_images</code>;</p>\n</li>\n</ol>\n<p>关于<code>load_images</code>和NSObject<code>+(void)load</code>,<a href=\"/2015/06/02/iOS/Foundation/NSObject/NSObject_load_initialize/\">可参见笔记——NSObject:Load &amp; initialize.</a><br>以上就是关于NSObject<code>+(void)load</code>的全部。可以确定，load的调用远早于main。因为<code>load</code>发生在库的载入阶段，而不是程序的执行阶段。</p>\n<h1 id=\"end\"><a href=\"#end\" class=\"headerlink\" title=\"end\"></a>end</h1><p>dyld完成的工作很多，看得我头大，不打算深究了。<br>参考资料：<br><a href=\"http://ddeville.me/2014/04/dynamic-linking/\">Dynamic linking on iOS</a><br><a href=\"http://newosxbook.com/articles/DYLD.html\">DYLD Detailed</a><br><a href=\"https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html\">MikeAsh——dyld: Dynamic Linking On OS X</a>.<br><a href=\"http://blog.sunnyxx.com/2014/08/30/objc-pre-main/\">iOS程序main函数之前发生了什么</a></p>\n","categories":["iOS","Objective-C","Runtime"],"tags":["runtime","dyld"]},{"title":"分离[ 结构 ]与 [ UI ]","url":"/2015/09/24/iOS/UIKit/Interface%20Builder/iOS_UIKit_interfacebuilde_controller_and_view/","content":"<p>当在尝试做一个App的时候，遇到一个很简单的状况：<br>我在Storyboard中设计了App的流程，各UIViewController的你来我往。<br>然后开始填充设计各UIViewController场景的UI。<br>随着各场景UI配置的增长和复杂度的递增。每次打开Stroyboard一眼扫过去都觉得眼皮下充斥了太多东西。<br>不爽。<br>此时，我想分离流程和UI的设计。保持功能的单一性。<br>因为我觉得这有助于维护和保持思路的简洁。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"i-want：\"><a href=\"#i-want：\" class=\"headerlink\" title=\"i want：\"></a>i want：</h1><p>很简单：</p>\n<ol>\n<li>使用stroyboard设计App流程：仅各UIViewController的连接，剔除UI</li>\n<li>使用xib文件设计各场景的UI：仅各UIViewController对应的UIView，无关流程</li>\n<li>运行。command+r如同全部storyboard中设计一样直接运行，无需再多余添加诸如利用xib文件初始化等代码。</li>\n</ol>\n<h1 id=\"how？\"><a href=\"#how？\" class=\"headerlink\" title=\"how？\"></a>how？</h1><ol>\n<li>按原计划使用storyboard设计App流程，该做什么做什么。</li>\n<li>为各个UIViewController新增同名或略去“Controller”后缀的nib文件设计UI。<br>（如：MenuViewController.xib或MenuView.xib）</li>\n<li>删除storyboard中UIViewController默认添加的View。</li>\n<li>修改xib文件的Custom Class为需要连接的自定义类。</li>\n<li>将xib文件Files&#39;s owner中的Outlets：view连接xib文件自己的view。</li>\n<li>done</li>\n</ol>\n<p>其实很简单，就2步：</p>\n<ol>\n<li>删除原连接。<em>删除原storyboard中UIViewController的view</em></li>\n<li>建立新连接。<em>连接storyboard中UIViewController的view至xib的view</em></li>\n</ol>\n<h1 id=\"explain\"><a href=\"#explain\" class=\"headerlink\" title=\"explain\"></a>explain</h1><p>首先，需要知道的是：UIViewController可以看做是两步式构造。</p>\n<ol>\n<li>初始化自己</li>\n<li>当第一次访问view时，调用loadview初始化view</li>\n</ol>\n<hr>\n<p>接下来，看看这个姿势是如何工作的：</p>\n<ol>\n<li><p>当以上程序开始运行时，系统根据storyboard信息构造各个UIViewController，虽然我们已在stroryboard上删除了UIViewController的view，但因为上述的对view的懒加载特性其构造并不受影响。</p>\n</li>\n<li><p>当需要view时，UIViewController发现<code>view == nil</code>,因此调用<code>loadview</code>方法。</p>\n</li>\n<li><p><code>loadview</code>方法根据<code>nibname</code>属性查找相对应的nib文件。<em>在storyboard中UIViewController的view已经被删除了。因此，这里<code>nibname</code>为<code>nil</code></em>;</p>\n</li>\n<li><p>因为<code>nibname</code>为nil，UIViewController则按顺序搜索：</p>\n<ol>\n<li>略去&quot;Controller&quot;后缀且当前符合类名的nib文件，如(MenuViewController则搜索MenuView.xib)</li>\n<li>与类同名的nib文件,如MenuViewController.xib</li>\n</ol>\n</li>\n<li><p>此时单独的xib文件登场了。UIViewController搜索到匹配的xib，为其生成nib，开始构造view。</p>\n<p> 现在，UIViewController有，view也有了。但是，如果仅到这里的话，App会crash，因为Storyboard中UIViewController的view还没有与nib中的view绑定。我们还需要最后一步：</p>\n</li>\n<li><p>UIViewController通过nib中的连接信息建立连接。<br> 之前的操作：将xib文件Files&#39;s owner中的Outlets：view连接xib文件自己的view，就是让Storyboard中UIViewController的view与xib中的view建立连接。<br> 效果等同于在view初始化完成之后执行：<code>UIViewController.view = view;</code></p>\n</li>\n<li><p>done!</p>\n</li>\n</ol>\n<h1 id=\"end\"><a href=\"#end\" class=\"headerlink\" title=\"end\"></a>end</h1><p>姿势总结：<br>使用Stroyboard设计App结构与流程，使用单独的xib设计App各场景的UI。利用UIViewController<code>loadview</code>方法的特性完成其余工作。</p>\n","categories":["iOS","UIKit","Interface Builder"],"tags":["storyboard"]},{"title":"Runtime：self & super","url":"/2015/10/15/iOS/Objective-C/runtime/iOS_objc_runtime_self_super/","content":"<h1 id=\"self\"><a href=\"#self\" class=\"headerlink\" title=\"self\"></a>self</h1><p>首先，<code>self</code>是什么？<br><a href=\"http://opensource.apple.com/source/objc4/objc4-647/runtime/NSObject.mm\">runtime/NSObject.mm</a><br>在NSObject中发现有这2个方法：</p>\n<figure class=\"highlight gml\"><table><tr><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"symbol\">id</span>)<span class=\"literal\">self</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"symbol\">id</span>)<span class=\"literal\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"symbol\">id</span>)<span class=\"literal\">self</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>很有趣，我想知道<code>self</code>是什么,在NSObject中看到这2个方法，以为这就是来源。结果发现：他们干的事又都是简单的<code>return self;</code><br>事实上，也没人这么用过self方法：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> <span class=\"keyword\">self</span> = [<span class=\"built_in\">NSObject</span> <span class=\"keyword\">self</span>];</span><br></pre></td></tr></table></figure>\n<p>反正我没见过有人这样写self，尽管可以。<br>那么它们是干什么的？也许这是答案：<a href=\"http://stackoverflow.com/questions/13895789/what-is-the-purpose-of-the-self-method-in-nsobject-conformant-classes\">StackOverflow:What is the purpose of the self method in NSObject</a><br>总之，这2个方法别有用处，但不是<code>self</code>。</p>\n<hr>\n<p>其实，经过之前runtime的学习，甚至还自己写一个<code>self</code>来解释了一下：<a href=\"/2015/09/04/iOS/Objective-C/runtime/iOS_objc_runtime_explanation/#Still_Why?\">笔记——Runtime：Why runtime?</a><br>已经知道，<code>self</code>是编译器在方法改写时增加的隐藏参数，类型为<code>id</code>,也就是“对象”。</p>\n<p>其理解为：消息的接收者。<br>我们可以通过这个接收者，来访问对象中的具体属性和行为。<br>当向对象发送消息时，这个消息的接收者是对象。<br>当向类发送消息时，这个消息的接收者是类。<br>别矛盾，还记得吗？对象是对象，类是对象，metaclass也是对象。所以，都是<code>id self</code>.<br><a href=\"/2015/09/25/iOS/Objective-C/runtime/iOS_objc_runtime_class_metaclass/#metaclass\">在之前的笔记中，有关于self分别代表对象和类的实例。</a><br>总之：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">id objc<span class=\"constructor\">_msgSend(<span class=\"params\">id</span> <span class=\"params\">self</span>,SEL <span class=\"params\">_cmd</span>,<span class=\"operator\">...</span>)</span>;</span><br></pre></td></tr></table></figure>\n<p>在方法改写时，每一个方法都会添加<code>id self</code>。那么，为什么呢？<br>举个栗子。<br>现有一个Test类：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">interface</span> <span class=\"symbol\">Test</span>:<span class=\"symbol\">NSObject</span>&#123;</span><br><span class=\"line\">  NSInteger count;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"built_in\">void</span>)setCount;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">void</span>)setCount&#123;</span><br><span class=\"line\">  count = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实例化一个对象：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\">id <span class=\"keyword\">test</span> = [[<span class=\"keyword\">Test</span> alloc]init];</span><br></pre></td></tr></table></figure>\n<p>Test类有一个实例变量，一个方法。test是其实例对象。<br>经过前面关于class&amp;object以及class&amp;metaclass的学习，我清楚的知道Test类和其对象分别掌握着什么信息：<br>Test类：</p>\n<ul>\n<li>实例变量大小</li>\n<li>实例变量类型</li>\n<li>实例变量的内存偏移位置</li>\n<li>方法的实现</li>\n<li>方法的方法名</li>\n</ul>\n<p>test对象：</p>\n<ul>\n<li>一段包括isa指针和实例变量大小的内存区域</li>\n<li>我的内存位置</li>\n<li>Test类信息的位置</li>\n</ul>\n<p>当给对象发送消息时：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">[test setCount];</span><br></pre></td></tr></table></figure>\n<p>test对象通过Test类找到方法setCount的具体实现，但方法的实现中：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">count</span> = <span class=\"number\">0</span><span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>这个count对于类而已只是一个泛型的描述：“将名称为count的变量设置为0”。<br>但事实上 ，真正的实现是针对具体每个对象的实例变量的操作。<br>要操作对象的这个实例变量，我们需要知道这个实例变量在哪里。<br>而类虽然有这个方法的实现和实例变量的大小，类型，偏移等信息，<br>但却是不可能知道自己的每个对象的实例变量存在哪的。<br>因此，事情上：以上代码会被编译器改写：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setCount&#123;</span><br><span class=\"line\">  <span class=\"built_in\">self</span>-&gt;count = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为只有对象掌握着自己的位置信息。<br>因此，每个方法的具体实现中，都需要一个<code>id self</code>，这个<code>self</code>对于访问实例变量来说是必需的。<br>这就是为什么，编译器会为每个方法加入隐藏参数：<code>id self</code>;</p>\n<h1 id=\"super\"><a href=\"#super\" class=\"headerlink\" title=\"super\"></a>super</h1><p>学习了runtime之后突然发现之前对<code>self</code>和<code>super</code>在理解上一直有个误区<br>这里就来解开这个误区。<br>关于Objective-C，接触到的第一个概念就是消息。<br>反正我在学习的时候，看到的书或者blog上都是这么介绍消息表达式的：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">[receiver message]</span><br></pre></td></tr></table></figure>\n<p>意思是向receiver发送消息message.</p>\n<p>在之后又看到：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">-(id) init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    self = [super init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (self != nil)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以关于<code>[super init]</code>，脑子中就转换为了：向super发送消息init。<br>然而现在才发现，这是错误的。事实上在这里super并不是消息的接收者。</p>\n<p>之前的笔记中提过，编译器会将方法改写为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">id <span class=\"title\">objc_msgSend</span><span class=\"params\">(id self,SEL _cmd,...)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>而当有super关键字时，方法改写是这样：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">id <span class=\"title\">objc_msgSendSuper</span><span class=\"params\">(struct objc_super *super, SEL op, ...)</span></span></span><br></pre></td></tr></table></figure>\n<p>其中struct objc_super：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_super</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/// Specifies an instance of a class.</span></span><br><span class=\"line\">    __unsafe_unretained id receiver;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Specifies the particular superclass of the instance to message. </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span></span><br><span class=\"line\">    <span class=\"comment\">/* For compatibility with old objc-runtime.h header */</span></span><br><span class=\"line\">    __unsafe_unretained Class <span class=\"class\"><span class=\"keyword\">class</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">    __unsafe_unretained Class super_class;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"comment\">/* super_class is the first class to search */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>包含的数据有：</p>\n<ul>\n<li>消息接收者 （依然是<code>self</code>）</li>\n<li>当前类</li>\n<li>当前类的父类</li>\n</ul>\n<p>结构体中，消息的接收者依然是<code>self</code>，不过在<code>self</code>之外，还记录了父类的信息。<br>而关于super是如何工作的，最后的注释似乎已经说得很明白了：</p>\n<blockquote>\n<p>/* super_class is the first class to search */</p>\n</blockquote>\n<p>所以，关于super关键字的误区：”向super发送消息“的正确理解应该是：<br><em>向self发送xxx消息，但是方法搜索跳过本类的方法列表，直接从superclass开始。</em></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"http://www.cocoawithlove.com/2009/04/what-does-it-mean-when-you-assign-super.html\">What does it mean when you assign [super init] to self?</a><br><a href=\"http://stackoverflow.com/questions/2956943/why-should-i-call-self-super-init\">StackOverflow:Why should I call self=[super init]</a></p>\n","categories":["iOS","Objective-C","Runtime"],"tags":["runtime","self","super"]},{"title":"Storyboard Reference","url":"/2015/09/24/iOS/UIKit/Interface%20Builder/iOS_UIKit_interfacebuilde_storyboard_reference/","content":"<p>当程序结构越来越复杂的时候。可以使用Stroyboard Reference来分离架构。</p>\n<p>感觉没什么可说的 。用就行了。</p>\n<p>转载一些教程博客之类的方便以后忘记了去翻阅吧。</p>\n<p><i class=\"fa fa-apple\"></i>  <a href=\"https://developer.apple.com/videos/play/wwdc2015/215/\">wwdc 2015 storyboard</a><br><i class=\"fa fa-apple\"></i>  <a href=\"https://developer.apple.com/library/ios/recipes/xcode_help-IB_storyboard/Chapters/RefactorStoryboard.html#//apple_ref/doc/uid/TP40014225-CH48-SW1\">iOS Developer Library:Storyboard Help</a><br><i class=\"fa fa-at\"></i> <a href=\"https://www.shinobicontrols.com/blog/ios9-day-by-day-day3-storyboard-references\">iOS9 Day-by-Day :: Day 3 :: Storyboard References</a></p>\n","categories":["iOS","UIKit","Interface Builder"],"tags":["storyboard"]},{"title":"unwind segue","url":"/2015/09/24/iOS/UIKit/Interface%20Builder/iOS_UIKit_interfacebuilde_unwind/","content":"<h1 id=\"操作步骤\"><a href=\"#操作步骤\" class=\"headerlink\" title=\"操作步骤\"></a>操作步骤</h1><p>先明确一下表达：<br>目标位置：希望返回到的目标ViewController。<br>当前位置：unwind segue触发点所在的当前ViewController。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"trigger-by-storyboard\"><a href=\"#trigger-by-storyboard\" class=\"headerlink\" title=\"trigger by storyboard\"></a>trigger by storyboard</h2><p>步骤：</p>\n<ol>\n<li>在目标位置实现IBAction： <figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)unwindToMainMenu:(<span class=\"built_in\">UIStoryboardSegue</span>*)sender&#123;</span><br><span class=\"line\">   <span class=\"built_in\">UIViewController</span> *sourceViewController = sender.sourceViewController;</span><br><span class=\"line\">    <span class=\"comment\">// Pull any data from the view controller which initiated the unwind segue.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n 这个方法会在unwind segue执行之前调用。<br> 目标位置可以在这里获取当前位置（sender.sourceViewController）中的数据，神马的。</li>\n<li>让当前位置链接目标位置的IBAction：<br> 在当前位置的某触发控件与上一步的unwind acton之间建立链接。control键拖动控件至Exit图标，在弹出来的在目标位置实现IBAction之中，选择目标位置的IBAction。<img src=\"http://ww3.sinaimg.cn/mw690/bfecc6a2gw1f2dmbgbqryj209r01vmx0.jpg\"></li>\n</ol>\n<h2 id=\"trigger-by-code\"><a href=\"#trigger-by-code\" class=\"headerlink\" title=\"trigger by code\"></a>trigger by code</h2><p>上述方法是在Storyboard中通过建立控件与unwind action的连接来完成的。<br>有时，也需要在程序中使用代码主动地来调用unwind segue。<br>方法：</p>\n<ol>\n<li><p>同上：<br> 在目标位置实现IBAction：</p>\n <figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)unwindToMainMenu:(<span class=\"built_in\">UIStoryboardSegue</span>*)sender&#123;</span><br><span class=\"line\">   <span class=\"built_in\">UIViewController</span> *sourceViewController = sender.sourceViewController;</span><br><span class=\"line\">    <span class=\"comment\">// Pull any data from the view controller which initiated the unwind segue.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>在目标位置生成unwind segue：<br> control键拖动Files&#39;s owner至Exit图标，在弹出来的IBAction之中，选择目标位置的IBAction。<br> <img src=\"http://ww2.sinaimg.cn/mw690/bfecc6a2gw1f2dpdgmaelj209r01vt8m.jpg\"></p>\n</li>\n<li><p>为上一步生成的unwind segue设置identifier：<br> <img src=\"http://ww2.sinaimg.cn/mw690/bfecc6a2gw1f2dpdgapu9j208805k3yw.jpg\"></p>\n</li>\n<li><p>当需要unwind时，调用：</p>\n <figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span> performSegueWithIdentifier:<span class=\"string\">@&quot;identifier&quot;</span> sender:<span class=\"keyword\">self</span>];</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"unwind-segue具体工作流程\"><a href=\"#unwind-segue具体工作流程\" class=\"headerlink\" title=\"unwind segue具体工作流程\"></a>unwind segue具体工作流程</h1><p>当unwind segue触发后：</p>\n<ol>\n<li>unwind segue首先定位目标位置</li>\n<li>定位成功后，生成一个segue实例，向当前位置发送<code> prepareForSegue:sender:</code>。<br> （当前位置可准备数据）</li>\n<li>调用目标位置的unwind action。<br> （目标位置可接收数据）</li>\n<li>perform。执行unwind segue。</li>\n</ol>\n<h1 id=\"explain\"><a href=\"#explain\" class=\"headerlink\" title=\"explain\"></a>explain</h1><p>unwind segue的工作分为三步：</p>\n<ol>\n<li>标记目标位置</li>\n<li>定位目标位置</li>\n<li>回到目标位置</li>\n</ol>\n<h2 id=\"标记目标位置\"><a href=\"#标记目标位置\" class=\"headerlink\" title=\"标记目标位置\"></a>标记目标位置</h2><p>还记得吗？为了实现unwind，第一步工作就是在目标位置实现unwind acion方法。<br>unwind segue的工作逻辑：<br>想回到某地方。首先需要明确要回到哪里——即目标位置。<br>unwind segue通过在目标位置实现一个以（UIStroyBoardSegue*）为参数的IBAction来明确目标位置。这个IBAction可以把它理解为一个地名，尽管它还可以提供其他一些信息，还是把它想象成一个地名比较直观。<br>链接IBAction的过程就相当于告诉当前位置，我们要去的地名是什么。<br>然后UIKit根据IBAction这个地名，开始查找目标位置。</p>\n<p>因为目的位置才有这个unwind acion，UIKit根据它来进行定位。</p>\n<h2 id=\"定位目标位置\"><a href=\"#定位目标位置\" class=\"headerlink\" title=\"定位目标位置\"></a>定位目标位置</h2><p>当unwind segue被触发后，当前位置UIViewController以自己为起点，以响应链（Responder chain）为线索发起对unwind action的定位：</p>\n<ol>\n<li>以自己为起点开始追溯响应链上游。以找到目标位置为终结。如果到响应链尽头都未成功，就放弃这个unwind。<br> 如果UIViewController是模态呈现的，上游就是其<code>presentingViewController</code>,否则就是其<code>parentViewController</code>.</li>\n<li>对每一个UIViewController的决策，都根据先<code>childViewControllers</code>再自己的顺序进行。<br> 先遍历自己的<code>childViewControllers</code>，在判断自己。</li>\n<li> 系统通过向每个待决策的UIViewController发送：<br> <a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/#//apple_ref/occ/instm/UIViewController/canPerformUnwindSegueAction:fromViewController:withSender:\"><code>canPerformUnwindSegueAction:fromViewController:withSender:</code></a>消息的方式来决策其是否响应unwind action。如果返回<code>YES</code>则定位成功，<code>NO</code>则继续追溯。<br> （告诉我，你的地名是不是叫“XXX”）。</li>\n</ol>\n<h3 id=\"关于Container-ViewController定位过程中的决策\"><a href=\"#关于Container-ViewController定位过程中的决策\" class=\"headerlink\" title=\"关于Container ViewController定位过程中的决策\"></a>关于Container ViewController定位过程中的决策</h3><p>在上面，定位目标位置的步骤2中，提到UIViewController如果有<code>childViewControllers</code>的话，将先遍历<code>childViewControllers</code>，然后才是自己。<br>鉴于UIViewController在一定程度上是掌握其子控制器的信息的。在对<code>childViewControllers</code>中的子控制器进行定位时，可以利用父控制器掌握的子控制器信息，而不必要进行逐一的匹配。<br>UIKit对每一个容器型控制器调用：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">UIViewController</span> *&gt; *)allowedChildViewControllersForUnwindingFromSource:(<span class=\"built_in\">UIStoryboardUnwindSegueSource</span> *)source</span><br></pre></td></tr></table></figure>\n<p>该方法返回可以进行IBAction（地名）匹配的子控制器数组。UIKit在对这个数组中的控制器进行逐一搜索。</p>\n<p>因此，如果控制器是容器类型的话，可以对<code>allowedChildViewControllersForUnwindingFromSource:</code>方法进行重写，以更改搜索的顺序，或者根据掌握的信息来加快搜索。</p>\n<p>在<code>allowedChildViewControllersForUnwindingFromSource</code>方法中，UIViewController调用：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIViewController</span> *)childViewControllerContainingSegueSource:(<span class=\"built_in\">UIStoryboardUnwindSegueSource</span> *)source</span><br></pre></td></tr></table></figure>\n<p>进行进一步筛检。</p>\n<p>我们要搜索的是目标位置。unwind发起的当前位置显然不是我们要找的。UIViewController通过这个方法排除触发位置。进一步删减等待决策的子控制器。</p>\n<p>以上是Container ViewController在决策过程中的两个辅助方法。</p>\n<h2 id=\"回到目标位置\"><a href=\"#回到目标位置\" class=\"headerlink\" title=\"回到目标位置\"></a>回到目标位置</h2><p>当定位成功后。接下来要做的就是回去。</p>\n<p>UIKit按照之前的查找路径一步一步地返回。让每一个返回路径上的UIViewController参与返回的这个过程。Runtime为每一步返回生成UIStoryboardSegue对象并执行。并对每一个路径上的UIViewController调用方法：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)unwindForSegue:(<span class=\"built_in\">UIStoryboardSegue</span> *)unwindSegue</span><br><span class=\"line\"> towardsViewController:(<span class=\"built_in\">UIViewController</span> *)subsequentVC;</span><br></pre></td></tr></table></figure>\n\n<p>方法中，<code>towardsViewController</code>是unwind路径上即将进入的下一个UIViewController。<br>我们可以在这个方法中对返回路径上的每一个UIViewController进行一些设置。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><i class=\"fa fa-apple\"></i> <a href=\"https://developer.apple.com/library/ios/technotes/tn2298/_index.html\">Using Unwind Segues</a></p>\n","categories":["iOS","UIKit","Interface Builder"],"tags":["storyboard"]},{"title":"居中","url":"/2018/10/26/Front/CSS/cheatsheet/center/center_in_css/","content":"<h1 id=\"inline元素\"><a href=\"#inline元素\" class=\"headerlink\" title=\"inline元素\"></a>inline元素</h1><h2 id=\"horizontal\"><a href=\"#horizontal\" class=\"headerlink\" title=\"horizontal\"></a>horizontal</h2><p>设置文字属性<code>text-align</code></p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.center</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"vertical\"><a href=\"#vertical\" class=\"headerlink\" title=\"vertical\"></a>vertical</h2><h3 id=\"单行\"><a href=\"#单行\" class=\"headerlink\" title=\"单行\"></a>单行</h3><p>文字只会占据单行，则设置行高与元素高度等高</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.center</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">line-height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"多行\"><a href=\"#多行\" class=\"headerlink\" title=\"多行\"></a>多行</h3><h4 id=\"支持Flexbox\"><a href=\"#支持Flexbox\" class=\"headerlink\" title=\"支持Flexbox\"></a>支持Flexbox</h4><p>使用<code>align-item</code>指定元素的cross axis对齐方式：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">align-items</span>: center; </span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者使用<code>justify-content</code>指定元素的main axis对齐方式：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">flex-direction</span>: column;</span><br><span class=\"line\">  <span class=\"attribute\">justify-content</span>: center;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"不支持Flexbox\"><a href=\"#不支持Flexbox\" class=\"headerlink\" title=\"不支持Flexbox\"></a>不支持Flexbox</h4><p>使用<code>vertical-align</code>属性实现居中。<br>vertical-align 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。<br>由此，分别有：</p>\n<h5 id=\"inline-vertical-align\"><a href=\"#inline-vertical-align\" class=\"headerlink\" title=\"inline vertical-align\"></a>inline vertical-align</h5><p><code>vertical-align</code>指定行内元素的inline box在line box中的垂直位置<br>首先要弄清楚几个概念：<br>the containing block<br><a href=\"https://www.w3.org/TR/CSS2/visuren.html#inline-boxes\">inline box</a><br><a href=\"https://www.w3.org/TR/CSS2/visuren.html#inline-formatting\">line box</a><br>现在，我们想要元素垂直居中，需要的是：</p>\n<ol>\n<li>该元素是行内元素inline</li>\n<li>包含该元素的line box高度与containning block相同，</li>\n</ol>\n<p>第1项很简单：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.center</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第2项可以通过增加一个伪元素解决。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">::after</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，containning block中有了一个等高的inline伪元素，这使得其生成的line box与containing block高度相同，现在可以使用<code>vertical-align</code>指定行内元素在line box中的垂直位置：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">::after</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">vertical-align</span>: middle;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.center</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">    <span class=\"attribute\">vertical-align</span>: middle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"table-cell-vertical-align\"><a href=\"#table-cell-vertical-align\" class=\"headerlink\" title=\"table-cell vertical-align\"></a>table-cell vertical-align</h5><p><code>vertical-align</code>也可以指定table cell的垂直位置。<br>因此，为元素和包含元素构建一个table</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: table;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.center</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: table-cell;</span><br><span class=\"line\">    <span class=\"attribute\">vertical-align</span>: middle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者直接：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: table-cell;</span><br><span class=\"line\">    <span class=\"attribute\">vertical-align</span>: middle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"block元素\"><a href=\"#block元素\" class=\"headerlink\" title=\"block元素\"></a>block元素</h1><h2 id=\"horizontal-1\"><a href=\"#horizontal-1\" class=\"headerlink\" title=\"horizontal\"></a>horizontal</h2><h3 id=\"单个block\"><a href=\"#单个block\" class=\"headerlink\" title=\"单个block\"></a>单个block</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.center</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多个block\"><a href=\"#多个block\" class=\"headerlink\" title=\"多个block\"></a>多个block</h3><h4 id=\"支持Flexbox-1\"><a href=\"#支持Flexbox-1\" class=\"headerlink\" title=\"支持Flexbox\"></a>支持Flexbox</h4><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.center</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">justify-content</span>: center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"不支持Flexbox-1\"><a href=\"#不支持Flexbox-1\" class=\"headerlink\" title=\"不支持Flexbox\"></a>不支持Flexbox</h4><p>多个block横向居中，则必须转为inline-block，然后使用<code>text-align</code>:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.center</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"vertical-1\"><a href=\"#vertical-1\" class=\"headerlink\" title=\"vertical\"></a>vertical</h2><h3 id=\"使用绝对定位\"><a href=\"#使用绝对定位\" class=\"headerlink\" title=\"使用绝对定位\"></a>使用绝对定位</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.center</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateY</span>(-<span class=\"number\">50%</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或用于已知高度：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.center</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>: -<span class=\"number\">50px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结合绝对定位,已知宽度，高度与marin：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>:relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.center</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">0</span>; <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0</span>; <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: auto;   <span class=\"comment\">/* 水平，垂直居中 */</span></span><br><span class=\"line\">  <span class=\"comment\">/* margin: auto 0; 垂直居中 */</span></span><br><span class=\"line\">  <span class=\"comment\">/* margin: 0 auto; 水平居中 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用table-cell与vertical-align\"><a href=\"#使用table-cell与vertical-align\" class=\"headerlink\" title=\"使用table-cell与vertical-align\"></a>使用table-cell与vertical-align</h3><p>缺点：table-cell会拉升自身height至table的height</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.center</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table-cell;</span><br><span class=\"line\">  <span class=\"attribute\">vertical-align</span>: middle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用Flexbox\"><a href=\"#使用Flexbox\" class=\"headerlink\" title=\"使用Flexbox\"></a>使用Flexbox</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">align-items</span>: center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者结合子元素的margin:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.center</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: auto <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用Grid\"><a href=\"#使用Grid\" class=\"headerlink\" title=\"使用Grid\"></a>使用Grid</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: grid;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.center</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["Front","CSS","Cheatsheet","Center"],"tags":["Center in CSS"]},{"title":"画三角","url":"/2017/03/26/Front/CSS/cheatsheet/center/triangle/","content":"<p>0宽，0高的box，设置border时，border会相交形成三角。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.arrow-up</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">20px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-right</span>: <span class=\"number\">20px</span> solid transparent;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">20px</span> solid black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.arrow-down</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">20px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-right</span>: <span class=\"number\">20px</span> solid transparent;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"attribute\">border-top</span>: <span class=\"number\">20px</span> solid <span class=\"number\">#f00</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.arrow-right</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">  <span class=\"attribute\">border-top</span>: <span class=\"number\">20px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">20px</span> solid transparent;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">20px</span> solid green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.arrow-left</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">  <span class=\"attribute\">border-top</span>: <span class=\"number\">20px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">20px</span> solid transparent; </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"attribute\">border-right</span>: <span class=\"number\">20px</span> solid blue; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://pineco.de/quick-tip-css-triangles/\">Quick Tip: CSS Triangles</a></p>\n","categories":["Front","CSS","Cheatsheet","Triangle"],"tags":["Triangle in CSS"]},{"title":"Objective-C:Autorelease","url":"/2015/04/14/iOS/Objective-C/essentials/Basic/Objc_essentials_autorelease/","content":"<h1 id=\"autoreleasepool\"><a href=\"#autoreleasepool\" class=\"headerlink\" title=\"@autoreleasepool\"></a>@autoreleasepool</h1><ol>\n<li><p>自动释放池是一个对象，作用是管理其他待内存释放的对象。<br> 用@autoreleasepool编译器指令取代NSAutoReleasePool只是表象，目的是更好理解。<br> 但本质不变。</p>\n</li>\n<li><p>对需要释放的对象发送消息：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">[object autorelease];</span><br></pre></td></tr></table></figure>\n<p> 等同于向自动释放池发送消息：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">[pool addObject:object];</span><br></pre></td></tr></table></figure>\n<p> 作用都是将对象添加进释放池，被其管理。</p>\n</li>\n<li><p>autorelease对象既然也是对象，其也需要被释放。不过autorelease对象有一个<code>drain</code>方法，<code>drain</code>方法的作用是在释放自己之前，先向被管理的所有对象发送<code>release</code>消息。<br>这就达到了释放所有被管理对象的目的。</p>\n</li>\n</ol>\n<p>以上消息都是在MRC模式下，在ARC下，所有内存管理消息都由编译器添加，我们需要做的就是：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@autoreleasepool</span>&#123;\t<span class=\"comment\">// 1.编译器创建NSAutoReleasePool，并压入线程的自动释放池栈</span></span><br><span class=\"line\">      <span class=\"comment\">// 2.在块内的所有临时对象，编译器都添加autorelease消息，加入池</span></span><br><span class=\"line\">&#125;\t\t\t<span class=\"comment\">// 3.块结束，编译器drain池，并将该池弹出线程的自动释放池栈</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"autoreleasepool与线程\"><a href=\"#autoreleasepool与线程\" class=\"headerlink\" title=\"@autoreleasepool与线程\"></a>@autoreleasepool与线程</h1><blockquote>\n<p>Each thread in a Cocoa application maintains its own stack of autorelease pool blocks. If you are writing a Foundation-only program or if you detach a thread, you need to create your own autorelease pool block.</p>\n</blockquote>\n<p>应用内的每个线程都维护了一个自己的自动释放池栈。<br>例如：应用主线程的自动释放池栈中的第一个释放池便是：</p>\n<figure class=\"highlight objectivec\"><figcaption><span>Main函数</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> * argv[]) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">UIApplicationMain</span>(argc, argv, <span class=\"literal\">nil</span>, <span class=\"built_in\">NSStringFromClass</span>([AppDelegate <span class=\"keyword\">class</span>]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>基于栈结构，autoreleasepool可以嵌套：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@autoreleasepool</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// . . .</span></span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// . . .</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    . . .</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上语句将在线程的释放池栈中压入2个新的自动释放池对象。</p>\n<p>当创建新线程，而又需要在新线程上调用Cocoa对象时，就需要在新线程上创建autoreleasepool。</p>\n<h1 id=\"autoreleasepool与Runloop\"><a href=\"#autoreleasepool与Runloop\" class=\"headerlink\" title=\"@autoreleasepool与Runloop\"></a>@autoreleasepool与Runloop</h1><p>NSRunloop的每一个运行周期的开始都会创建一个Autoreleasepool对象，在运行周期结束时其将被销毁。周而复始。<br>如此完成对runloop每一个周期期间产生的临时对象的内存管理。</p>\n<blockquote><p>App启动后，苹果在主线程RunLoop里注册了两个Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>\n<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>\n<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>\n<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p><footer><strong>ibireme</strong><cite><a href=\"http://blog.ibireme.com/2015/05/18/runloop/\">深入理解NSRunloop</a></cite></footer></blockquote>\n\n<h1 id=\"use-autoreleasepool\"><a href=\"#use-autoreleasepool\" class=\"headerlink\" title=\"use @autoreleasepool\"></a>use @autoreleasepool</h1><p>当@autoreleasepool{}块结束时，池中的临时对象就会被释放，基于此，可以更好的利用@autoreleasepool来进行内存管理。<br>现在知道，每个runloop运行周期都会自动的创建和释放一个autoreleasepool，但是，当runloop运行周期内一定时间内产生大量临时对象时，依然会消耗大量内存，而这些内存必须运行到runloop结束时才会释放。这在一定情况下依然会产生内存瓶颈。</p>\n<p>而如果将这些临时内存包裹在一个@autoreleasepool{}块中，我们就不用等到runloop周期结束，而可以在使用完毕之后利用autoreleasepool马上释放：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)useALoadOfNumbers &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10000</span>; ++j) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">@autoreleasepool</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; ++i) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">NSNumber</span> *number = [<span class=\"built_in\">NSNumber</span> numberWithInt:(i+j)];</span><br><span class=\"line\">                <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;number = %p&quot;</span>, number);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","categories":["iOS","Objective-C","Essentials","Basic"]},{"title":"Objective-C:blocks","url":"/2015/06/03/iOS/Objective-C/essentials/Basic/Objc_essentials_blocks/","content":"<p>@<a href=\"http://clang.llvm.org/docs/Block-ABI-Apple.html\">Block Implementation Specification</a><br>@<a href=\"https://www.cocoawithlove.com/2009/10/how-blocks-are-implemented-and.html\">How blocks are implemented (and the consequences)</a><br>@<a href=\"https://www.mikeash.com/pyblog/friday-qa-2008-12-26.html\">Friday Q&amp;A 2008-12-26</a></p>\n","categories":["iOS","Objective-C","Essentials","Basic"],"tags":["NSObject"]},{"title":"Objective-C:basic types","url":"/2015/04/11/iOS/Objective-C/essentials/Basic/Objc_essentials_basic_type/","content":"<p><a href=\"https://opensource.apple.com/source/objc4/objc4-647/runtime/objc.h.auto.html\">runtime/objc.h</a></p>\n<h1 id=\"BOOL\"><a href=\"#BOOL\" class=\"headerlink\" title=\"BOOL\"></a>BOOL</h1><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Type to represent a boolean value.</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> !defined(OBJC_HIDE_64) &amp;&amp; TARGET_OS_IPHONE &amp;&amp; __LP64__</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">bool</span> BOOL;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">signed</span> <span class=\"keyword\">char</span> BOOL; </span><br><span class=\"line\"><span class=\"comment\">// BOOL is explicitly signed so @encode(BOOL) == &quot;c&quot; rather than &quot;C&quot; </span></span><br><span class=\"line\"><span class=\"comment\">// even if -funsigned-char is used.</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"YES-amp-NO\"><a href=\"#YES-amp-NO\" class=\"headerlink\" title=\"YES &amp; NO\"></a>YES &amp; NO</h1><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> __has_feature(objc_bool)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> YES __objc_yes</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NO  __objc_no</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> YES ((BOOL)1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NO  ((BOOL)0)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Nil-amp-nil\"><a href=\"#Nil-amp-nil\" class=\"headerlink\" title=\"Nil &amp; nil\"></a>Nil &amp; nil</h1><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> Nil</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">if</span> __has_feature(cxx_nullptr)</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> Nil nullptr</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> Nil __DARWIN_NULL</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> nil</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">if</span> __has_feature(cxx_nullptr)</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> nil nullptr</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> nil __DARWIN_NULL</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"NSInteger\"><a href=\"#NSInteger\" class=\"headerlink\" title=\"NSInteger\"></a>NSInteger</h1><p><a href=\"https://opensource.apple.com/source/objc4/objc4-647/runtime/NSObjCRuntime.h.auto.html\">runtime/NSObjCRuntime.h</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> __LP64__ || (TARGET_OS_EMBEDDED &amp;&amp; !TARGET_OS_IPHONE) || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> NSInteger;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> NSUInteger;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> NSInteger;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> NSUInteger;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","categories":["iOS","Objective-C","Essentials","Basic"]},{"title":"Objective-C:Runloop","url":"/2015/06/14/iOS/Objective-C/essentials/Basic/Objc_essentials_runloop/","content":"<p><a href=\"http://blog.ibireme.com/2015/05/18/runloop/\">深入理解Runloop</a><br><a href=\"https://mikeash.com/pyblog/friday-qa-2010-01-01-nsrunloop-internals.html\">Friday Q&amp;A 2010-01-01: NSRunLoop Internals</a></p>\n","categories":["iOS","Objective-C","Essentials","Basic"]},{"title":"Objective-C:basic struct","url":"/2015/04/11/iOS/Objective-C/essentials/Basic/Objc_essentials_runtime_struct/","content":"<p><a href=\"https://opensource.apple.com/source/objc4/objc4-647/runtime/objc.h.auto.html\">runtime/objc.h</a></p>\n<h1 id=\"类和对象\"><a href=\"#类和对象\" class=\"headerlink\" title=\"类和对象\"></a>类和对象</h1><h2 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h2><figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_class &#123;</span><br><span class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> !__OBJC2__</span></span><br><span class=\"line\">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name                                         OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125; OBJC2_UNAVAILABLE;</span><br><span class=\"line\"><span class=\"comment\">/* Use `Class` instead of `struct objc_class *` */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"object\"><a href=\"#object\" class=\"headerlink\" title=\"object\"></a>object</h2><figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> !OBJC_TYPES_DEFINED</span></span><br><span class=\"line\"><span class=\"comment\">/// An opaque type that represents an Objective-C class.</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_class *Class;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Represents an instance of a class.</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> objc_object &#123;</span><br><span class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"id\"><a href=\"#id\" class=\"headerlink\" title=\"id\"></a>id</h2><figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// A pointer to an instance of a class.</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_object *<span class=\"keyword\">id</span>;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"实例变量与属性\"><a href=\"#实例变量与属性\" class=\"headerlink\" title=\"实例变量与属性\"></a>实例变量与属性</h1><h2 id=\"iVar\"><a href=\"#iVar\" class=\"headerlink\" title=\"iVar\"></a>iVar</h2><figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// An opaque type that represents an instance variable.</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_ivar *Ivar;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> objc_ivar &#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *ivar_name                                          OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *ivar_type                                          OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ivar_offset                                          OBJC2_UNAVAILABLE;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __LP64__</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125;      </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_ivar_list &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ivar_count                                           OBJC2_UNAVAILABLE;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __LP64__</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"comment\">/* variable length structure */</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_ivar ivar_list[<span class=\"number\">1</span>]                            OBJC2_UNAVAILABLE;</span><br><span class=\"line\">&#125;        </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"property\"><a href=\"#property\" class=\"headerlink\" title=\"property\"></a>property</h2><figure class=\"highlight gauss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// An opaque type that represents an Objective-C declared property.</span></span><br><span class=\"line\">typedef <span class=\"keyword\">struct</span> <span class=\"type\">objc_property</span> *objc_property_t</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"property-39-s-attribute\"><a href=\"#property-39-s-attribute\" class=\"headerlink\" title=\"property&#39;s attribute\"></a>property&#39;s attribute</h2><figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Defines a property attribute</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;           <span class=\"comment\">/**&lt; The name of the attribute */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *value;          <span class=\"comment\">/**&lt; The value of the attribute (usually empty) */</span></span><br><span class=\"line\">&#125; objc_property_attribute_t;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"方法和消息\"><a href=\"#方法和消息\" class=\"headerlink\" title=\"方法和消息\"></a>方法和消息</h1><h2 id=\"SEL\"><a href=\"#SEL\" class=\"headerlink\" title=\"SEL\"></a>SEL</h2><figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// An opaque type that represents a method selector.</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_selector *SEL;</span><br></pre></td></tr></table></figure>\n\n<p>objc_selector是一个透明类型，没找到其定义，但在[runtime/objc-sel.mm]中有获取SEL的方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *sel_getName(SEL sel) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!sel) <span class=\"keyword\">return</span> <span class=\"string\">&quot;&lt;null selector&gt;&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *)(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>*)sel;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可见SEL其实是一个字符串指针。<br>在其他资料中（忘了哪里）有读到：</p>\n<blockquote>\n<p>SEL是一个附加了匹配加速功能的字符串</p>\n</blockquote>\n<p>即其是一个字符串，但有着一套自己的匹配优化设计。</p>\n<h2 id=\"IMP\"><a href=\"#IMP\" class=\"headerlink\" title=\"IMP\"></a>IMP</h2><figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// A pointer to the function of a method implementation. </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span> (*IMP)(<span class=\"keyword\">void</span> <span class=\"comment\">/* id, SEL, ... */</span> ); </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">id</span> (*IMP)(<span class=\"keyword\">id</span>, SEL, ...); </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Method\"><a href=\"#Method\" class=\"headerlink\" title=\"Method\"></a>Method</h2><figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// An opaque type that represents a method in a class definition.</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_method *Method;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_method &#123;</span><br><span class=\"line\">    SEL method_name                                          OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *method_types                                       OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    IMP method_imp                                           OBJC2_UNAVAILABLE;</span><br><span class=\"line\">&#125;      </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_method_list &#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_method_list *obsolete                        OBJC2_UNAVAILABLE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> method_count                                         OBJC2_UNAVAILABLE;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __LP64__</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"comment\">/* variable length structure */</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_method method_list[<span class=\"number\">1</span>]                        OBJC2_UNAVAILABLE;</span><br><span class=\"line\">&#125;                                                            OBJC2_UNAVAILABLE;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Protocol\"><a href=\"#Protocol\" class=\"headerlink\" title=\"Protocol\"></a>Protocol</h1><h2 id=\"Protocol-1\"><a href=\"#Protocol-1\" class=\"headerlink\" title=\"Protocol\"></a>Protocol</h2><figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Protocol</span> : <span class=\"title\">Object</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">@private</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *protocol_name OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_protocol_list *protocol_list OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_method_description_list *instance_methods OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_method_description_list *class_methods OBJC2_UNAVAILABLE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"objc-protocol-list\"><a href=\"#objc-protocol-list\" class=\"headerlink\" title=\"objc_protocol_list\"></a>objc_protocol_list</h2><figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_protocol_list &#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_protocol_list *next;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> count;</span><br><span class=\"line\">    Protocol *list[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"objc-method-description\"><a href=\"#objc-method-description\" class=\"headerlink\" title=\"objc_method_description\"></a>objc_method_description</h2><figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Defines a method</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> objc_method_description &#123;</span><br><span class=\"line\">  SEL name;               <span class=\"comment\">/**&lt; The name of the method */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> *types;            <span class=\"comment\">/**&lt; The types of the method arguments */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_method_description_list &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> objc_method_description list[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __OBJC__</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@class</span> <span class=\"title\">Protocol</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_object Protocol;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Defines a method</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> objc_method_description &#123;</span><br><span class=\"line\">  SEL name;               <span class=\"comment\">/**&lt; The name of the method */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> *types;            <span class=\"comment\">/**&lt; The types of the method arguments */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Category\"><a href=\"#Category\" class=\"headerlink\" title=\"Category\"></a>Category</h1><figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// An opaque type that represents a category.</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_category *Category;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_category &#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *category_name                                      OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *class_name                                         OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_method_list *instance_methods                OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_method_list *class_methods                   OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class=\"line\">&#125;                                                            OBJC2_UNAVAILABLE;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","categories":["iOS","Objective-C","Essentials","Basic"]},{"title":"Objective-C:variable arguments method","url":"/2015/06/11/iOS/Objective-C/essentials/Basic/Objc_essentials_variable_arguments/","content":"<p>定义一个有可变参数列表的函数有以下限制：</p>\n<ol>\n<li>可变参数列表函数的参数除了可变列表外，还必须有其他参数</li>\n<li>可变参数列表必须位于参数列表的最后</li>\n</ol>\n<p>以给NSMutableArray对象增加一个添加对象的方法为例：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)appendObjects:(<span class=\"keyword\">id</span>)firstObject, ...&#123;</span><br><span class=\"line\">  <span class=\"keyword\">id</span> eachObject;</span><br><span class=\"line\">  va_list argumentList;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (firstObject) \t\t    \t<span class=\"comment\">// The first argument isn&#x27;t part of the varargs list,</span></span><br><span class=\"line\">  &#123;                                   \t<span class=\"comment\">// so we&#x27;ll handle it separately.</span></span><br><span class=\"line\"> \t \t[<span class=\"keyword\">self</span> addObject: firstObject];</span><br><span class=\"line\">  \t\tva_start(argumentList, firstObject); \t\t<span class=\"comment\">// Start scanning for arguments after firstObject.</span></span><br><span class=\"line\">  \t\t<span class=\"keyword\">while</span> (eachObject = va_arg(argumentList, <span class=\"keyword\">id</span>))   <span class=\"comment\">// As many times as we can get an argument of type &quot;id&quot;</span></span><br><span class=\"line\">      \t\t\t[<span class=\"keyword\">self</span> addObject: eachObject]; \t\t<span class=\"comment\">// that isn&#x27;t nil, add it to self&#x27;s contents.</span></span><br><span class=\"line\">  \t\tva_end(argumentList);</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可变参数函数获取每个参数的方法是：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1. 定义va_list类型的变量，准备存贮各个参数</span></span><br><span class=\"line\">  va_list argumentsList;</span><br><span class=\"line\"><span class=\"comment\">//2. 使用va_start()方法，初始化va_list参数列表</span></span><br><span class=\"line\"><span class=\"comment\">//   va_start的第二个参数是...前面的参数名，用于分割参数列表</span></span><br><span class=\"line\">  va_start(argumentsList, 可变参数的前一个参数变量名);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//3. 使用va_arg(argumentsList,类型);来迭代获取每一个参数</span></span><br><span class=\"line\">  <span class=\"keyword\">id</span> object = va_arg(argumentsList,<span class=\"keyword\">id</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//4. 释放va_list变量</span></span><br><span class=\"line\">  va_end(argumentsList);</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n\n<p>最后，调用：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">array</span> appendObjects:first,second,third,nil];</span><br></pre></td></tr></table></figure>\n<p>可变参数个数的函数调用一般以nil结尾。但是在实际使用中，经常会忘记添加<code>nil</code>结尾导致出错。<br>这时，可以在函数声明中添加<code>NS_REQUIRES_NIL_TERMINATION</code>宏来让编译器发错警告：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)appendObjects:(<span class=\"keyword\">id</span>)firstObject,... <span class=\"built_in\">NS_REQUIRES_NIL_TERMINATION</span>;</span><br></pre></td></tr></table></figure>\n\n<p>参考：<br>@<a href=\"https://developer.apple.com/library/content/qa/qa1405/_index.html\">Technical Q&amp;A QA1405</a><br>@<a href=\"https://www.cocoawithlove.com/2009/05/variable-argument-lists-in-cocoa.html\">Variable argument lists in Cocoa</a></p>\n","categories":["iOS","Objective-C","Essentials","Basic"]},{"title":"NSObject:Copying","url":"/2015/06/03/iOS/Objective-C/essentials/NSObject/NSObject_copying/","content":"<h2 id=\"About-id-copy\"><a href=\"#About-id-copy\" class=\"headerlink\" title=\"About-(id)copy;\"></a>About<code>-(id)copy;</code></h2><p>首先，如果一个对象希望支持COPY操作，那么其需要实现<code>&lt;NSCopying&gt;</code>或者<code>&lt;NSMutableCopying&gt;</code>协议。<br>具体要做的是：</p>\n<ol>\n<li>遵从NSCopying或者NSMutablCopying协议</li>\n<li>实现协议对应的方法：<code>copyWithZone:</code>或者<code>mutableCopyWithZone:</code></li>\n</ol>\n<p>然后,因为对象几乎都继承自NSObject，然而可以看到NSObject只遵从了&#60;NSObject&#62;而没有&#60;NSCopying&#62;<br>这说明NSObject对象本身是没有实现NSCopying协议，不支持COPY操作的。</p>\n<span id=\"more\"></span>\n<p>尽管如此，NSObject提供了2个方法：</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"name\">id</span>)copy<span class=\"comment\">;</span></span><br><span class=\"line\">- (<span class=\"name\">id</span>)mutableCopy<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>这里，需要知道的是：NSObject的<code>-(id)copy</code>其实是NSObject提供COPY操作的便捷方法。其本质是调用<code>&lt;NSCopying&gt;</code>的<code>-(id)copyWithZone:</code>来进行复制，因此，如果调用<code>-(id)copy</code>而没有实现<code>&lt;NSCopying&gt;</code>的<code>-(id)copyWithZone:</code>方法，则会抛出异常。<br><code>-(id)mutableCopy</code>同理。</p>\n<p>所以，如果需要为对象添加复制，要做的依然是上述的：实现<code>&lt;NSCopying&gt;</code>或者<code>&lt;NSMutableCopying&gt;</code>协议。</p>\n<p>另外，在为自定义对象实现<code>(id)copyWithZone:</code>方法时，有一个比较重要的细节：<br><em>在实现中使用<code>[self class]</code>而不是<code>类名</code>。</em></p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (id)<span class=\"symbol\">copyWithZone:</span>(NSZone *)zone&#123;</span><br><span class=\"line\">  /<span class=\"regexp\">/应使用[self class]而不是类名，这样可以保证在继承关系中，调用本方法的正确性。</span></span><br><span class=\"line\"><span class=\"regexp\">\tCustomObject *object = [[[self class] allocWithZone:zone] init];</span></span><br><span class=\"line\"><span class=\"regexp\">    ...</span></span><br><span class=\"line\"><span class=\"regexp\">    ...</span></span><br><span class=\"line\"><span class=\"regexp\">    return object;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>试想：现有一个ChildObject继承自CustomObject，其<code>(id)copyWithZone:</code>方法实现为：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (id)copyWithZone:(<span class=\"type\">NSZone</span> *)zone&#123;</span><br><span class=\"line\">  <span class=\"type\">ChildObject</span> *<span class=\"class\"><span class=\"keyword\">object</span> </span>= [<span class=\"keyword\">super</span> copyWithZone:zone];</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">object</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当其实现中调用<code>[super copyWithZone:zone];</code>时，如果父类的copy方法中写的不是<code>[self class]</code>而是<code>[CustomObject]</code>的话，就将返回错误的父类型，而产生错误。</p>\n<h2 id=\"shallow-amp-deep\"><a href=\"#shallow-amp-deep\" class=\"headerlink\" title=\"shallow &amp; deep\"></a>shallow &amp; deep</h2><p>图书馆里有1本书。<br>Shallow：每个人都抄了那1本书的书架号，知道那1本书在哪，都可以去查阅，查阅的是同一本。（复制是指抄了个书架号给你）<br>Deep：每个人在查阅之前都复印了1本，放在自己知道的书架号，所查阅的也都是自己的那一本。（复制是真的复印了一本）</p>\n<p>显然：<br>Shallow容易出现的问题是，不独立：某人在书上涂鸦了，其他人也都会看到这个涂鸦。<br>优点是：复制更快捷，空间资源也更省。（仅复制个书架号，书也只一本，占用空间更少）<br>Deep优点也很明显：大家都有独立的书。<br>缺点是：复制耗时，耗空间。（一人一本书，又要复制书内容，又要图书馆挪地方来放书，图书馆空间还是有限的）。</p>\n<p>图书馆就是内存空间，书就是对象，书架号就是地址。<br>我想，shallow copy和deep copy大概就是这么个意思。<br>苹果文档上的图解：<br><img src=\"https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Art/object_copying_2x.png\"></p>\n<p>在实际开发中，对象如果需要复制，是shallow还是deep显然取决于业务逻辑。<br>不过，需要知道的是：Foundation框架中的NSValue,NSNumber,NSString,NSArray等容器类中，<code>-(id)copy</code>操作所做的都是shallow copy。</p>\n<h2 id=\"copy-amp-mutableCopy\"><a href=\"#copy-amp-mutableCopy\" class=\"headerlink\" title=\"copy &amp; mutableCopy\"></a>copy &amp; mutableCopy</h2><p>如果想让对象分为分变与不可变的，那么就需要同时实现<code>&lt;NSCopying&gt;</code>和<code>&lt;NSMutableCopying&gt;</code>.<br>Foundation框架中的对象，不论对象本身是可变还是不可变类型，<code>copy</code>方法永远返回的都是不可变对象，相反<code>mutableCopy</code>永远返回的都是可变对象。</p>\n<p>另外，从一定角度来看的话，mutable与deep copy也是有关系的。<br>为什么这么说？因为mutable意味着对象的可变性，对象的可变性会为所有该对象的持有对象带来副作用的问题。在复制对象时，有些引用视其为可变对象的同时，有些引用视其为不可变对象的，这显然会引起问题。因此，必须要分别对待。<br>所以，当mutable与copy一起出现时（复制的同时对象的可变性将发生变化），为了避免副作用的问题，复制方式也会发生变化，如<code>mutableCopy</code>一般将进行deep copy。</p>\n<h2 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h2><p>这里用Foundation框架中的2种常用类来举例做一下笔记：<br>首先，应该明确，容器类和非容器类应该区别对待。因为容器类中的对象，可能还会存在层次问题：比如NSArray容器中的每一个对象都是其他的NSArray，显然是更复杂的。<br>这里我用NSString作为非容器的代表，NSArray作为容器的代表来进行笔记。</p>\n<h3 id=\"shallow-copy\"><a href=\"#shallow-copy\" class=\"headerlink\" title=\"shallow copy\"></a>shallow copy</h3><p><em>Foundation框架中的NSValue,NSNumber,NSString,NSArray等容器类中，-(id)copy操作所做的都是shallow copy</em></p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span>* str = [<span class=\"built_in\">NSString</span> new];</span><br><span class=\"line\"><span class=\"built_in\">NSString</span>* strCopy = [str <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span>* arr = @[<span class=\"string\">@&quot;one&quot;</span>,<span class=\"string\">@&quot;two&quot;</span>,<span class=\"string\">@&quot;three&quot;</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span>* arrCopy = [arr <span class=\"keyword\">copy</span>];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>可以验证复制对象与源对象都指向同一地址。而对于NSArray容器类来说，不但自身与源对象指向同一地址，容器中的内容也与原始内容指向的地址逐一一致。</p>\n<h3 id=\"copy-amp-mutableCopy-1\"><a href=\"#copy-amp-mutableCopy-1\" class=\"headerlink\" title=\"copy &amp; mutableCopy\"></a>copy &amp; mutableCopy</h3><p><em>不论对象本身是可变还是不可变类型，<code>copy</code>方法永远返回的都是不可变对象，相反<code>mutableCopy</code>永远返回的都是可变对象。</em></p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span>* str = [<span class=\"built_in\">NSString</span> new];</span><br><span class=\"line\"><span class=\"built_in\">NSString</span>* strCopy = [str mutableCopy];</span><br><span class=\"line\"><span class=\"built_in\">NSMutableString</span>*  strMCopy = [str <span class=\"keyword\">copy</span>];</span><br></pre></td></tr></table></figure>\n<p>可以验证strCopy类型虽然是NSString但是却持有的<code>mutablCopy</code>返回的NSMutablString对象，对它采取强转后进行appendString等操作无障碍。<br>然而strMCopy类型虽然是NSMutablString但是却持有<code>copy</code>返回的NSString对象，对其进行appendString等操作将运行时错误。</p>\n<h3 id=\"copy-amp-mutability\"><a href=\"#copy-amp-mutability\" class=\"headerlink\" title=\"copy &amp; mutability\"></a>copy &amp; mutability</h3><p><em>当mutable与copy一起出现时（复制的同时对象的可变性将发生变化），为了避免副作用的问题，复制方式也会发生变化，如<code>mutableCopy</code>一般将进行deep copy。</em></p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span>* str = [<span class=\"built_in\">NSString</span> new];</span><br><span class=\"line\"><span class=\"built_in\">NSString</span>* strCopy = [str <span class=\"keyword\">copy</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSString</span>* strMCopy = [str mutableCopy];</span><br><span class=\"line\">.</span><br><span class=\"line\">.<span class=\"comment\">//NSValue...</span></span><br><span class=\"line\">.<span class=\"comment\">//NSDictionary...</span></span><br><span class=\"line\">.</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span>* arr = @[<span class=\"string\">@&quot;one&quot;</span>,<span class=\"string\">@&quot;two&quot;</span>,<span class=\"string\">@&quot;three&quot;</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span>* arrCopy = [arr <span class=\"keyword\">copy</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span>* arrMCopy = [arr mutableCopy];</span><br></pre></td></tr></table></figure>\n<p>str，strCopy，arr，arrCopy由于mutability没有发生改变，进行shallow copy，而strMCopy和arrMCopy由于和源对象在复制的同时mutability发生了变化，都另外分配了地址进行了deep copy。</p>\n<h4 id=\"关于容器类的deep-copy\"><a href=\"#关于容器类的deep-copy\" class=\"headerlink\" title=\"关于容器类的deep copy\"></a>关于容器类的deep copy</h4><p>在这里，容器类的deep copy比较特殊：<br>上面的笔记中的NSArray对象：arrMCopy，虽然本身另外分配了地址，但从输出其内容的地址来看，其中的内容还是指向的原始对象的内容。意味着其内容还是shallow copy。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"code\"><pre><span class=\"line\">[[<span class=\"name\">arrMCopy</span> objectAtIndex:0] doSomething]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>如果我们使用上面的操作，干其他一些事情，仍然会影响到原始的arr对象。因此对容器类而言，这并不是true deep copy.<br>关于容器类中所装内容的deep copy，苹果文档有介绍：<a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html#//apple_ref/doc/uid/TP40010162-SW3\">Copying Collections.</a></p>\n<p>其中介绍了2种方法：</p>\n<h5 id=\"第一种方法：initWithXXXX-copyItems\"><a href=\"#第一种方法：initWithXXXX-copyItems\" class=\"headerlink\" title=\"第一种方法：initWithXXXX:copyItems:\"></a>第一种方法：initWithXXXX:copyItems:</h5><p>使用容器类的<code>initWithXXXX:copyItems:</code>方法。<br>该方法在利用另一个容器对象进行初始化的同时，会向原容器中每一个对象发送<code>copyWithZone:</code>消息。因此，如果容器中的内容是自定义类的话，应该让它们实现<code>&lt;NSCopying&gt;</code>否则将运行时错误。<br>如果容器只有1层。这将可以得到deep copy。</p>\n<p>但是如果容器是超过1层的，比如：容器中的对象也是容器。这种方法就会出现问题。<br>为什么呢？<br>因为：上文其实已经说过了<em>该方法在利用另一个容器对象进行初始化的同时，会向原容器中每一个对象发送<code>copyWithZone:</code>消息。</em>而如果容器中的对象又是容器时，就相当于向该对象（容器）发送<code>copyWithZone:</code>消息。而Foundation框架中的容器的<code>copyWithZone:</code>方法都进行的是shallow copy。结果就是容器中的对象（每一个又都是容器）又都进行了一次shallow copy，那么其深层的数据也都全是shallow的，这不是想要的deep copy的结果。</p>\n<p>关于这一点，文档提出了第二种方法：</p>\n<h5 id=\"第二种方法：利用归档\"><a href=\"#第二种方法：利用归档\" class=\"headerlink\" title=\"第二种方法：利用归档\"></a>第二种方法：利用归档</h5><p>利用归档，在归档后立即反归档。<br>这需要对象都实现<code>&lt;NSCoding&gt;</code>协议。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span>* trueDeepCopyArray = [<span class=\"built_in\">NSKeyedUnarchiver</span> unarchiveObjectWithData:</span><br><span class=\"line\">          [<span class=\"built_in\">NSKeyedArchiver</span> archivedDataWithRootObject:oldArray]];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>以上复制都在内存中完成，不需要落地到文件。<br>留一个参考地址：<a href=\"http://stackoverflow.com/questions/2002174/copy-mutablecopy\">stackoverflow:copy-mutablecopy</a></p>\n<h5 id=\"一些细节\"><a href=\"#一些细节\" class=\"headerlink\" title=\"一些细节\"></a>一些细节</h5><p>关于<code>initWithXXXX:copyItems:</code>还有许多细节需要注意：<br>首先，可以注意到<code>initWithXXXX:copyItems:</code>是通过向每一个容器内的对象发送<code>copyWithZone:</code>消息来进行复制，而不是<code>mutableCopyWithZone:</code>,这样的结果是，返回的结果无论原对象是immutable还是mutable的都将会成为immutable，因此会对容器内的对象的mutability产生影响。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span>* arr = @[[<span class=\"built_in\">NSMutableString</span> stringWithString:<span class=\"string\">@&quot;one&quot;</span>],<span class=\"string\">@&quot;two&quot;</span>,<span class=\"string\">@&quot;three&quot;</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span>* deepCopy = [[<span class=\"built_in\">NSMutableArray</span> alloc]initWithArray:arr copyItems:<span class=\"literal\">YES</span>];</span><br></pre></td></tr></table></figure>\n<p>如上述完成复制后，第一个元素NSMutableString的可变性因为<code>copyWithZone:</code>的影响变为不可变。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"name\">deepCopy</span>[<span class=\"name\">0</span>]appendString:@<span class=\"string\">&quot;hi&quot;</span>]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>将产生运行时错误。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span>* arr = @[[<span class=\"built_in\">NSMutableString</span> stringWithString:<span class=\"string\">@&quot;one&quot;</span>],<span class=\"string\">@&quot;two&quot;</span>,<span class=\"string\">@&quot;three&quot;</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span>* deepCopy = [[<span class=\"built_in\">NSMutableArray</span> alloc]initWithArray:arr copyItems:<span class=\"literal\">NO</span>];</span><br></pre></td></tr></table></figure>\n<p>如上述完成复制后，第一个元素NSMutableString的可变性因为<code>copyItems:NO</code>而没有向元素发送<code>copyWithZone:</code>消息，因此其可变性不产生影响，</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"name\">deepCopy</span>[<span class=\"name\">0</span>]appendString:@<span class=\"string\">&quot;hi&quot;</span>]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>将可以顺利进行。<br>但这种情况下，容器完成的是shallow copy,等同于<code>[arr copy]</code>。</p>\n<p>关于对可变性的影响，文档有总结：</p>\n<blockquote>\n<p>When you copy a collection, the mutability of that collection or the objects it contains can be affected. Each method of copying has slightly different effects on the mutability of the objects in a collection of arbitrary depth:</p>\n</blockquote>\n<ul>\n<li>copyWithZone: makes the surface level immutable. All deeper levels have the mutability they previously had.</li>\n<li>initWithArray:copyItems: with NO as the second parameter gives the surface level the mutability of the class it is allocated as. All deeper levels have the mutability they previously had.</li>\n<li>initWithArray:copyItems: with YES as the second parameter gives the surface level the mutability of the class it is allocated as. The next level is immutable, and all deeper levels have the mutability they previously had.</li>\n<li>Archiving and unarchiving the collection leaves the mutability of all levels as it was before.</li>\n</ul>\n<p>关于以上内容，更应该知道的是为什么：<br>1.copyWithZone: makes the surface level immutable. All deeper levels have the mutability they previously had.<br>为什么？<br>还记得，NSObject的<code>-(id)copy</code>就是简单的对<code>copyWithZone:</code>的调用。<br>这里，<code>[XXX copyWithZone:]</code>就等同于<code>[XXX copy]</code>，<br><code>copy</code>返回的都是不可变对象，因此makes the surface level immutable。<br>而上文说过，Foundation框架中这些类<code>copy</code>进行的都是shallow copy。因此copy后持有的还是源指针，所以深层对象的可变性都不会变化。</p>\n<p>2.initWithArray:copyItems: with NO as the second parameter gives the surface level the mutability of the class it is allocated as. All deeper levels have the mutability they previously had.<br>为什么？<br>上文中已经说过了：<br>因为<code>copyItems:NO</code>而没有向各个元素发送<code>copyWithZone:</code>消息，进行的是向每一个元素发送<code> retain</code>,因此All deeper levels have the mutability they previously had.</p>\n<p>3.initWithArray:copyItems: with YES as the second parameter gives the surface level the mutability of the class it is allocated as. The next level is immutable, and all deeper levels have the mutability they previously had.<br>为什么？<br><code>copyItems:YES</code>后，向每个元素发送<code>copyWithZone:</code>，而不是<code>mutableCopyWithZone:</code>,返回的结果无论原对象是immutable还是mutable的都将会成为immutable，因此The next level is immutable，而又因为：如果还有更深层的元素的话，就意味着这一层的元素也是容器，那么容器的<code>copyWithZone:</code>进行的又是shallow copy，因此all deeper levels have the mutability they previously had.</p>\n<p>4.Archiving and unarchiving the collection leaves the mutability of all levels as it was before.<br>而使用归档完成的容器复制，其元素的可变性与复制前<em>保持一致</em>。所以利用归档进行容器复制应该是比较轻松的方式。</p>\n","categories":["iOS","Objective-C","Essentials","NSObject"],"tags":["NSObject"]},{"title":"NSObject:introspection","url":"/2015/07/13/iOS/Objective-C/essentials/NSObject/NSObject_introspection/","content":"<p><em>做一下笔记,关于自省：</em></p>\n<h1 id=\"Identifying-Classes\"><a href=\"#Identifying-Classes\" class=\"headerlink\" title=\"Identifying Classes\"></a>Identifying Classes</h1><h2 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a>class</h2><p>NSObject对象和NSObject协议提供了class方法获取对象的class信息。</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"code\"><pre><span class=\"line\">+ (Class)<span class=\"class\"><span class=\"keyword\">class</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (Class)<span class=\"class\"><span class=\"keyword\">class</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> object_getClass(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>虽然简单瞟一眼就知道是怎么回事。但也可以仔细想一下，加深理解。比如：<br>为什么同样是获取class信息，然而2个class方法的实现不一样。<br>一个是<code>returen self;</code>而另一个是<code>return object_getClass(self);</code><br>先来看一下<code>object_getClass</code>的实现：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Class <span class=\"keyword\">object</span><span class=\"constructor\">_getClass(<span class=\"params\">id</span> <span class=\"params\">obj</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj) return obj-&gt;get<span class=\"constructor\">Isa()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> return Nil;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其通过isa指针获取类信息。</p>\n<p>然而</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (Class)<span class=\"class\"><span class=\"keyword\">class</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> object_getClass(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>是实例方法，调用者为实例对象。对象的isa指向其所属的Class。因此通过<code>object_getClass</code>来<code>obj-&gt;getIsa()</code>。<br>相反，</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"code\"><pre><span class=\"line\">+ (Class)<span class=\"class\"><span class=\"keyword\">class</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>是类方法。调用者为类。如果还是<code>obj-&gt;getIsa()</code>的话，返回的就是类的isa，其指向的是metaclass。而<code>self</code>是每个方法的隐藏参数，代表消息的接收者。类方法<code>+ class</code>的消息接收者就是类本身，正是此时的<code>self</code>，所以返回<code>return self</code>，才是获取类信息的正解。</p>\n<h2 id=\"superclass\"><a href=\"#superclass\" class=\"headerlink\" title=\"superclass\"></a>superclass</h2><p>NSObject对象和NSObject协议提供的获取superclass信息的方法：</p>\n<figure class=\"highlight monkey\"><table><tr><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"class\"><span class=\"keyword\">Class</span>)<span class=\"title\">superclass</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">self</span>-&gt;superclass;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"class\"><span class=\"keyword\">Class</span>)<span class=\"title\">superclass</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">self</span> <span class=\"class\"><span class=\"keyword\">class</span>]-&gt;<span class=\"title\">superclass</span>;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其也根据类方法和实例方法有不同的实现。</p>\n<h1 id=\"Testing-Object-Inheritance\"><a href=\"#Testing-Object-Inheritance\" class=\"headerlink\" title=\"Testing Object Inheritance\"></a>Testing Object Inheritance</h1><h2 id=\"isMemberOfClass\"><a href=\"#isMemberOfClass\" class=\"headerlink\" title=\"isMemberOfClass\"></a>isMemberOfClass</h2><p><code>isMemberOfClass</code>：对象是否是某类的实例。</p>\n<figure class=\"highlight monkey\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (BOOL)isMemberOfClass:(<span class=\"class\"><span class=\"keyword\">Class</span>)<span class=\"title\">cls</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">self</span> <span class=\"class\"><span class=\"keyword\">class</span>] == <span class=\"title\">cls</span>;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"isKindOfClass\"><a href=\"#isKindOfClass\" class=\"headerlink\" title=\"isKindOfClass\"></a>isKindOfClass</h2><p><code>isKindOfClass</code>：对象是否继承自某类。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Class tcls = [<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>]; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tcls == cls) <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Testing-Functionality\"><a href=\"#Testing-Functionality\" class=\"headerlink\" title=\"Testing Functionality\"></a>Testing Functionality</h1><h2 id=\"instancesRespondToSelector\"><a href=\"#instancesRespondToSelector\" class=\"headerlink\" title=\"+ instancesRespondToSelector\"></a>+ instancesRespondToSelector</h2><p>NSObject提供了类方法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"selector-tag\">BOOL</span>)<span class=\"selector-tag\">instancesRespondToSelector</span><span class=\"selector-pseudo\">:(SEL)aSelector</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)instancesRespondToSelector:(SEL)sel &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!sel) <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> class_respondsToSelector(<span class=\"keyword\">self</span>, sel);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>检验类的实例是否响应某消息。</p>\n<h2 id=\"respondsToSelector\"><a href=\"#respondsToSelector\" class=\"headerlink\" title=\"- respondsToSelector\"></a>- respondsToSelector</h2><p>NSObject协议提供了实例方法：</p>\n<figure class=\"highlight erlang\"><table><tr><td class=\"code\"><pre><span class=\"line\">- <span class=\"params\">(BOOL)</span>respondsToSelector:<span class=\"params\">(SEL)</span>aSelector</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (BOOL)respondsToSelector:(SEL)sel &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!sel) <span class=\"keyword\">return</span> NO;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> class_respondsToSelector_inst([self <span class=\"class\"><span class=\"keyword\">class</span>], <span class=\"type\">sel</span>, <span class=\"type\">self);</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看一下源码：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">BOOL <span class=\"keyword\">class</span><span class=\"constructor\">_respondsToSelector(Class <span class=\"params\">cls</span>, SEL <span class=\"params\">sel</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return <span class=\"keyword\">class</span><span class=\"constructor\">_respondsToSelector_inst(<span class=\"params\">cls</span>, <span class=\"params\">sel</span>, <span class=\"params\">nil</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，前者<code>class_respondsToSelector</code>只是<code>class_respondsToSelector_inst</code>方法最后的实例参数为nil而已。<br>干的都是一件事：<br>就是从class的方法列表中查找方法实现，找到就成功，否则失败。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// inst is an instance of cls or a subclass thereof, or nil if none is known.</span></span><br><span class=\"line\"><span class=\"comment\">// Non-nil inst is faster in some cases. See lookUpImpOrForward() for details.</span></span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> class_respondsToSelector_inst(Class cls, SEL sel, <span class=\"keyword\">id</span> inst)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    IMP imp;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!sel  ||  !cls) <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Avoids +initialize because it historically did so.</span></span><br><span class=\"line\">    <span class=\"comment\">// We&#x27;re not returning a callable IMP anyway.</span></span><br><span class=\"line\">    imp = lookUpImpOrNil(cls, sel, inst, </span><br><span class=\"line\">                         <span class=\"literal\">NO</span><span class=\"comment\">/*initialize*/</span>, <span class=\"literal\">YES</span><span class=\"comment\">/*cache*/</span>, <span class=\"literal\">YES</span><span class=\"comment\">/*resolver*/</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> imp ? <span class=\"literal\">YES</span> : <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Testing-Protocol-Conformance\"><a href=\"#Testing-Protocol-Conformance\" class=\"headerlink\" title=\"Testing Protocol Conformance\"></a>Testing Protocol Conformance</h1><p>NSObject和NSObject协议均提供了验证是否遵从协议的方法。<br>干的事情都一样，只是一个为了方便类对象的调用，一个为了方便实例对象的调用。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)conformsToProtocol:(Protocol *)protocol &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!protocol) <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Class tcls = <span class=\"keyword\">self</span>; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (class_conformsToProtocol(tcls, protocol)) <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)conformsToProtocol:(Protocol *)protocol &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!protocol) <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Class tcls = [<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>]; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (class_conformsToProtocol(tcls, protocol)) <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"code\"><pre><span class=\"line\">BOOL class_conformsToProtocol(<span class=\"name\">Class</span> cls, Protocol *proto_gen)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    protocol_t *proto = newprotocol(<span class=\"name\">proto_gen</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">    const protocol_list_t **plist<span class=\"comment\">;</span></span><br><span class=\"line\">    unsigned int i<span class=\"comment\">;</span></span><br><span class=\"line\">    BOOL result = NO<span class=\"comment\">;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    if (!cls) return NO<span class=\"comment\">;</span></span><br><span class=\"line\">    if (!proto_gen) return NO<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    rwlock_read(<span class=\"name\">&amp;runtimeLock</span>)<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    assert(<span class=\"name\">cls-&gt;isRealized</span>())<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    for (<span class=\"name\">plist</span> = cls-&gt;data()-&gt;protocols<span class=\"comment\">; plist  &amp;&amp;  *plist; plist++) &#123;</span></span><br><span class=\"line\">        for (<span class=\"name\">i</span> = <span class=\"number\">0</span><span class=\"comment\">; i &lt; (*plist)-&gt;count; i++) &#123;</span></span><br><span class=\"line\">            protocol_t *p = remapProtocol((*plist)-&gt;list[i])<span class=\"comment\">;</span></span><br><span class=\"line\">            if (<span class=\"name\">p</span> == proto || protocol_conformsToProtocol_nolock(<span class=\"name\">p</span>, proto)) &#123;</span><br><span class=\"line\">                result = YES<span class=\"comment\">;</span></span><br><span class=\"line\">                goto done<span class=\"comment\">;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> done:</span><br><span class=\"line\">    rwlock_unlock_read(<span class=\"name\">&amp;runtimeLock</span>)<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    return result<span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从class的结构体种获取<code>protocol_list_t</code>,其中存储了类所有实现的协议。遍历每一个协议验证协议所实现的协议（别忘了，协议也是可继承的）<code>protocol_conformsToProtocol_nolock</code>:</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">static</span> <span class=\"keyword\">bool</span> </span><br><span class=\"line\">protocol_conformsToProtocol_nolock(protocol_t *<span class=\"built_in\">self</span>, protocol_t *other)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    rwlock_assert_locked(&amp;runtimeLock);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">self</span>  ||  !other) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> NO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// protocols need not be fixed up</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == strcmp(<span class=\"built_in\">self</span>-&gt;mangledName, other-&gt;mangledName)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> YES;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">self</span>-&gt;protocols) &#123;</span><br><span class=\"line\">        uintptr_t i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">self</span>-&gt;protocols-&gt;count; i++) &#123;</span><br><span class=\"line\">            protocol_t *proto = remapProtocol(<span class=\"built_in\">self</span>-&gt;protocols-&gt;list[i]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == strcmp(other-&gt;mangledName, proto-&gt;mangledName)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> YES;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (protocol_conformsToProtocol_nolock(proto, other)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> YES;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> NO;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从line23可以看到，因为协议的可继承性，这里对协议所实现的协议检测有一个递归的过程。<br>检测的方法似乎也很简单：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (0 == strcmp(<span class=\"keyword\">self</span>-&gt;mangledName, other-&gt;mangledName)) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> YES;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>c语言的字符串比较函数，协议名一致，则判定成功，否则失败。</p>\n","categories":["iOS","Objective-C","Essentials","NSObject"],"tags":["NSObject"]},{"title":"NSObject:Load & initialize","url":"/2015/06/02/iOS/Objective-C/essentials/NSObject/NSObject_load_initialize/","content":"<h1 id=\"Load笔记\"><a href=\"#Load笔记\" class=\"headerlink\" title=\"Load笔记\"></a>Load笔记</h1><h2 id=\"关于Load\"><a href=\"#关于Load\" class=\"headerlink\" title=\"关于Load\"></a>关于Load</h2><p>正如字面意义一样，<code>+(void)Load;</code>调用发生在程序的载入阶段而不是执行阶段，这意味着<code>Load</code>发生在<code>main</code>之前。关于Load，文档有如下介绍：</p>\n<blockquote>\n<p>Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.<br>...<br>The load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.<br>...<br>In addition:<br>A class’s +load method is called after all of its superclasses’ +load methods.<br>A category +load method is called after the class’s own +load method.</p>\n</blockquote>\n<blockquote>\n<p>In a custom implementation of load you can therefore safely message other unrelated classes from the same image, but any load methods implemented by those classes may not have run yet.</p>\n</blockquote>\n<span id=\"more\"></span>\n<p><code>load</code>最显著的特点是：</p>\n<ul>\n<li>load调用发生在加载进runtime时</li>\n<li>无论是静态链接或动态加载的类和分类，load都会调用</li>\n<li>类的load调用在其所有superclass的load调用之后</li>\n<li>category的load不会覆盖class的load，这2个方法都会被调用。且分类的load调用在其class的load调用之后</li>\n<li>以上所有的前提是：load方法有实现</li>\n</ul>\n<h2 id=\"load-images\"><a href=\"#load-images\" class=\"headerlink\" title=\"load_images\"></a>load_images</h2><p>关于load的源码，大概入手点应该是：objc-runtime-new.mm中的 load_images方法。<br>删减关于线程互斥之类的代码后：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/***********************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">* load_images</span></span><br><span class=\"line\"><span class=\"comment\">* Process +load in the given images which are being mapped in by dyld.</span></span><br><span class=\"line\"><span class=\"comment\">* Calls ABI-agnostic code after taking ABI-specific locks.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* Locking: write-locks runtimeLock and loadMethodLock</span></span><br><span class=\"line\"><span class=\"comment\">**********************************************************************/</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *</span><br><span class=\"line\">load_images(<span class=\"keyword\">enum</span> dyld_image_states state, <span class=\"keyword\">uint32_t</span> infoCount,</span><br><span class=\"line\">            <span class=\"keyword\">const</span> struct dyld_image_info infoList[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    BOOL found; </span><br><span class=\"line\">    <span class=\"comment\">// Discover load methods</span></span><br><span class=\"line\">    found = load_images_nolock(state, infoCount, infoList);</span><br><span class=\"line\">    <span class=\"comment\">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (found) &#123;</span><br><span class=\"line\">        call_load_methods();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nil;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>load_images</code>就干了2个工作：</p>\n<ol>\n<li>准备load方法</li>\n<li>调用load方法</li>\n</ol>\n<p><code>load_images</code>方法将会在恰当时机被runtime所调用。</p>\n<p><em>Edited：<br><a href=\"/2015/09/11/iOS/Objective-C/runtime/iOS_objc_runtime_lauch/#附：有关于+(void)load;\">关于这个“恰当的调用时机”</a></em></p>\n<h2 id=\"准备load方法\"><a href=\"#准备load方法\" class=\"headerlink\" title=\"准备load方法\"></a>准备load方法</h2><h3 id=\"prepare-load-methods\"><a href=\"#prepare-load-methods\" class=\"headerlink\" title=\"prepare_load_methods\"></a>prepare_load_methods</h3><p><a href=\"http://opensource.apple.com/source/objc4/objc4-680/runtime/objc-runtime-new.mm\">objc-runtime-new.mm</a><br>load_images_nolock调用 <code>prepare_load_methods</code>方法来进行准备工作。</p>\n<figure class=\"highlight cpp\"><figcaption><span>有删减</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">prepare_load_methods</span><span class=\"params\">(<span class=\"keyword\">const</span> headerType *mhdr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> count, i;</span><br><span class=\"line\">    <span class=\"keyword\">classref_t</span> *classlist = </span><br><span class=\"line\">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">        schedule_class_load(remapClass(classlist[i]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">category_t</span> **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">category_t</span> *cat = categorylist[i];</span><br><span class=\"line\">        Class cls = remapClass(cat-&gt;cls);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cls) <span class=\"keyword\">continue</span>;  <span class=\"comment\">// category for ignored weak-linked class</span></span><br><span class=\"line\">        realizeClass(cls);</span><br><span class=\"line\">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class=\"line\">        add_category_to_loadable_list(cat);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>runtime首先获取classlist，然后逐个<code>schedule_class_load</code></li>\n<li>获取categorylist，将categorylist中的category所属的class实现</li>\n<li>最后将category添加进载入列表<code>add_category_to_loadable_list</code>准备调用<code>load</code></li>\n</ol>\n<figure class=\"highlight cpp\"><figcaption><span>有删减</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">schedule_class_load</span><span class=\"params\">(Class cls)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cls) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    assert(cls-&gt;isRealized());  <span class=\"comment\">// _read_images should realize</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Ensure superclass-first ordering</span></span><br><span class=\"line\">    schedule_class_load(cls-&gt;superclass);</span><br><span class=\"line\"></span><br><span class=\"line\">    add_class_to_loadable_list(cls);</span><br><span class=\"line\">    cls-&gt;setInfo(RW_LOADED); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>schedule_class_load</code>中检查class是否有superclass有则递归调用<code>schedule_class_load</code>以将class及其所有superclass添加进载入列表<code>add_class_to_loadable_list</code>.<em>这就是为什么class的load调用在其所有superclass的load之后</em>。</p>\n<p>综合以上2个方法来看。<code>prepare_load_methods</code>干的就是：</p>\n<ol>\n<li>将class列表中的类递归添加入一个存储载入类信息的loadable_list，</li>\n<li>将category列表中的分类添加入一个存储载入分类信息的loadable_list。</li>\n</ol>\n<h3 id=\"add-class-to-loadable-list-和-add-category-to-loadable-list\"><a href=\"#add-class-to-loadable-list-和-add-category-to-loadable-list\" class=\"headerlink\" title=\"add_class_to_loadable_list 和 add_category_to_loadable_list\"></a>add_class_to_loadable_list 和 add_category_to_loadable_list</h3><p><a href=\"http://opensource.apple.com/source/objc4/objc4-647/runtime/objc-loadmethod.mm\">源码见objc-loadmethod.mm</a></p>\n<p>首先定义了一些数据结构：</p>\n<figure class=\"highlight thrift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">loadable_class</span> </span>&#123;</span><br><span class=\"line\">    Class cls;  <span class=\"comment\">// may be nil</span></span><br><span class=\"line\">    IMP method;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">loadable_category</span> </span>&#123;</span><br><span class=\"line\">    Category cat;  <span class=\"comment\">// may be nil</span></span><br><span class=\"line\">    IMP method;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>loadable_class </code>和<code>loadable_category</code>分别代表载入的class和category。</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"code\"><pre><span class=\"line\">IMP <span class=\"function\"><span class=\"keyword\">method</span>;</span></span><br></pre></td></tr></table></figure>\n<p>指向class和category的<code>+(void)load;</code>函数指针，将用于直接调用。</p>\n<figure class=\"highlight cpp\"><figcaption><span>有删减</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/***********************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">* add_class_to_loadable_list</span></span><br><span class=\"line\"><span class=\"comment\">* Class cls has just become connected. Schedule it for +load if</span></span><br><span class=\"line\"><span class=\"comment\">* it implements a +load method.</span></span><br><span class=\"line\"><span class=\"comment\">**********************************************************************/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_class_to_loadable_list</span><span class=\"params\">(Class cls)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    IMP method;</span><br><span class=\"line\">    method = cls-&gt;getLoadMethod();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!method) <span class=\"keyword\">return</span>;  <span class=\"comment\">// Don&#x27;t bother if cls has no +load method</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class=\"line\">        loadable_classes_allocated = loadable_classes_allocated*<span class=\"number\">2</span> + <span class=\"number\">16</span>;</span><br><span class=\"line\">        loadable_classes = (struct loadable_class *)</span><br><span class=\"line\">            _realloc_internal(loadable_classes,</span><br><span class=\"line\">                              loadable_classes_allocated *</span><br><span class=\"line\">                              <span class=\"keyword\">sizeof</span>(struct loadable_class));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class=\"line\">    loadable_classes[loadable_classes_used].method = method;</span><br><span class=\"line\">    loadable_classes_used++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>add_class_to_loadable_list</code>方法实现中：</p>\n<ol>\n<li><code>loadable_classes</code>是一个用来存储载入的class的数组列表。</li>\n<li>runtime将载入的类添加进该数组，之后将用于逐个调用数组中每个类的<code>load</code>。</li>\n<li>9-10行，如果<code>load</code>方法未实现则直接返回。<em>这说明load调用的一切前提是该方法有实现</em>。</li>\n</ol>\n<p>添加category到载入列表的方法<code>add_category_to_loadable_list</code>和上面大同小异。</p>\n<h2 id=\"调用load方法\"><a href=\"#调用load方法\" class=\"headerlink\" title=\"调用load方法\"></a>调用load方法</h2><h3 id=\"call-load-methods\"><a href=\"#call-load-methods\" class=\"headerlink\" title=\"call_load_methods\"></a>call_load_methods</h3><p>在完成将载入类和分类添加如待载入列表后，runtime就完成了准备工作；<br>之后将会进入<code>call_load_methods</code>来逐一调用class和category的load方法。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">/<span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">**<span class=\"emphasis\">*</span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">*</span> call<span class=\"emphasis\">_load_</span>methods</span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">* Call all pending class and category +load methods.</span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">*</span> Class +load methods are called superclass-first. </span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">* Category +load methods are not called until after the parent class&#x27;s +load.</span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">*</span> </span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">* This method must be RE-ENTRANT, because a +load could trigger </span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">*</span> more image mapping. In addition, the superclass-first ordering </span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">* must be preserved in the face of re-entrant calls. Therefore, </span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">*</span> only the OUTERMOST call of this function will do anything, and </span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">* that call will handle all loadable classes, even those generated </span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">*</span> while it was running.</span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">*</span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">*</span> The sequence below preserves +load ordering in the face of </span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">* image loading during a +load, and make sure that no </span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">*</span> +load method is forgotten because it was added during </span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">* a +load call.</span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">*</span> Sequence:</span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">* 1. Repeatedly call class +loads until there aren&#x27;t any more</span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">*</span> 2. Call category +loads ONCE.</span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">* 3. Run more +loads if:</span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">*</span>    (a) there are more classes to load, OR</span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">*    (b) there are some potential category +loads that have </span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">*</span>        still never been attempted.</span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">* Category +loads are only run once to ensure &quot;parent class first&quot; </span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">*</span> ordering, even if a category +load triggers a new loadable class </span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">* and a new loadable category attached to that class. </span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">*</span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">* Locking: loadMethodLock must be held by the caller </span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">*</span>   All other locks must not be held.</span></span><br><span class=\"line\"><span class=\"strong\">**</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span>/</span><br><span class=\"line\">void call<span class=\"emphasis\">_load_</span>methods(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"code\">    static BOOL loading = NO;</span></span><br><span class=\"line\"><span class=\"code\">    BOOL more_categories;</span></span><br><span class=\"line\"><span class=\"code\">    </span></span><br><span class=\"line\"><span class=\"code\">    // Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class=\"line\"><span class=\"code\">    if (loading) return;</span></span><br><span class=\"line\"><span class=\"code\">    loading = YES;</span></span><br><span class=\"line\"><span class=\"code\"></span></span><br><span class=\"line\"><span class=\"code\">    void *pool = objc_autoreleasePoolPush();</span></span><br><span class=\"line\"><span class=\"code\"></span></span><br><span class=\"line\"><span class=\"code\">    do &#123;</span></span><br><span class=\"line\"><span class=\"code\">        // 1. Repeatedly call class +loads until there aren&#x27;t any more</span></span><br><span class=\"line\"><span class=\"code\">        while (loadable_classes_used &gt; 0) &#123;</span></span><br><span class=\"line\"><span class=\"code\">            call_class_loads();</span></span><br><span class=\"line\"><span class=\"code\">        &#125;</span></span><br><span class=\"line\"><span class=\"code\"></span></span><br><span class=\"line\"><span class=\"code\">        // 2. Call category +loads ONCE</span></span><br><span class=\"line\"><span class=\"code\">        more_categories = call_category_loads();</span></span><br><span class=\"line\"><span class=\"code\"></span></span><br><span class=\"line\"><span class=\"code\">        // 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class=\"line\"><span class=\"code\">    &#125; while (loadable_classes_used &gt; 0  ||  more_categories);</span></span><br><span class=\"line\"><span class=\"code\"></span></span><br><span class=\"line\"><span class=\"code\">    objc_autoreleasePoolPop(pool);</span></span><br><span class=\"line\"><span class=\"code\"></span></span><br><span class=\"line\"><span class=\"code\">    loading = NO;</span></span><br><span class=\"line\"><span class=\"code\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>45-53行中，的do-while循环里runtime调用class和category的load<br>其中43-47行的嵌套while循环可见 *load的调用先class的<code>call_class_loads();</code>在class的load调用全部完成后，再category的<code>call_category_loads();</code>*。</p>\n<h4 id=\"class‘s-load\"><a href=\"#class‘s-load\" class=\"headerlink\" title=\"class‘s load\"></a>class‘s load</h4><figure class=\"highlight cpp\"><figcaption><span>有删减</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">call_class_loads</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;  </span><br><span class=\"line\">    <span class=\"comment\">// Call all +loads for the detached list.</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; used; i++) &#123;</span><br><span class=\"line\">        Class cls = classes[i].cls;</span><br><span class=\"line\">        <span class=\"keyword\">load_method_t</span> load_method = (<span class=\"keyword\">load_method_t</span>)classes[i].method;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cls) <span class=\"keyword\">continue</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (PrintLoading) &#123;</span><br><span class=\"line\">            _objc_inform(<span class=\"string\">&quot;LOAD: +[%s load]\\n&quot;</span>, cls-&gt;nameForLogging());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        (*load_method)(cls, SEL_load);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ol>\n<li>从<code>loadable_classes</code>数组从逐个取出载入的class</li>\n<li>取出class中的load方法实现</li>\n<li>调用load方法<code>(*load_method)(cls, SEL_load);</code></li>\n</ol>\n<h4 id=\"category‘s-load\"><a href=\"#category‘s-load\" class=\"headerlink\" title=\"category‘s load\"></a>category‘s load</h4><p><code>call_category_loads</code>方法主要也是从<code>loadable_categories</code>数组逐个取出载入的分类，调用其load方法。另外还有些对新添加分类和调用排序上的操作。</p>\n<h1 id=\"Initialize笔记\"><a href=\"#Initialize笔记\" class=\"headerlink\" title=\"Initialize笔记\"></a>Initialize笔记</h1><h2 id=\"关于Initialize\"><a href=\"#关于Initialize\" class=\"headerlink\" title=\"关于Initialize\"></a>关于Initialize</h2><p><code>+ (void)initialize</code>最显著的特点是：</p>\n<ul>\n<li>每个类只调用其一次</li>\n<li>只在第一条消息发送前调用</li>\n<li>superclass的initialize先于subclass</li>\n<li>如果subclass未实现该方法，那么将再次调用superclass的initialize</li>\n</ul>\n<h2 id=\"从源码来看\"><a href=\"#从源码来看\" class=\"headerlink\" title=\"从源码来看\"></a>从源码来看</h2><p><a href=\"http://opensource.apple.com/source/objc4/objc4-680/runtime/objc-initialize.mm\">关于initialize的源码</a></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">/<span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">**<span class=\"emphasis\">*</span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">*</span> class<span class=\"emphasis\">_initialize.  Send the &#x27;+initialize&#x27; message on demand to any</span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\">* uninitialized class. Force initialization of superclasses first.</span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\"><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">****</span><span class=\"strong\">**/</span></span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\"><span class=\"strong\">void <span class=\"emphasis\">_class_</span>initialize(Class cls)</span></span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\"><span class=\"strong\">&#123;</span></span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\"><span class=\"strong\">    assert(!cls-&gt;isMetaClass());</span></span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\"><span class=\"strong\"></span></span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\"><span class=\"strong\">    Class supercls;</span></span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\"><span class=\"strong\"></span></span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\"><span class=\"strong\">    // Make sure super is done initializing BEFORE beginning to initialize cls.</span></span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\"><span class=\"strong\">    // See note about deadlock above.</span></span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\"><span class=\"strong\">    supercls = cls-&gt;superclass;</span></span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\"><span class=\"strong\">    if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span></span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\"><span class=\"strong\">        <span class=\"emphasis\">_class_</span>initialize(supercls);</span></span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\"><span class=\"strong\">    &#125;</span></span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\"><span class=\"strong\">    </span></span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\"><span class=\"strong\">     // Send the +initialize message.</span></span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\"><span class=\"strong\">     // Note that +initialize is sent to the superclass (again) if </span></span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\"><span class=\"strong\">     // this class doesn&#x27;t implement +initialize. 2157218</span></span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\"><span class=\"strong\">      </span></span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\"><span class=\"strong\">    ((void(<span class=\"emphasis\">*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span></span></span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\"><span class=\"strong\"><span class=\"emphasis\">    </span></span></span></span></span><br><span class=\"line\"><span class=\"strong\"><span class=\"emphasis\"><span class=\"strong\"><span class=\"emphasis\">&#125;</span></span></span></span></span><br></pre></td></tr></table></figure>\n<p>以上是删去线程操作后的代码.</p>\n<p>第13-16行，在subclass的initilize调用前首先会检查superclass的是否initialized情况，因此<em>superclass的initialize先于subclass</em></p>\n<p>第22行，如果class没有initialize那么将向class发送initialize消息，以调用initialize方法:<br><code>((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</code><br>根据Objective-C的消息机制，<code>objc_msgSend</code>将根据<code>isa</code>指针搜索class的方法列表，如果class没有实现该方法，消息机制将追溯到superclass的方法列表继续查找。因此<em>如果class没有实现initialize方法，那么将再次调用superclass的initialize</em>；</p>\n<p>文档中建议了这种方式来避免superclass的initialize的多次调用：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">void</span>)initialize &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> == [ClassName <span class=\"keyword\">self</span>]) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... do the initialization ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，上面的<code>void _class_initialize(Class cls)</code>方法，将会被runtime在方法查找时进行调用，因为当向对象发送消息时，才会进行方法查找。<em>因此，<code>initialize</code>只在第一条消息发送前调用。</em><br>又因为方法查找函数<code>lookUpImpOrForward</code>中有如下实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Check for +initialize</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class=\"line\">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><em>因此，每个类只调用一次<code>initialize</code>。</em></p>\n","categories":["iOS","Objective-C","Essentials","NSObject"],"tags":["NSObject"]},{"title":"->[ NSObject ]","url":"/2015/06/01/iOS/Objective-C/essentials/NSObject/Something%20i%20should%20know%20about-NSObject/","content":"<p>NSObject在Objective-C中无处不在。<br>所以花点时间来学习一下并不过分。<br>关于NSObject的问题罗列在这里。方便查阅。</p>\n<h2 id=\"为什么继承NSObject\"><a href=\"#为什么继承NSObject\" class=\"headerlink\" title=\"为什么继承NSObject\"></a>为什么继承NSObject</h2><p>显然，Objective-C对象也存在着这三个哲学问题：<br>我是谁？<br>我从哪里来？<br>我要到哪里去？<br>这些问题是每一个对象都必须回答的。<br>一劳永逸。作为对象继承体系的根，NSObject负责回答这3个哲学问题并且提供作为Objective-C对象的基本行为准则(公用方法)。<br>对于Objective-C而言，runtime是对象，消息机制等的基石。而NSObject知道如何与runtime打交道。<br>对象通过继承NSObject获得与runtime交互的能力和作为Objective-C对象的基本行为。</p>\n<h2 id=\"为什么-interface-NSObject-60-NSObjct-62\"><a href=\"#为什么-interface-NSObject-60-NSObjct-62\" class=\"headerlink\" title=\"为什么@interface NSObject&#60;NSObjct&#62;\"></a>为什么@interface NSObject&#60;NSObjct&#62;</h2><p>为什么NSObject之后又有&#60;NSObjct&#62;。<br>事实上，NSObject并不是Objctive-C的唯一根类，而作为对象根类的基本行为该有的还是应该有。因此在NSObject之外&#60;NSObjct&#62;又限定了Objective-C根类所必须具有的API。这在一定意义上支持了多个根类（比如NSProxy，自定义根类）的定义。<br><i class=\"fa fa-at\"></i> <a href=\"https://mikeash.com/pyblog/friday-qa-2013-10-25-nsobject-the-class-and-the-protocol.html\">Friday Q&amp;A 2013-10-25: NSObject: the Class and the Protocol</a></p>\n<h2 id=\"为什么self-super-init\"><a href=\"#为什么self-super-init\" class=\"headerlink\" title=\"为什么self = [super init];\"></a>为什么self = [super init];</h2><p><a href=\"https://www.cocoawithlove.com/2009/04/what-does-it-mean-when-you-assign-super.html\">What does it mean when you assign [super init] to self?</a><br><a href=\"http://stackoverflow.com/questions/2956943/why-should-i-call-self-super-init\">Why should I call self=[super init]</a></p>\n<h2 id=\"Load-amp-initialize\"><a href=\"#Load-amp-initialize\" class=\"headerlink\" title=\"+ Load &amp; + initialize\"></a>+ Load &amp; + initialize</h2><p>笔记：<br><i class=\"fa fa-book\"></i> <a href=\"/2015/06/02/iOS/Foundation/NSObject/NSObject_load_initialize/\">学习笔记-Load&amp;Initialize</a></p>\n<p>参考内容：<br><i class=\"fa fa-at\"></i> <a href=\"http://stackoverflow.com/questions/13326435/nsobject-load-and-initialize-what-do-they-do#answer-13326633\">StackOverflow:NSObject-load-and-initialize-what-do-they-do</a><br><i class=\"fa fa-at\"></i> <a href=\"https://mikeash.com/pyblog/friday-qa-2009-05-22-objective-c-class-loading-and-initialization.html\">Friday Q&amp;A 2009-05-22: Objective-C Class Loading and Initialization</a></p>\n<h2 id=\"copy-amp-mutableCopy\"><a href=\"#copy-amp-mutableCopy\" class=\"headerlink\" title=\"copy &amp; mutableCopy\"></a>copy &amp; mutableCopy</h2><p>笔记：<br><i class=\"fa fa-book\"></i> <a href=\"/2015/06/03/iOS/Foundation/NSObject/NSObject_copying/\">学习笔记-Copying</a></p>\n<h2 id=\"Reflection-amp-introspection\"><a href=\"#Reflection-amp-introspection\" class=\"headerlink\" title=\"Reflection &amp; introspection\"></a>Reflection &amp; introspection</h2><blockquote>\n<p>Reflection is the ability of a program to manipulate as data something<br>representing the state of the program during its own execution. There are<br>two aspects of such manipulation :  introspection and  intercession.<br>Introspection is the ability of a program to observe and therefore reason<br>about its own state. Intercession is the ability of a program to modify its<br>own execution state or alter its own interpretation or meaning. Both<br>aspects require a mechanism for encoding execution state as data; providing<br>such an encoding is called  reification.</p>\n</blockquote>\n<p>自省让对象回答关于自己的一切问题。<br>我是谁，我能做什么，我遵守的协议。等等<br>对象通过runtime查询这些消息。<br>在NSObject中关于自省的方法不过是对runtime函数的简单包装。</p>\n<p>笔记：<br><i class=\"fa fa-book\"></i> <a href=\"/2015/07/13/iOS/Foundation/NSObject/NSObject_introspection/\">学习笔记-introspection</a></p>\n","categories":["iOS","Objective-C","Essentials","NSObject"],"tags":["NSObject"]},{"title":"Runtime：Class & Object","url":"/2015/09/15/iOS/Objective-C/runtime/iOS_objc_runtime_class_object/","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>首先，在之前关于runtime的学习中已经提到过：<br>Objective-C即面向对象的C语言，是在C的基础上给C提供了面向对象支持。<br>Objective-C在支持所有C特性的同时，将C语法进行了一个面向对象的包装。<br>比如说提供了面向对象层的数据结构：如Class，Object。<br>另外，C语言的方法调用（method call）也用消息（message sending）来包装。<br>之所以用“包装”这个词，是因为,本质上，Class、Object还是C结构体，消息传递本质还是方法调用。</p>\n<hr>\n<h1 id=\"interface\"><a href=\"#interface\" class=\"headerlink\" title=\"@interface\"></a>@interface</h1><p>Objetive-C的类声明由<code>@interface</code>开始，<code>@end</code>结束。<br>虽然不知道<code>@interface</code>具体如何工作的。<br>但经过之前的一些学习，已经大概了解了编译器会对源文件做出的处理（<a href=\"/2015/09/04/iOS/Objective-C/runtime/iOS_objc_runtime_compiler/\">笔记：关于Compiler</a>）：<br>对于本文的主题——类来说呢，编译器会将<code>@interface</code>，<code>@end</code>中的内容构造成一个C结构体，并将其信息存储在最后生成的Mach-O可执行文件中的<code>_OBJC segment</code>中的<code>__class section</code>中，最后在执行时，由loader载入对应的内存。<br>所以，从本质上来看，如果我说“<code>@interface</code>，<code>@end</code>不过是<code>typedef struct</code>的比较漂亮的写法”，我想，这一观点也并不过分。<br>当然<code>@interface</code>和<code>@end</code>显然还给了编译器一些其他信息，例如，“这是一个类声明，从哪开始的，哪结束的，将它存进<code>_OBJC segment</code>中的<code>__class section</code>中，balabala”，我猜它大概说了这些。</p>\n<span id=\"more\"></span>\n<h1 id=\"class-amp-obejct\"><a href=\"#class-amp-obejct\" class=\"headerlink\" title=\"class &amp; obejct\"></a>class &amp; obejct</h1><p>关于类和对象，从哪个先讲起呢。<br>鉴于一个普遍共识:对象是类的实例——这样一个从属关系来看，可能从class开始介绍比较合理。<br>但，我更想从object着手，遵循自己的脑子关于object和class的思考过程。</p>\n<h2 id=\"object\"><a href=\"#object\" class=\"headerlink\" title=\"object\"></a>object</h2><p>学习Objective-C的最最最开始，就是“Objective-C”这个语言名字本身：<br>Objective-C，面向对象的C，然后，第一堂课就是对象——object，那么，什么是对象。<br>教科书说：对象是类的实例。<br>我们接触到的第一个类就是<code>NSObject</code>,接着,打开runtime中<code>NSObject.h</code>可以看到NSObject是这样定义的：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">interface</span> <span class=\"symbol\">NSObject</span> &lt;<span class=\"symbol\">NSObject</span>&gt; &#123;</span><br><span class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么NSObject类的实例是什么呢：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\">NSObject* <span class=\"keyword\">object</span> = [[NSObject alloc]<span class=\"keyword\">init</span>];</span><br></pre></td></tr></table></figure>\n<p>这个object就是类——NSObject的实例——咱们的对象了。<br>从内存的角度来看，这个对象不过是堆中的一块区域，仅占4个字节（一个包含Class isa指针的C结构体）。<br>现在，另外声明2个类：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">interface</span> <span class=\"symbol\">IntObject</span>:<span class=\"symbol\">NSObject</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@interface</span> <span class=\"attr\">CharObject:</span>NSObject&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> b;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> d;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实例化之后，从内存的角度看，IntObject的对象是堆中的一块区域占8个字节，而CharObject的对象也一模一样占8个字节。2个对象在内存中都仅仅是8个字节的数据而已。<br>那么问题来了：<br><em>问题一</em><br>我们通过对象指针，仅知道对象在哪，但是却对对象的信息一无所知。<br>当处理这个对象的时候，会有很多问题：<br>我们只能如结构体指针一样来访问指向结构中的成员。可以访问i，可以访问到a，b，c，d。<br>但这不够，信息太少。如果在运行过程中，我需要知道i是什么类型呢。<br>另外，对象的属性，方法呢，NSObject对象也仅4个字节，NSObject那么多的方法在哪？<br>还有协议什么的呢？</p>\n<p><em>问题二</em><br>runtime中对象的定义是：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Represents an instance of a class.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_object</span> &#123;</span></span><br><span class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>注意到，注释里说的和教科书里一样，“这代表类的实例”。<br>除此之外，还有个 <code>id</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// A pointer to an instance of a class.</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_object</span> *<span class=\"title\">id</span>;</span></span><br></pre></td></tr></table></figure>\n<p>并介绍了：1个指向类实例的指针。<br>再然后又看到这样一句话：“<code>id</code>可以指向任何对象”。<br>好吧，<code>struct objc_object</code>就是类的实例（对象），且“<code>id</code>可以指向任何对象”。但是它们其实都仅是一个占4字节的其中仅含一个指针的结构体啊。<br>为什么？为什么仅仅1个4个字节的指针就可以代表一个对象，且可以代表任何对象。单从所占内存字节来看，每个不同类的对象仅根据实例变量的不同所占字节都是不一样的，千变万化，然而为什么这个4字节的<code>Class isa</code>就可以代表任何对象了？</p>\n<p>而这2个问题的答案是一样的：</p>\n<p>答案都包罗在唯一已知的那4个字节里：<br>单从对象看，我们确实对对象的信息一无所知，<br>但事实是：按照Objective-C的对象的定义，我们已知且唯一已知的是每个对象前4个字节都是这样一个指针：</p>\n<figure class=\"highlight monkey\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">Class</span> <span class=\"title\">isa</span>  <span class=\"title\">OBJC_ISA_AVAILABILITY</span>;</span></span><br></pre></td></tr></table></figure>\n<p>这个指针指向的就是类——class：class描述对象的所有信息。我有多大，我有哪些属性，我有哪些方法，我的方法的实现是什么，后面的内存字节中那几个字节是什么内容等等的问题的答案都在这里。<br>class的所有对象都有<code>isa</code>来指向class获取关于这些信息，共享这一份类信息。<br>对象是多个的，而说明书只需要一份，class就是这一份说明书，isa就是说明书的位置。</p>\n<p>为什么这样，可以回顾下之前的笔记：<a href=\"/2015/09/04/iOS/Objective-C/runtime/iOS_objc_runtime_explanation/#Still_Why?\">笔记——Runtime：Why runtime?</a></p>\n<h2 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h2><p>class是对象的原型。是其所有实例对象所共享的信息之源。<br><a href=\"http://opensource.apple.com/source/objc4/objc4-647/runtime/objc.h\">/runtime/objc.h</a>中Class的定义为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// An opaque type that represents an Objective-C class.</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_class</span> *<span class=\"title\">Class</span>;</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://opensource.apple.com/source/objc4/objc4-647/runtime/runtime.h.auto.html\">/runtime/runtime.h</a>中objc_class又有如下定义：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_class</span> &#123;</span></span><br><span class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> !__OBJC2__</span></span><br><span class=\"line\">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name                                         OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_ivar_list</span> *<span class=\"title\">ivars</span>                             <span class=\"title\">OBJC2_UNAVAILABLE</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_method_list</span> **<span class=\"title\">methodLists</span>                    <span class=\"title\">OBJC2_UNAVAILABLE</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_cache</span> *<span class=\"title\">cache</span>                                 <span class=\"title\">OBJC2_UNAVAILABLE</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_protocol_list</span> *<span class=\"title\">protocols</span>                     <span class=\"title\">OBJC2_UNAVAILABLE</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125; OBJC2_UNAVAILABLE;</span><br><span class=\"line\"><span class=\"comment\">/* Use `Class` instead of `struct objc_class *` */</span></span><br></pre></td></tr></table></figure>\n<p>这就是class，一个指向objc_class结构体的指针。<br>一目了然，objc_class结构体描述了一个类的所有信息，父类，名称，信息，变量大小，变量列表，方法列表，协议列表等等。<br>可能最有趣的是：objc_class结构体中第一个数据又是指向另一个Class的isa指针。（而这关乎的是另一个话题metaclass）。</p>\n<p>先不管这个isa。<br>总之，这就是类了。<br>[对象]存储在堆里，当我们实例一个对象时，会在堆中开辟空间存储对象。<br>[类]并不是实例时生成的，而是在程序加载时从可执行文件载入到内存中。<br>当在源代码中声明一个类后，编译器将每个类构造成了这样一个结构体<code>struct objc_class </code>,并将其信息存储在最后生成的Mach-O可执行文件中的<code>_OBJC segment</code>中的<code>__class section</code>中。<br>最后在加载阶段将<code>_OBJC segment</code>连同<code>__TEXT segment</code>,<code>__DATA segment</code>等一起载入内存，开始执行。<br><code>_OBJC segment</code>中存储了runtime需要的所有信息，包括class，metaclass，category，method等等。之前有过<a href=\"/2015/09/04/iOS/Objective-C/runtime/iOS_objc_runtime_compiler/#5%EF%BC%9AMach-O_file\">_OBJC segment的笔记。</a></p>\n<p>总之：objc_class里面存储了关于类的一切。而这一切都将用于描述这个类的所有实例object。每一个已声明的类都将构造成这样一个结构存储在<code>_OBJC segment</code>中加载进内存。<br>所以在运行时，runtime其实对每一个object都已了然于胸，遇到不知道的，通过isa指向的<code>_OBJC segment</code>查查就知道了。</p>\n<h3 id=\"isa\"><a href=\"#isa\" class=\"headerlink\" title=\"isa\"></a>isa</h3><p>之前提到了，objc_class结构体中第一个数据又是指向另一个Class的isa指针。关于metaclass的东西在看看吧。<br>*<br>Edited:<br><a href=\"/2015/09/25/iOS/Objective-C/runtime/iOS_objc_runtime_class_metaclass/\">笔记：about metaclass</a><br>*</p>\n<h3 id=\"super-class\"><a href=\"#super-class\" class=\"headerlink\" title=\"super_class\"></a>super_class</h3><p>显然，<code>super_class</code>也是一个指向类结构的指针，&quot;我的父类是什么？&quot;。<br>是关于面向对象的继承链的问题。当我们继承自某类时（比如按常例，我们会继承NSObject类），那么<code>super_class</code>指向父类。<br>如果存在继承，那么对象就需要2份说明书才能阐释清楚，一份是自己的类和一份是父类。<br>在自己的类里找不到的说明，就去父类里找。<br>例如：变量的信息找不到就去super_class继续进行，方法在当前对象上也缺失，那么就追溯到super_class继续进行。<br>根类(如NSObject或NSProxy)的super_class为nil。</p>\n<h3 id=\"ivars\"><a href=\"#ivars\" class=\"headerlink\" title=\"ivars\"></a>ivars</h3><p>对象利用<code>instance_size</code>再配合<code>struct objc_ivar_list</code>对象实例变量链表，这2个信息来揭露关于对象实例变量的一切。</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"code\"><pre><span class=\"line\">long instance_size                                       OBJC2_UNAVAILABLE<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p><code>instance_size</code>存储了关于对象的大小信息，让我们清楚了对象在内存所占据的区域。</p>\n<p>ivars指向<code>struct objc_ivar_list</code>,那么<code>objc_ivar_list</code>是什么：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_ivar_list</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ivar_count                                           OBJC2_UNAVAILABLE;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __LP64__</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"comment\">/* variable length structure */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_ivar</span> <span class=\"title\">ivar_list</span>[1]                            <span class=\"title\">OBJC2_UNAVAILABLE</span>;</span></span><br><span class=\"line\">&#125;            </span><br></pre></td></tr></table></figure>\n<p><code>struct objc_ivar_list</code>这个结构体描述关于class的实例变量的信息：</p>\n<ul>\n<li>有几个实例变量，</li>\n<li>一共占用内存多大</li>\n<li>一个<a href=\"https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html\">可变长的数组</a>，根据实际变量数量再进而描述每一个实例变量的信息：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_ivar</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *ivar_name                                          OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *ivar_type                                          OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ivar_offset                                          OBJC2_UNAVAILABLE;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __LP64__</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125;                                                            OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>\n<p><code>struct objc_ivar</code>描述具体某个实例变量的信息：</p>\n<ul>\n<li>变量名，</li>\n<li>变量类型，</li>\n<li>在类结构体中的地址偏移位置，</li>\n<li>占用空间。</li>\n</ul>\n<p>有了<code>instance_size</code>，又有了总共多少实例变量，再加上每个实例变量的类型，大小和位置。这些信息足以描述对象的所有实例变量，相当于解释了对象在内存中的每一个字节的具体内容。</p>\n<h3 id=\"methodLists\"><a href=\"#methodLists\" class=\"headerlink\" title=\"methodLists\"></a>methodLists</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_method_list</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_method_list</span> *<span class=\"title\">obsolete</span>                        <span class=\"title\">OBJC2_UNAVAILABLE</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> method_count                                         OBJC2_UNAVAILABLE;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __LP64__</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"comment\">/* variable length structure */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_method</span> <span class=\"title\">method_list</span>[1]                        <span class=\"title\">OBJC2_UNAVAILABLE</span>;</span></span><br><span class=\"line\">&#125;                                                            OBJC2_UNAVAILABLE;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>struct objc_method_list</code>结构体存储关于方法的所有信息：</p>\n<ul>\n<li>方法的总数，</li>\n<li>占用空间，</li>\n<li>一个可变长数组存储每一个对象方法<code>objc_method</code>。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// An opaque type that represents a method in a class definition.</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_method</span> *<span class=\"title\">Method</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_method</span> &#123;</span></span><br><span class=\"line\">    SEL method_name                                          OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *method_types                                       OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    IMP method_imp                                           OBJC2_UNAVAILABLE;</span><br><span class=\"line\">&#125;                                                            OBJC2_UNAVAILABLE;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>objc_method结构体描述具体单个方法：</p>\n<ul>\n<li>SEL（方法名），</li>\n<li>method_types，方法的参数类型，返回类型</li>\n<li>IMP（实现——函数指针）。</li>\n</ul>\n<p>当向对象发送消息时，对象实质上对自己的行为和方法也一无所知，对象通过isa找到自己的类信息，在类信息结构中<code>objc_method_list</code>存储了类的实例方法列表。对象在这里匹配对应的方法名和实现，再进行函数调用。</p>\n<h3 id=\"cache\"><a href=\"#cache\" class=\"headerlink\" title=\"cache\"></a>cache</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_cache</span> *<span class=\"title\">Cache</span>                             <span class=\"title\">OBJC2_UNAVAILABLE</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_cache</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> mask <span class=\"comment\">/* total = mask + 1 */</span>                 OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> occupied                                    OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    Method buckets[<span class=\"number\">1</span>]                                        OBJC2_UNAVAILABLE;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>将原本直接的函数调用(method call)包装为消息传递（send message）后函数调用的简单方式演变为先SEL查找对应IMP，再调用IMP的过程。当方法列表庞大时，SEL和IMP的查找对应显然会成为一个耗时的工序。objc_cache正是消息传递机制中的一个优化环节。当第一次发送消息时，runtime将查找结果Method放入objc_cache的篮子（buckets）中，以加快之后该消息工作的速度。</p>\n<h3 id=\"protocols\"><a href=\"#protocols\" class=\"headerlink\" title=\"protocols\"></a>protocols</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_protocol_list</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_protocol_list</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> count;</span><br><span class=\"line\">    Protocol *<span class=\"built_in\">list</span>[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_object</span> <span class=\"title\">Protocol</span>;</span></span><br></pre></td></tr></table></figure>\n<p>从这个定义看，似乎protocol就是一个对象啊。<br>确实是:<br><a href=\"http://opensource.apple.com/source/objc4/objc4-647/runtime/Protocol.h\">/runtime/Protocol.h</a>中有如下定义：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">@interface Protocol : Object</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">@<span class=\"keyword\">private</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *protocol_name OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_protocol_list</span> *<span class=\"title\">protocol_list</span> <span class=\"title\">OBJC2_UNAVAILABLE</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_method_description_list</span> *<span class=\"title\">instance_methods</span> <span class=\"title\">OBJC2_UNAVAILABLE</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_method_description_list</span> *<span class=\"title\">class_methods</span> <span class=\"title\">OBJC2_UNAVAILABLE</span>;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://opensource.apple.com/source/objc4/objc4-647/runtime/runtime.h.auto.html\">/runtime/runtime.h</a>也有：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __OBJC__</span></span><br><span class=\"line\">@<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Protocol</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_object</span> <span class=\"title\">Protocol</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>这也正是协议可以继承的原因，因为其本质就是对象，存储了：</p>\n<ul>\n<li>协议名，</li>\n<li>继承的协议链表，</li>\n<li>实例方法信息链表，</li>\n<li>类方法信息链表</li>\n</ul>\n<p>这意味着，每一个协议后面都有一个class描述协议的信息，不过这个class中只有协议的方法信息，没有方法实现信息。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_method_description_list</span> &#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> count;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_method_description</span> <span class=\"title\">list</span>[1];</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>而方法描述也只是提供方法名和参数类型：</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Defines a method</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"type\">objc_method_description</span> &#123;</span><br><span class=\"line\">  SEL name;               <span class=\"comment\">/**&lt; The name of the method */</span></span><br><span class=\"line\">  char *types;            <span class=\"comment\">/**&lt; The types of the method arguments */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>由此可见，方法的具体实现必须由遵循协议的类给出。</p>\n<h1 id=\"End\"><a href=\"#End\" class=\"headerlink\" title=\"End\"></a>End</h1><p>Objective-C是面向对象的语言，Objective-C的每一个对象(Object)都是一个类(Class)的实例，Class描述了对象的数据结构和行为。<br>当使用一个类实例化一个对象时，对象的isa就指向它的类。<br>为什么需要有个isa指向它的类？<br>对象(Object)在内存中占据一定空间保存自己的实例变量，但却没有自己的方法列表和自己的实例变量信息。<br>类(Class)的方法和关于类的实例变量信息是其所有对象(Object)公用的。<br>当我们向一个类的实例对象发送消息时，消息绑定机制将（利用isa）追溯到实例对象(Instance Object)的类(Class)去寻找方法。<br>当我们使用对象的实例变量时，也是isa指向的类揭示关于实例变量的类型和大小等信息。</p>\n<blockquote>\n<p>The compiler creates just one object, a class object, to represent the class. The class object has access to all the information about the class, which means mainly information about what instances of the class are like. It&#39;s able to produce new instances according to the plan put forward in the class definition.</p>\n</blockquote>\n<p>一言以蔽之：<br><em>对象持有数据（实例变量），类持有行为（方法）和数据的相关描述。</em></p>\n","categories":["iOS","Objective-C","Runtime"],"tags":["object","runtime","class"]},{"title":"Runtime：Before lauch，关于Compiler time","url":"/2015/09/10/iOS/Objective-C/runtime/iOS_objc_runtime_compiler/","content":"<h1 id=\"About\"><a href=\"#About\" class=\"headerlink\" title=\"About\"></a>About</h1><p>从源文件到可执行程序。代码都经历了些什么?<br>使用编译器Clang来一步一步地参考一下。<br>使用以下命令查看编译器对源文件进行处理的步骤：<br><code>clang -ccc-print-phases main.m</code></p>\n<figure class=\"highlight objectivec\"><figcaption><span>clang user$ clang -ccc-print-phases main.m 输出结果</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span>: input, <span class=\"string\">&quot;main.m&quot;</span>, objective-c</span><br><span class=\"line\"><span class=\"number\">1</span>: preprocessor, &#123;<span class=\"number\">0</span>&#125;, objective-c-cpp-output</span><br><span class=\"line\"><span class=\"number\">2</span>: compiler, &#123;<span class=\"number\">1</span>&#125;, assembler</span><br><span class=\"line\"><span class=\"number\">3</span>: assembler, &#123;<span class=\"number\">2</span>&#125;, object</span><br><span class=\"line\"><span class=\"number\">4</span>: linker, &#123;<span class=\"number\">3</span>&#125;, image</span><br><span class=\"line\"><span class=\"number\">5</span>: bind-arch, <span class=\"string\">&quot;x86_64&quot;</span>, &#123;<span class=\"number\">4</span>&#125;, image</span><br></pre></td></tr></table></figure>\n\n\n<span id=\"more\"></span>\n<p>笔记：<br>待处理的文件是main.m，包含一个简单的类，分类，协议。类有实例变量，一个类方法，一个实例方法。总之就是尽可能多而又简单的包含oc语言的特性。</p>\n<figure class=\"highlight objectivec\"><figcaption><span>Main.m</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  main.m</span></span><br><span class=\"line\"><span class=\"comment\">//  Clang</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">//宏定义</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MULT(x) (x) * (x)</span></span><br><span class=\"line\"><span class=\"comment\">//Category</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSObject</span>(<span class=\"title\">MyObject</span>)</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)sayHello;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSObject</span>(<span class=\"title\">MyObject</span>)</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)sayHello&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;hello world&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"comment\">//Protocol</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">sayAgain</span> &lt;<span class=\"title\">NSObject</span>&gt;</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)sayHelloAgain;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"comment\">//Interface</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">People</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\">&lt;sayAgain&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)hello;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)hello;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">People</span></span></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)hello&#123;</span><br><span class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;class method&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)hello&#123;</span><br><span class=\"line\">    sum = MULT(<span class=\"number\">10</span>);</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> sayHello];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;sum = %d&quot;</span>,sum);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)sayHelloAgain&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> hello];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// insert code here...</span></span><br><span class=\"line\">        <span class=\"keyword\">id</span>  jackson = [[People alloc]init];</span><br><span class=\"line\">        [People hello];</span><br><span class=\"line\">        [jackson hello];</span><br><span class=\"line\">        [jackson sayHelloAgain];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"1-preprocessor-预处理\"><a href=\"#1-preprocessor-预处理\" class=\"headerlink\" title=\"1:preprocessor 预处理\"></a>1:preprocessor 预处理</h1><p>编译器的第一个阶段是预处理。<br>调用工具是预处理器。<br>跟预处理器打交道的是<a href=\"https://gcc.gnu.org/onlinedocs/cpp/\">预处理语言</a>，预处理器的主要工作是根据预处理指令进行代码替换以及宏展开。<br>查看预处理器的输出结果可以使用命令行：<br><code>clang -E main.m</code><br>也可以Xcode：Product/Perform Action/Preprocess main.m<br>可以看到输出文件中</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>已经替换为Foundation.h文件中的代码。<br>另外</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MULT(x) (x) * (x)</span></span><br><span class=\"line\">sum = MULT(<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n\n<p>也经过宏展开，成为</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">sum = (<span class=\"number\">10</span>) * (<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n<p>同时，文件中注释和多余空行也经过优化或者删除。准备好了进入下一步。</p>\n<h1 id=\"2-compiler-编译\"><a href=\"#2-compiler-编译\" class=\"headerlink\" title=\"2:compiler 编译\"></a>2:compiler 编译</h1><p>这个阶段编译器输入预处理后的文件，进行词法，语法，语义分析以配合类型检查，代码优化等工作，最后输出为中间代码，如汇编代码。</p>\n<h2 id=\"词法分析（Lexcical-Analysis）\"><a href=\"#词法分析（Lexcical-Analysis）\" class=\"headerlink\" title=\"词法分析（Lexcical Analysis）\"></a>词法分析（Lexcical Analysis）</h2><p>编译器将源文件中的定义，声明，关键字等分解成一个个标示符，完成初步分解。<br>使用编译器命令：<br><code>clang -Xclang -dump-tokens main.m</code></p>\n<p>如：上文示例程序中的：</p>\n<figure class=\"highlight objectivec\"><figcaption><span>源文件</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">interface <span class=\"built_in\">NSObject</span>(MyObject)</span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)sayHello;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>被解析为：</p>\n<figure class=\"highlight bash\"><figcaption><span>词法分析后</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">at <span class=\"string\">&#x27;@&#x27;</span>\t                [StartOfLine]\tLoc=&lt;main.m:15:1&gt;</span><br><span class=\"line\">identifier <span class=\"string\">&#x27;interface&#x27;</span>\t\t\tLoc=&lt;main.m:15:2&gt;</span><br><span class=\"line\">identifier <span class=\"string\">&#x27;NSObject&#x27;</span>\t[LeadingSpace]\tLoc=&lt;main.m:15:12&gt;</span><br><span class=\"line\">l_paren <span class=\"string\">&#x27;(&#x27;</span>\t\t\t\tLoc=&lt;main.m:15:20&gt;</span><br><span class=\"line\">identifier <span class=\"string\">&#x27;MyObject&#x27;</span>\t\t\tLoc=&lt;main.m:15:21&gt;</span><br><span class=\"line\">r_paren <span class=\"string\">&#x27;)&#x27;</span>\t\t\t\tLoc=&lt;main.m:15:29&gt;</span><br><span class=\"line\">minus <span class=\"string\">&#x27;-&#x27;</span>\t \t[StartOfLine]\tLoc=&lt;main.m:17:1&gt;</span><br><span class=\"line\">l_paren <span class=\"string\">&#x27;(&#x27;</span>\t \t[LeadingSpace]\tLoc=&lt;main.m:17:3&gt;</span><br><span class=\"line\">void <span class=\"string\">&#x27;void&#x27;</span>\t\t\t\tLoc=&lt;main.m:17:4&gt;</span><br><span class=\"line\">r_paren <span class=\"string\">&#x27;)&#x27;</span>\t\t\t\tLoc=&lt;main.m:17:8&gt;</span><br><span class=\"line\">identifier <span class=\"string\">&#x27;sayHello&#x27;</span>\t\t\tLoc=&lt;main.m:17:9&gt;</span><br><span class=\"line\">semi <span class=\"string\">&#x27;;&#x27;</span>\t\t\t\tLoc=&lt;main.m:17:17&gt;</span><br></pre></td></tr></table></figure>\n<p>可以看到，编译器记录了每个标示符所在的文件名，标示符在文件中所处的行数，位置等。当代码分析出错后，编译器可以通过这些信息尽可能地定位错误位置。</p>\n<h2 id=\"语法分析（Syntax-Analysis）\"><a href=\"#语法分析（Syntax-Analysis）\" class=\"headerlink\" title=\"语法分析（Syntax Analysis）\"></a>语法分析（Syntax Analysis）</h2><p>语法分析阶段，编译器将根据词法分析器的输出结果，调用语法分析器生成树形的中间表示结构抽象语法树AST（Abstract Syntax Tree)。AST给出了源代码的语法结构，对之后的处理提供一个比较清晰的接口。AST是对语言语法的一个很好的阐释，比如一个算数表达式被构造成AST后，不同的遍历顺序，将直接代表表达式在原程序语言是以什么方式编写。前缀，中缀还是后缀，并不是复杂的语法语义，仅仅是对应不同的树遍历算法而已。<br>编译器的后续步骤将根据AST来分析和优化代码。<br><code>clang -Xclang -ast-dump main.m</code><br>输出</p>\n<figure class=\"highlight java\"><figcaption><span>AST</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">| <span class=\"comment\">//Category(MyObject)</span></span><br><span class=\"line\">|-ObjCCategoryDecl <span class=\"number\">0x106c1e0c0</span> &lt;main.m:<span class=\"number\">15</span>:<span class=\"number\">1</span>, line:<span class=\"number\">19</span>:<span class=\"number\">2</span>&gt; line:<span class=\"number\">15</span>:<span class=\"number\">12</span> MyObject</span><br><span class=\"line\">| |-ObjCInterface <span class=\"number\">0x1049e7fb0</span> <span class=\"string\">&#x27;NSObject&#x27;</span></span><br><span class=\"line\">| |-ObjCCategoryImpl <span class=\"number\">0x106c1e1f0</span> <span class=\"string\">&#x27;NSObject&#x27;</span></span><br><span class=\"line\">| `-ObjCMethodDecl <span class=\"number\">0x106c1e160</span> &lt;line:<span class=\"number\">17</span>:<span class=\"number\">1</span>, col:<span class=\"number\">17</span>&gt; col:<span class=\"number\">1</span> - sayHello <span class=\"string\">&#x27;void&#x27;</span></span><br><span class=\"line\">|-ObjCCategoryImplDecl <span class=\"number\">0x106c1e1f0</span> &lt;line:<span class=\"number\">21</span>:<span class=\"number\">1</span>, line:<span class=\"number\">27</span>:<span class=\"number\">1</span>&gt; line:<span class=\"number\">21</span>:<span class=\"number\">17</span> NSObject</span><br><span class=\"line\">| |-ObjCInterface <span class=\"number\">0x1049e7fb0</span> <span class=\"string\">&#x27;NSObject&#x27;</span></span><br><span class=\"line\">| |-ObjCCategory <span class=\"number\">0x106c1e0c0</span> <span class=\"string\">&#x27;MyObject&#x27;</span></span><br><span class=\"line\">| `-ObjCMethodDecl <span class=\"number\">0x106c1e270</span> &lt;line:<span class=\"number\">23</span>:<span class=\"number\">1</span>, line:<span class=\"number\">25</span>:<span class=\"number\">1</span>&gt; line:<span class=\"number\">23</span>:<span class=\"number\">1</span> - sayHello <span class=\"string\">&#x27;void&#x27;</span></span><br><span class=\"line\">|   |-ImplicitParamDecl <span class=\"number\">0x106c1e300</span> &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit self <span class=\"string\">&#x27;NSObject *&#x27;</span></span><br><span class=\"line\">|   |-ImplicitParamDecl <span class=\"number\">0x106c1e360</span> &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit _cmd <span class=\"string\">&#x27;SEL&#x27;</span>:<span class=\"string\">&#x27;SEL *&#x27;</span></span><br><span class=\"line\">|   `-CompoundStmt <span class=\"number\">0x106c1e4f8</span> &lt;col:<span class=\"number\">17</span>, line:<span class=\"number\">25</span>:<span class=\"number\">1</span>&gt;</span><br><span class=\"line\">|     `-CallExpr <span class=\"number\">0x106c1e4b0</span> &lt;line:<span class=\"number\">24</span>:<span class=\"number\">5</span>, col:<span class=\"number\">25</span>&gt; <span class=\"string\">&#x27;void&#x27;</span></span><br><span class=\"line\">|       |-ImplicitCastExpr <span class=\"number\">0x106c1e498</span> &lt;col:<span class=\"number\">5</span>&gt; <span class=\"string\">&#x27;void (*)(id, ...)&#x27;</span> &lt;FunctionToPointerDecay&gt;</span><br><span class=\"line\">|       | `-DeclRefExpr <span class=\"number\">0x106c1e3b8</span> &lt;col:<span class=\"number\">5</span>&gt; <span class=\"string\">&#x27;void (id, ...)&#x27;</span> Function <span class=\"number\">0x104af8010</span> <span class=\"string\">&#x27;NSLog&#x27;</span> <span class=\"string\">&#x27;void (id, ...)&#x27;</span></span><br><span class=\"line\">|       `-ImplicitCastExpr <span class=\"number\">0x106c1e4e0</span> &lt;col:<span class=\"number\">11</span>, col:<span class=\"number\">12</span>&gt; <span class=\"string\">&#x27;id&#x27;</span>:<span class=\"string\">&#x27;id&#x27;</span> &lt;BitCast&gt;</span><br><span class=\"line\">|         `-ObjCStringLiteral <span class=\"number\">0x106c1e418</span> &lt;col:<span class=\"number\">11</span>, col:<span class=\"number\">12</span>&gt; <span class=\"string\">&#x27;NSString *&#x27;</span></span><br><span class=\"line\">|           `-StringLiteral <span class=\"number\">0x106c1e3e0</span> &lt;col:<span class=\"number\">12</span>&gt; <span class=\"string\">&#x27;char [12]&#x27;</span> lvalue <span class=\"string\">&quot;hello world&quot;</span></span><br><span class=\"line\">略。。</span><br><span class=\"line\"><span class=\"comment\">//main</span></span><br><span class=\"line\">  |-FunctionDecl <span class=\"number\">0x106c1f4d0</span> &lt;line:<span class=\"number\">58</span>:<span class=\"number\">1</span>, line:<span class=\"number\">67</span>:<span class=\"number\">1</span>&gt; line:<span class=\"number\">58</span>:<span class=\"number\">5</span> main <span class=\"string\">&#x27;int (int, const char **)&#x27;</span></span><br><span class=\"line\">  |-ParmVarDecl <span class=\"number\">0x106c1f310</span> &lt;col:<span class=\"number\">10</span>, col:<span class=\"number\">14</span>&gt; col:<span class=\"number\">14</span> argc <span class=\"string\">&#x27;int&#x27;</span></span><br><span class=\"line\">  |-ParmVarDecl <span class=\"number\">0x106c1f3c0</span> &lt;col:<span class=\"number\">20</span>, col:<span class=\"number\">38</span>&gt; col:<span class=\"number\">33</span> argv <span class=\"string\">&#x27;const char **&#x27;</span>:<span class=\"string\">&#x27;const char **&#x27;</span></span><br><span class=\"line\">   -CompoundStmt <span class=\"number\">0x106c1f838</span> &lt;col:<span class=\"number\">41</span>, line:<span class=\"number\">67</span>:<span class=\"number\">1</span>&gt;</span><br><span class=\"line\">    |-ObjCAutoreleasePoolStmt <span class=\"number\">0x106c1f7e0</span> &lt;line:<span class=\"number\">59</span>:<span class=\"number\">5</span>, line:<span class=\"number\">65</span>:<span class=\"number\">5</span>&gt;</span><br><span class=\"line\">    | `-CompoundStmt <span class=\"number\">0x106c1f7a8</span> &lt;line:<span class=\"number\">59</span>:<span class=\"number\">22</span>, line:<span class=\"number\">65</span>:<span class=\"number\">5</span>&gt;</span><br><span class=\"line\">    |   |-DeclStmt <span class=\"number\">0x106c1f670</span> &lt;line:<span class=\"number\">61</span>:<span class=\"number\">9</span>, col:<span class=\"number\">43</span>&gt;</span><br><span class=\"line\">    |   | `-VarDecl <span class=\"number\">0x106c1f590</span> &lt;col:<span class=\"number\">9</span>, col:<span class=\"number\">42</span>&gt; col:<span class=\"number\">13</span> used jackson <span class=\"string\">&#x27;id&#x27;</span>:<span class=\"string\">&#x27;id&#x27;</span> cinit</span><br><span class=\"line\">    |   |   `-ImplicitCastExpr <span class=\"number\">0x106c1f658</span> &lt;col:<span class=\"number\">23</span>, col:<span class=\"number\">42</span>&gt; <span class=\"string\">&#x27;id&#x27;</span>:<span class=\"string\">&#x27;id&#x27;</span> &lt;BitCast&gt;</span><br><span class=\"line\">    |   |     `-ObjCMessageExpr <span class=\"number\">0x106c1f628</span> &lt;col:<span class=\"number\">23</span>, col:<span class=\"number\">42</span>&gt; <span class=\"string\">&#x27;People *&#x27;</span> selector=init</span><br><span class=\"line\">    |   |       `-ObjCMessageExpr <span class=\"number\">0x106c1f5f8</span> &lt;col:<span class=\"number\">24</span>, col:<span class=\"number\">37</span>&gt; <span class=\"string\">&#x27;People *&#x27;</span> selector=alloc <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&#x27;People&#x27;</span></span><br><span class=\"line\">    |   |-ObjCMessageExpr <span class=\"number\">0x106c1f698</span> &lt;line:<span class=\"number\">62</span>:<span class=\"number\">9</span>, col:<span class=\"number\">22</span>&gt; <span class=\"string\">&#x27;void&#x27;</span> selector=hello <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&#x27;People&#x27;</span></span><br><span class=\"line\">    |   |-ObjCMessageExpr <span class=\"number\">0x106c1f708</span> &lt;line:<span class=\"number\">63</span>:<span class=\"number\">9</span>, col:<span class=\"number\">23</span>&gt; <span class=\"string\">&#x27;void&#x27;</span> selector=hello</span><br><span class=\"line\">    |   | `-ImplicitCastExpr <span class=\"number\">0x106c1f6f0</span> &lt;col:<span class=\"number\">10</span>&gt; <span class=\"string\">&#x27;id&#x27;</span>:<span class=\"string\">&#x27;id&#x27;</span> &lt;LValueToRValue&gt;</span><br><span class=\"line\">    |   |   `-DeclRefExpr <span class=\"number\">0x106c1f6c8</span> &lt;col:<span class=\"number\">10</span>&gt; <span class=\"string\">&#x27;id&#x27;</span>:<span class=\"string\">&#x27;id&#x27;</span> lvalue Var <span class=\"number\">0x106c1f590</span> <span class=\"string\">&#x27;jackson&#x27;</span> <span class=\"string\">&#x27;id&#x27;</span>:<span class=\"string\">&#x27;id&#x27;</span></span><br><span class=\"line\">    |   `-ObjCMessageExpr <span class=\"number\">0x106c1f778</span> &lt;line:<span class=\"number\">64</span>:<span class=\"number\">9</span>, col:<span class=\"number\">31</span>&gt; <span class=\"string\">&#x27;void&#x27;</span> selector=sayHelloAgain</span><br><span class=\"line\">    |     `-ImplicitCastExpr <span class=\"number\">0x106c1f760</span> &lt;col:<span class=\"number\">10</span>&gt; <span class=\"string\">&#x27;id&#x27;</span>:<span class=\"string\">&#x27;id&#x27;</span> &lt;LValueToRValue&gt;</span><br><span class=\"line\">    |       `-DeclRefExpr <span class=\"number\">0x106c1f738</span> &lt;col:<span class=\"number\">10</span>&gt; <span class=\"string\">&#x27;id&#x27;</span>:<span class=\"string\">&#x27;id&#x27;</span> lvalue Var <span class=\"number\">0x106c1f590</span> <span class=\"string\">&#x27;jackson&#x27;</span> <span class=\"string\">&#x27;id&#x27;</span>:<span class=\"string\">&#x27;id&#x27;</span></span><br><span class=\"line\">    `-ReturnStmt <span class=\"number\">0x106c1f818</span> &lt;line:<span class=\"number\">66</span>:<span class=\"number\">5</span>, col:<span class=\"number\">12</span>&gt;</span><br><span class=\"line\">      `-IntegerLiteral <span class=\"number\">0x106c1f7f8</span> &lt;col:<span class=\"number\">12</span>&gt; <span class=\"string\">&#x27;int&#x27;</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p>根据输出的AST结构，可以看出编译器在构建AST时已经对代码进行了一定的优化和改写。<br>比如：添加了隐式的强制转换，Objective-C的<code>@&quot;hello world&quot;</code>字符串字面量也转变为了``-StringLiteral 0x106c1e3e0 <a href=\"col:12\">col:12</a> &#39;char [12]&#39; lvalue &quot;hello world&quot;`.等等。</p>\n<p>根据AST，编译器掌握了代码的语法结构和信息，将以此为基础作语义分析。</p>\n<h2 id=\"语义分析（Semantic-Analysis），运行时支持\"><a href=\"#语义分析（Semantic-Analysis），运行时支持\" class=\"headerlink\" title=\"语义分析（Semantic Analysis），运行时支持\"></a>语义分析（Semantic Analysis），运行时支持</h2><p>语义分析的处理对象依然是AST。<br>语义分析根据AST和符号表来分析源代码与程序语言定义的语义是否一致。<br>包括：语法检查，静态分析，类型检查等，与此同时也进行代码改写与代码优化。<br>命令：<br><code>clang -fsyntax-only</code><br><code>clang -analyze</code><br>可查看相应分析的结果。</p>\n<p>节选对比一下原示例代码中的类声明部分，观察一下AST：</p>\n<figure class=\"highlight objectivec\"><figcaption><span>原示例中的类别</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSObject</span>(<span class=\"title\">MyObject</span>)</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)sayHello;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSObject</span>(<span class=\"title\">MyObject</span>)</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)sayHello&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;hello world&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight x86asm\"><figcaption><span>AST输出</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">|-ObjCCategoryDecl <span class=\"number\">0x106c1e0c0</span> &lt;main<span class=\"number\">.</span>m:<span class=\"number\">15</span>:<span class=\"number\">1</span>, line:<span class=\"number\">19</span>:<span class=\"number\">2</span>&gt; line:<span class=\"number\">15</span>:<span class=\"number\">12</span> MyObject</span><br><span class=\"line\">| |-ObjCInterface <span class=\"number\">0x1049e7fb0</span> <span class=\"string\">&#x27;NSObject&#x27;</span></span><br><span class=\"line\">| |-ObjCCategoryImpl <span class=\"number\">0x106c1e1f0</span> <span class=\"string\">&#x27;NSObject&#x27;</span></span><br><span class=\"line\">| <span class=\"string\">`-ObjCMethodDecl 0x106c1e160 &lt;line:17:1, col:17&gt; col:1 - sayHello &#x27;void&#x27;</span></span><br><span class=\"line\"><span class=\"string\">|-ObjCCategoryImplDecl 0x106c1e1f0 &lt;line:21:1, line:27:1&gt; line:21:17 NSObject</span></span><br><span class=\"line\"><span class=\"string\">| |-ObjCInterface 0x1049e7fb0 &#x27;NSObject&#x27;</span></span><br><span class=\"line\"><span class=\"string\">| |-ObjCCategory 0x106c1e0c0 &#x27;MyObject&#x27;</span></span><br><span class=\"line\"><span class=\"string\">| `</span>-ObjCMethodDecl <span class=\"number\">0x106c1e270</span> &lt;line:<span class=\"number\">23</span>:<span class=\"number\">1</span>, line:<span class=\"number\">25</span>:<span class=\"number\">1</span>&gt; line:<span class=\"number\">23</span>:<span class=\"number\">1</span> - sayHello <span class=\"string\">&#x27;void&#x27;</span></span><br><span class=\"line\">|   |-ImplicitParamDecl <span class=\"number\">0x106c1e300</span> &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit self <span class=\"string\">&#x27;NSObject *&#x27;</span></span><br><span class=\"line\">|   |-ImplicitParamDecl <span class=\"number\">0x106c1e360</span> &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit _cmd <span class=\"string\">&#x27;SEL&#x27;</span>:<span class=\"string\">&#x27;SEL *&#x27;</span></span><br><span class=\"line\">|   <span class=\"string\">`-CompoundStmt 0x106c1e4f8 &lt;col:17, line:25:1&gt;</span></span><br><span class=\"line\"><span class=\"string\">|     `</span>-CallExpr <span class=\"number\">0x106c1e4b0</span> &lt;line:<span class=\"number\">24</span>:<span class=\"number\">5</span>, col:<span class=\"number\">25</span>&gt; <span class=\"string\">&#x27;void&#x27;</span></span><br><span class=\"line\">|       |-ImplicitCastExpr <span class=\"number\">0x106c1e498</span> &lt;col:<span class=\"number\">5</span>&gt; <span class=\"string\">&#x27;void (*)(id, ...)&#x27;</span> &lt;FunctionToPointerDecay&gt;</span><br><span class=\"line\">|       | <span class=\"string\">`-DeclRefExpr 0x106c1e3b8 &lt;col:5&gt; &#x27;void (id, ...)&#x27; Function 0x104af8010 &#x27;NSLog&#x27; &#x27;void (id, ...)&#x27;</span></span><br><span class=\"line\"><span class=\"string\">|       `</span>-ImplicitCastExpr <span class=\"number\">0x106c1e4e0</span> &lt;col:<span class=\"number\">11</span>, col:<span class=\"number\">12</span>&gt; <span class=\"string\">&#x27;id&#x27;</span>:<span class=\"string\">&#x27;id&#x27;</span> &lt;BitCast&gt;</span><br><span class=\"line\">|         <span class=\"string\">`-ObjCStringLiteral 0x106c1e418 &lt;col:11, col:12&gt; &#x27;NSString *&#x27;</span></span><br><span class=\"line\"><span class=\"string\">|           `</span>-StringLiteral <span class=\"number\">0x106c1e3e0</span> &lt;col:<span class=\"number\">12</span>&gt; <span class=\"string\">&#x27;char [12]&#x27;</span> lvalue <span class=\"string\">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>其中line8,9,10</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"code\"><pre><span class=\"line\">| `-ObjCMethodDecl <span class=\"number\">0</span>x106c1e270 &lt;line:<span class=\"number\">23</span>:<span class=\"number\">1</span>, line:<span class=\"number\">25</span>:<span class=\"number\">1</span>&gt; line:<span class=\"number\">23</span>:<span class=\"number\">1</span> - sayHello <span class=\"string\">&#x27;void&#x27;</span></span><br><span class=\"line\">|   |-ImplicitParamDecl <span class=\"number\">0</span>x106c1e300 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; <span class=\"keyword\">implicit</span> self <span class=\"string\">&#x27;NSObject *&#x27;</span></span><br><span class=\"line\">|   |-ImplicitParamDecl <span class=\"number\">0</span>x106c1e360 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; <span class=\"keyword\">implicit</span> _cmd <span class=\"string\">&#x27;SEL&#x27;</span>:<span class=\"string\">&#x27;SEL *&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>根据该AST-方法声明节点<code>-ObjCMethodDecl</code>可看出编译器为类别中的方法：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)sayHello&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;hello world&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>添加了2个隐藏参数<code>ImplicitParamDecl</code>:</p>\n<ol>\n<li><code>implicit self &#39;NSObject</code></li>\n<li><code>implicit _cmd &#39;SEL&#39;:&#39;SEL *&#39;</code></li>\n</ol>\n<p>这就是Objective-C运行时系统中消息发送函数的2个隐藏参数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">id <span class=\"title\">objc_msgSend</span><span class=\"params\">(id self,SEL _cmd,...)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>self 当前消息的接收者</li>\n<li>_cmd 当前消息的selector</li>\n</ol>\n<p>在这个阶段Objective-C的消息已全部转换为了C的函数，并全部添加了<code>self</code>和<code>_cmd</code>2个隐藏参数，这只是在我们这个测试代码中显而易见就可以观察到的部分，其他Objective-C代码的改写和运行时支持当然也都在发生。<br>可以查看改写后的C代码，进行一定的参考：<br><code>clang -rewrite-objc</code> 改写为C代码：<br>粗略翻看一下，有不少眼熟的东西（示例程序改写的C代码全文可参见：<a href=\"/rawcode/main_cpp.html\" target=\"_blank\">CPP代码</a>）<br>对比一下就比较清晰了。</p>\n<ol>\n<li>Objective-C 示例程序<a href=\"#more\">源代码</a></li>\n<li>改写的C代码：</li>\n</ol>\n<figure class=\"highlight cpp\"><figcaption><span>Rewrite</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">prop_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *attributes;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">protocol_t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">objc_method</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_selector</span> * _<span class=\"title\">cmd</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *method_type;</span><br><span class=\"line\">    <span class=\"keyword\">void</span>  *_imp;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">protocol_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> * isa;  <span class=\"comment\">// NULL</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *protocol_name;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">protocol_list_t</span> * <span class=\"title\">protocol_list</span>;</span> <span class=\"comment\">// super protocols</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">method_list_t</span> *<span class=\"title\">instance_methods</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">method_list_t</span> *<span class=\"title\">class_methods</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">method_list_t</span> *<span class=\"title\">optionalInstanceMethods</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">method_list_t</span> *<span class=\"title\">optionalClassMethods</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">prop_list_t</span> * <span class=\"title\">properties</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> size;  <span class=\"comment\">// sizeof(struct _protocol_t)</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> flags;  <span class=\"comment\">// = 0</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> ** extendedMethodTypes;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">ivar_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> *offset;  <span class=\"comment\">// pointer to ivar offset location</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *type;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> alignment;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>  size;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">class_ro_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> flags;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> instanceStart;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> instanceSize;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> reserved;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *ivarLayout;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">method_list_t</span> *<span class=\"title\">baseMethods</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">objc_protocol_list</span> *<span class=\"title\">baseProtocols</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">ivar_list_t</span> *<span class=\"title\">ivars</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *weakIvarLayout;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">prop_list_t</span> *<span class=\"title\">properties</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">class_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">class_t</span> *<span class=\"title\">isa</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">class_t</span> *<span class=\"title\">superclass</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *cache;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *vtable;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">class_ro_t</span> *<span class=\"title\">ro</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">category_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">class_t</span> *<span class=\"title\">cls</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">method_list_t</span> *<span class=\"title\">instance_methods</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">method_list_t</span> *<span class=\"title\">class_methods</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">protocol_list_t</span> *<span class=\"title\">protocols</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">prop_list_t</span> *<span class=\"title\">properties</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以比较清晰地看到接口，类别，协议，方法等都根据runtime library改写为了C的结构体数据结构。<br>除了数据结构以外，上文中的消息传递也改写为了:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">id <span class=\"title\">objc_msgSend</span><span class=\"params\">(id self,SEL _cmd,...)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>消息传递变成方法调用，这也是编译器提供运行时支持比较典型的例子。<br>节选main函数的代码部分来仔细看一下：</p>\n<figure class=\"highlight cpp\"><figcaption><span>C</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class=\"line\"></span><br><span class=\"line\">    id jackson = ((People *(*)(id, SEL))(<span class=\"keyword\">void</span> *)objc_msgSend)((id)((People *(*)(id, SEL))(<span class=\"keyword\">void</span> *)objc_msgSend)((id)objc_getClass(<span class=\"string\">&quot;People&quot;</span>), sel_registerName(<span class=\"string\">&quot;alloc&quot;</span>)), sel_registerName(<span class=\"string\">&quot;init&quot;</span>));</span><br><span class=\"line\">    ((<span class=\"keyword\">void</span>(*)(id, SEL))(<span class=\"keyword\">void</span> *)objc_msgSend)((id)objc_getClass(<span class=\"string\">&quot;People&quot;</span>), sel_registerName(<span class=\"string\">&quot;hello&quot;</span>));</span><br><span class=\"line\">    ((<span class=\"keyword\">void</span>(*)(id, SEL))(<span class=\"keyword\">void</span> *)objc_msgSend)((id)jackson, sel_registerName(<span class=\"string\">&quot;hello&quot;</span>));</span><br><span class=\"line\">    ((<span class=\"keyword\">void</span>(*)(id, SEL))(<span class=\"keyword\">void</span> *)objc_msgSend)((id)jackson, sel_registerName(<span class=\"string\">&quot;sayHelloAgain&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight hy\"><table><tr><td class=\"code\"><pre><span class=\"line\">((<span class=\"name\">void</span>(<span class=\"name\"><span class=\"builtin-name\">*</span></span>)(<span class=\"name\"><span class=\"builtin-name\">id</span></span>, SEL))(<span class=\"name\">void</span> *)objc_msgSend)((<span class=\"name\"><span class=\"builtin-name\">id</span></span>)objc_getClass(<span class=\"string\">&quot;People&quot;</span>), sel_registerName(<span class=\"string\">&quot;hello&quot;</span>))<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>从这里可以比较清晰的看到，代码已经褪去了Objective-C的外层包装，回归了C的本质。</p>\n<p>这些C构体定义和消息函数定义都可以在Runtime中找到：<a href=\"http://opensource.apple.com/source/objc4/objc4-647/runtime/runtime.h\">/runtime/runtime.h</a></p>\n<p><em>结论：在程序的编译阶段，编译器已经根据语言特性，配合运行时系统的运行时库（runtime library)生成用于运行阶段执行的方法和数据结构，为runtime system提供运行时支持。</em></p>\n<h2 id=\"中间代码生成\"><a href=\"#中间代码生成\" class=\"headerlink\" title=\"中间代码生成\"></a>中间代码生成</h2><p>一切分析通过后，编译器利用此时的AST进行中间代码生成，转换为中间码<a href=\"http://llvm.org/docs/LangRef.html\">LLVM IR</a>。</p>\n<p>这个阶段最后编译器将上一阶段的输出进一步转换为中间码，以提供平台无关的支持。<br><code>clang -S -emit-llvm</code> 生成LLVM IR</p>\n<p>示例程序生成的LLVM中间码全文可参见：<a href=\"/rawcode/main_ll.html\" target=\"_blank\">LLVM IR中间码</a><br>接口，分类，协议等数据结构的中间码：</p>\n<figure class=\"highlight bash\"><figcaption><span>LLVM IR</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">%struct.NSConstantString = <span class=\"built_in\">type</span> &#123; i32*, i32, i8*, i64 &#125;</span><br><span class=\"line\">%struct._class_t = <span class=\"built_in\">type</span> &#123; %struct._class_t*, %struct._class_t*, %struct._objc_cache*, i8* (i8*, i8*)**, %struct._class_ro_t* &#125;</span><br><span class=\"line\">%struct._objc_cache = <span class=\"built_in\">type</span> opaque</span><br><span class=\"line\">%struct._class_ro_t = <span class=\"built_in\">type</span> &#123; i32, i32, i32, i8*, i8*, %struct.__method_list_t*, %struct._objc_protocol_list*, %struct._ivar_list_t*, i8*, %struct._prop_list_t* &#125;</span><br><span class=\"line\">%struct.__method_list_t = <span class=\"built_in\">type</span> &#123; i32, i32, [0 x %struct._objc_method] &#125;</span><br><span class=\"line\">%struct._objc_method = <span class=\"built_in\">type</span> &#123; i8*, i8*, i8* &#125;</span><br><span class=\"line\">%struct._objc_protocol_list = <span class=\"built_in\">type</span> &#123; i64, [0 x %struct._protocol_t*] &#125;</span><br><span class=\"line\">%struct._protocol_t = <span class=\"built_in\">type</span> &#123; i8*, i8*, %struct._objc_protocol_list*, %struct.__method_list_t*, %struct.__method_list_t*, %struct.__method_list_t*, %struct.__method_list_t*, %struct._prop_list_t*, i32, i32, i8** &#125;</span><br><span class=\"line\">%struct._ivar_list_t = <span class=\"built_in\">type</span> &#123; i32, i32, [0 x %struct._ivar_t] &#125;</span><br><span class=\"line\">%struct._ivar_t = <span class=\"built_in\">type</span> &#123; i64*, i8*, i8*, i32, i32 &#125;</span><br><span class=\"line\">%struct._prop_list_t = <span class=\"built_in\">type</span> &#123; i32, i32, [0 x %struct._prop_t] &#125;</span><br><span class=\"line\">%struct._prop_t = <span class=\"built_in\">type</span> &#123; i8*, i8* &#125;</span><br><span class=\"line\">%struct._category_t = <span class=\"built_in\">type</span> &#123; i8*, %struct._class_t*, %struct.__method_list_t*, %struct.__method_list_t*, %struct._objc_protocol_list*, %struct._prop_list_t* &#125;</span><br></pre></td></tr></table></figure>\n\n<p>main函数的中间码：</p>\n<figure class=\"highlight bash\"><figcaption><span>LLVM IR</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">; Function Attrs: ssp uwtable</span><br><span class=\"line\">define i32 @main(i32 %argc, i8** %argv) <span class=\"comment\">#0 &#123;</span></span><br><span class=\"line\">  %1 = alloca i32, align 4</span><br><span class=\"line\">  %2 = alloca i32, align 4</span><br><span class=\"line\">  %3 = alloca i8**, align 8</span><br><span class=\"line\">  %jackson = alloca i8*, align 8</span><br><span class=\"line\">  store i32 0, i32* %1</span><br><span class=\"line\">  store i32 %argc, i32* %2, align 4</span><br><span class=\"line\">  store i8** %argv, i8*** %3, align 8</span><br><span class=\"line\">  %4 = call i8* @objc_autoreleasePoolPush() <span class=\"comment\">#3</span></span><br><span class=\"line\">  %5 = load %struct._class_t** @<span class=\"string\">&quot;\\01L_OBJC_CLASSLIST_REFERENCES_<span class=\"variable\">$_</span>&quot;</span></span><br><span class=\"line\">  %6 = load i8** @<span class=\"string\">&quot;\\01L_OBJC_SELECTOR_REFERENCES_54&quot;</span>, !invariant.load !5</span><br><span class=\"line\">  %7 = bitcast %struct._class_t* %5 to i8*</span><br><span class=\"line\">  %8 = call i8* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to i8* (i8*, i8*)*)(i8* %7, i8* %6)</span><br><span class=\"line\">  %9 = bitcast i8* %8 to %1*</span><br><span class=\"line\">  %10 = load i8** @<span class=\"string\">&quot;\\01L_OBJC_SELECTOR_REFERENCES_56&quot;</span>, !invariant.load !5</span><br><span class=\"line\">  %11 = bitcast %1* %9 to i8*</span><br><span class=\"line\">  %12 = call i8* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to i8* (i8*, i8*)*)(i8* %11, i8* %10)</span><br><span class=\"line\">  %13 = bitcast i8* %12 to %1*</span><br><span class=\"line\">  %14 = bitcast %1* %13 to i8*</span><br><span class=\"line\">  store i8* %14, i8** %jackson, align 8</span><br><span class=\"line\">  %15 = load %struct._class_t** @<span class=\"string\">&quot;\\01L_OBJC_CLASSLIST_REFERENCES_<span class=\"variable\">$_</span>&quot;</span></span><br><span class=\"line\">  %16 = load i8** @<span class=\"string\">&quot;\\01L_OBJC_SELECTOR_REFERENCES_6&quot;</span>, !invariant.load !5</span><br><span class=\"line\">  %17 = bitcast %struct._class_t* %15 to i8*</span><br><span class=\"line\">  call void bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to void (i8*, i8*)*)(i8* %17, i8* %16)</span><br><span class=\"line\">  %18 = load i8** %jackson, align 8</span><br><span class=\"line\">  %19 = load i8** @<span class=\"string\">&quot;\\01L_OBJC_SELECTOR_REFERENCES_6&quot;</span>, !invariant.load !5</span><br><span class=\"line\">  call void bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to void (i8*, i8*)*)(i8* %18, i8* %19)</span><br><span class=\"line\">  %20 = load i8** %jackson, align 8</span><br><span class=\"line\">  %21 = load i8** @<span class=\"string\">&quot;\\01L_OBJC_SELECTOR_REFERENCES_57&quot;</span>, !invariant.load !5</span><br><span class=\"line\">  call void bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to void (i8*, i8*)*)(i8* %20, i8* %21)</span><br><span class=\"line\">  call void @objc_autoreleasePoolPop(i8* %4)</span><br><span class=\"line\">  ret i32 0</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>虽然看不懂，但是光挑关键字的话，其实llvm ir中间表示还是很有可读性的。</p>\n<h1 id=\"3-assembler-汇编\"><a href=\"#3-assembler-汇编\" class=\"headerlink\" title=\"3: assembler 汇编\"></a>3: assembler 汇编</h1><p>最后编译器将代码优化后，将其汇编成为汇编代码。<br>汇编代码可以由<br><code>clang -S</code>命令查看。<br>得到<a href=\"/rawcode/main_s.html\" target=\"_blank\">Assembler汇编代码</a>。<br>还是看不懂，找找关键字吧，有些眼熟。<br>还是可以体会到从源代码-&gt;AST-&gt;改写C-&gt;llvm-&gt;assembler的痕迹。<br>编译器还剩下的最后一个翻译步骤是将现在的汇编代码汇编成目标的机器码，生成目标文件&quot;.o&quot;。<br>可以使用命令：<br><code>clang -c</code>得到汇编后的输出&quot;.o&quot;。文件中的内容是机器码，只能使用反汇编查看其中的内容。<br>命令<code>nm -nm</code>可以得到目标文件中的<a href=\"/rawcode/main_nm.html\" target=\"_blank\">符号表</a>。<br>符号表是编译器用来保存源代码构造的各种信息的数据结构。这些数据在分析阶段被逐步收集，符号表每个条目都包括与一个标示符相关的信息，如一个函数名字，它的参数数量，参数类型，参数的传递方法，返回信息等信息。<br>如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0000000000000000</span> (__TEXT,__text) non-external -[NSObject(MyObject) sayHello]</span><br><span class=\"line\">                 (undefined) external _NSLog</span><br><span class=\"line\">                 (undefined) external _OBJC_CLASS_$_NSObject</span><br><span class=\"line\">                 (undefined) external _OBJC_METACLASS_$_NSObject</span><br><span class=\"line\">                 (undefined) external ___CFConstantStringClassReference</span><br><span class=\"line\">                 (undefined) external __objc_empty_cache</span><br><span class=\"line\">                 (undefined) external _objc_autoreleasePoolPop</span><br><span class=\"line\">                 (undefined) external _objc_autoreleasePoolPush</span><br><span class=\"line\">                 (undefined) external _objc_msgSend</span><br><span class=\"line\"><span class=\"number\">0000000000000030</span> (__TEXT,__text) non-external +[People hello]</span><br><span class=\"line\"><span class=\"number\">0000000000000060</span> (__TEXT,__text) non-external -[People hello]</span><br><span class=\"line\"><span class=\"number\">00000000000000d</span>0 (__TEXT,__text) non-external -[People sayHelloAgain]</span><br><span class=\"line\"><span class=\"number\">0000000000000110</span> (__TEXT,__text) external _main</span><br><span class=\"line\"><span class=\"number\">00000000000001</span>a2 (__TEXT,__cstring) non-external L_.str</span><br><span class=\"line\"><span class=\"number\">00000000000001</span>ae (__TEXT,__cstring) non-external L_.str1</span><br><span class=\"line\"><span class=\"number\">00000000000001</span>bb (__TEXT,__cstring) non-external L_.str3</span><br><span class=\"line\"><span class=\"number\">00000000000001</span>c4 (__TEXT,__cstring) non-external L_OBJC_PROP_NAME_ATTR_</span><br><span class=\"line\"><span class=\"number\">00000000000001</span>c9 (__TEXT,__cstring) non-external L_OBJC_PROP_NAME_ATTR_45</span><br><span class=\"line\">略··</span><br></pre></td></tr></table></figure>\n<p>可以看到<code>_NSLog</code>, <code>_OBJC_CLASS_$_NSObject</code>，<code>_objc_msgSend</code>等符号都是<code>(undefined)</code></p>\n<h1 id=\"4-link-链接\"><a href=\"#4-link-链接\" class=\"headerlink\" title=\"4: link 链接\"></a>4: link 链接</h1><p>汇编后的目标文件与与其他需要的目标文件链接以生成可执行文件。<br>如示例程序需要与Foundation框架链接以生成可执行程序。<br>执行命令：<br><code>clang -framework Foundation main.o</code><br>连接main.o目标文件与Foundation框架。<br>然后再次查看符号表<br><code>nm -nm a.out</code><br>得到：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">                 (undefined) <span class=\"function\">external <span class=\"title\">_NSLog</span> <span class=\"params\">(from Foundation)</span></span></span><br><span class=\"line\"><span class=\"function\">                 <span class=\"params\">(undefined)</span> external _OBJC_CLASS_$<span class=\"title\">_NSObject</span> <span class=\"params\">(from CoreFoundation)</span></span></span><br><span class=\"line\"><span class=\"function\">                 <span class=\"params\">(undefined)</span> external _OBJC_METACLASS_$<span class=\"title\">_NSObject</span> <span class=\"params\">(from CoreFoundation)</span></span></span><br><span class=\"line\"><span class=\"function\">                 <span class=\"params\">(undefined)</span> external <span class=\"title\">___CFConstantStringClassReference</span> <span class=\"params\">(from CoreFoundation)</span></span></span><br><span class=\"line\"><span class=\"function\">                 <span class=\"params\">(undefined)</span> external <span class=\"title\">__objc_empty_cache</span> <span class=\"params\">(from libobjc)</span></span></span><br><span class=\"line\"><span class=\"function\">                 <span class=\"params\">(undefined)</span> external <span class=\"title\">_objc_autoreleasePoolPop</span> <span class=\"params\">(from libobjc)</span></span></span><br><span class=\"line\"><span class=\"function\">                 <span class=\"params\">(undefined)</span> external <span class=\"title\">_objc_autoreleasePoolPush</span> <span class=\"params\">(from libobjc)</span></span></span><br><span class=\"line\"><span class=\"function\">                 <span class=\"params\">(undefined)</span> external <span class=\"title\">_objc_msgSend</span> <span class=\"params\">(from libobjc)</span></span></span><br><span class=\"line\"><span class=\"function\">                 <span class=\"params\">(undefined)</span> external <span class=\"title\">dyld_stub_binder</span> <span class=\"params\">(from libSystem)</span></span></span><br><span class=\"line\"><span class=\"function\">0000000100000000 <span class=\"params\">(__TEXT,__text)</span> [referenced dynamically] external __mh_execute_header</span></span><br><span class=\"line\"><span class=\"function\">0000000100000<span class=\"title\">b20</span> <span class=\"params\">(__TEXT,__text)</span> non-external -[<span class=\"title\">NSObject</span><span class=\"params\">(MyObject)</span> sayHello]</span></span><br><span class=\"line\"><span class=\"function\">0000000100000<span class=\"title\">b50</span> <span class=\"params\">(__TEXT,__text)</span> non-external +[People hello]</span></span><br><span class=\"line\"><span class=\"function\">0000000100000<span class=\"title\">b80</span> <span class=\"params\">(__TEXT,__text)</span> non-external -[People hello]</span></span><br><span class=\"line\"><span class=\"function\">0000000100000<span class=\"title\">bf0</span> <span class=\"params\">(__TEXT,__text)</span> non-external -[People sayHelloAgain]</span></span><br><span class=\"line\"><span class=\"function\">0000000100000<span class=\"title\">c30</span> <span class=\"params\">(__TEXT,__text)</span> external _main</span></span><br><span class=\"line\"><span class=\"function\">00000001000015<span class=\"title\">c0</span> <span class=\"params\">(__DATA,__objc_ivar)</span> external _OBJC_IVAR_$_People.sum</span></span><br><span class=\"line\"><span class=\"function\">00000001000015<span class=\"title\">c8</span> <span class=\"params\">(__DATA,__objc_data)</span> external _OBJC_METACLASS_$_People</span></span><br><span class=\"line\"><span class=\"function\">00000001000015<span class=\"title\">f0</span> <span class=\"params\">(__DATA,__objc_data)</span> external _OBJC_CLASS_$_People</span></span><br></pre></td></tr></table></figure>\n\n\n<p>经过链接后新生产的符号表已经发生了变化：<br>可以看到1-9行 <code>(undefined)</code>的符号后都多出了来源信息。<br>1-4行：<code>Foundation</code>,<code>CoreFoundation</code>框架因<code>-framework Foundation</code>指令添加了链接信息。记录了这些外部定义符号的查找框架。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">(undefined) <span class=\"function\">external <span class=\"title\">_NSLog</span> <span class=\"params\">(from Foundation)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(undefined)</span> external _OBJC_CLASS_$<span class=\"title\">_NSObject</span> <span class=\"params\">(from CoreFoundation)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(undefined)</span> external _OBJC_METACLASS_$<span class=\"title\">_NSObject</span> <span class=\"params\">(from CoreFoundation)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(undefined)</span> external <span class=\"title\">___CFConstantStringClassReference</span> <span class=\"params\">(from CoreFoundation)</span></span></span><br></pre></td></tr></table></figure>\n<p>5-8行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">(undefined) <span class=\"function\">external <span class=\"title\">__objc_empty_cache</span> <span class=\"params\">(from libobjc)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(undefined)</span> external <span class=\"title\">_objc_autoreleasePoolPop</span> <span class=\"params\">(from libobjc)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(undefined)</span> external <span class=\"title\">_objc_autoreleasePoolPush</span> <span class=\"params\">(from libobjc)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(undefined)</span> external <span class=\"title\">_objc_msgSend</span> <span class=\"params\">(from libobjc)</span></span></span><br></pre></td></tr></table></figure>\n\n<p><code>_objc_empty_cache</code>，<code>_objc_msgSend</code> 都<code>(from libobjc)</code><br><em>这里的libobjc正是运行时支持库，这里的<code>__objc_empty_cache</code>,<code>_objc_msgSend</code>等都来源于Runtime, 在连接阶段，连接器将runtime库&quot;libobjc.A.dylib&quot;链接信息添加进来，dyld动态连接器将在程序加载时，根据这些链接信息，动态链接需要的动态库。</em></p>\n<h1 id=\"5：Mach-O-file\"><a href=\"#5：Mach-O-file\" class=\"headerlink\" title=\"5：Mach-O file\"></a>5：Mach-O file</h1><p>当连接完成后，连接器生成一个格式为：Mach-O的可执行文件。<br>参考资料：</p>\n<ul>\n<li><a href=\"https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/MachORuntime/index.html\">Mach-O apple</a></li>\n<li><a href=\"http://www.cilinder.be/docs/next/NeXTStep/3.3/nd/DevTools/14_MachO/MachO.htmld/index.html\">Mach-O</a></li>\n<li><a href=\"https://www.objc.io/issues/6-build-tools/mach-o-executables/\">Mach-O 可执行文件</a></li>\n</ul>\n<p>可执行文件中包含程序执行的一切信息。<br>除了大多可执行文件中的<code>TEXT</code>,<code>DATA</code>,<code>BSS</code>等segment外，Mach-O可执行文件有一个专门的<code>_OBJC segment</code>用于存储runtime(连接器之前连接的库“libobjc.A.dylib”)所需的数据信息。<br>这些信息都由编译器生成，包含的section有：</p>\n<ul>\n<li><code>__class</code>,</li>\n<li><code> __meta_class</code>, </li>\n<li><code>__cls_meth</code>, </li>\n<li><code>__inst_meth</code>, </li>\n<li><code>__class_vars</code>, </li>\n<li><code>__instance_vars</code>,</li>\n<li><code>__message_refs</code>, </li>\n<li><code>__symbols</code>, </li>\n<li><code>__category</code>, </li>\n<li><code>__cat_inst_meth</code>, </li>\n<li><code>__cat_cls_meth</code>,</li>\n<li><code>__module_info</code>,</li>\n<li><code>__selector_strs</code>.<br>等。</li>\n</ul>\n<p><em>可以看到，这里存储了很多数据和信息，这些都是runtime在运行时将要用到的。也正是Objective-C动态之源。</em></p>\n<p><a href=\"http://wiki.lazarus.freepascal.org/Mach-O\">_OBJC segment 参考资料.</a></p>\n<h1 id=\"End\"><a href=\"#End\" class=\"headerlink\" title=\"End\"></a>End</h1><p>至此，万事俱备：<br><code>./a.out</code>后，可执行文件载入内存，dyld动态加载进runtime(libobjc.A.dylib)和其他需要的Framework和动态库。<br>准备就绪后，开始执行。<br><code>hello world</code>.<br>源-&gt;tokens-&gt;AST-&gt;运行时支持-&gt;llvm-&gt;object code确是漫漫长路。</p>\n<h1 id=\"续-Todo\"><a href=\"#续-Todo\" class=\"headerlink\" title=\"续,Todo\"></a>续,Todo</h1><p>从上面可以看到，编译器将Objective-C代码根据runtime library改写为特别的C数据结构和方法以配合Runtime来支持其Objective的特性。<br>Runtime是Objective-C的操作系统，是其一切动态性的来源。每一个程序都有自己对应的运行时，在程序启动时加载。<br>那么在a.out之后，程序正式开始之前（main函数开始执行），Runtime又是如何加载进来的呢？<br>引入新问题：静态链接，动态链接，dyld。<br>关于这方面参考链接：<br><a href=\"https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html\">dyld: Dynamic Linking On OS X</a>.<br><a href=\"http://ddeville.me/2014/04/dynamic-linking/\">Dynamic linking on iOS</a><br><a href=\"http://blog.sunnyxx.com/2014/08/30/objc-pre-main/\">iOS程序main函数之前发生了什么</a></p>\n<h1 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h1><ol>\n<li><a class=\"btn btn-secondary\" href=\"http://clang.llvm.org/docs/CommandGuide/clang.html#cmdoption-c\">Clang</a></li>\n<li><a class=\"btn btn-secondary\" href=\"https://gcc.gnu.org/onlinedocs/cpp/\">The_C_Preprocessor</a></li>\n<li><a class=\"btn btn-secondary\" href=\"http://nshipster.com/at-compiler-directives/\">Complete-List_ObjectiveC-2.0_Compiler_Directives</a></li>\n<li><a class=\"btn btn-secondary\" href=\"http://opensource.apple.com/source/objc4/objc4-647/runtime/\">Objective-C_Runtime_SourceCode</a></li>\n<li><a class=\"btn btn-secondary\" href=\"http://www.unix.com/man-page/opensolaris/1/nm/\">nm(1)——[UNIX-nm]</a></li>\n</ol>\n","categories":["iOS","Objective-C","Runtime"],"tags":["runtime","compiler"]}]
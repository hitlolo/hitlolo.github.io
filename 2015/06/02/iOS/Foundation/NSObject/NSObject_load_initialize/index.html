<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Zero's Blog | iOS学习日志"><title>NSObject:Load &amp; initialize | Command+R</title><link rel="stylesheet" type="text/css" href="/css/highlight/highlight.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/normalize.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/pure-min.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">NSObject:Load &amp; initialize</h1><a id="logo" href="/.">Command+R</a><p class="description">Life doesn't have a ctrl-z. Type wisely.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/categories/"><i class="fa fa-folder"> 分类</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">NSObject:Load &amp; initialize</h1><div class="post-meta">Jun 2, 2015<span> | </span><span class="category"><a href="/categories/iOS/">iOS @ </a><a href="/categories/iOS/Foundation/">Foundation @ </a><a href="/categories/iOS/Foundation/NSObject/">NSObject</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Load笔记"><span class="toc-number">1.</span> <span class="toc-text">Load笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#关于Load"><span class="toc-number">1.1.</span> <span class="toc-text">关于Load</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#load_images"><span class="toc-number">1.2.</span> <span class="toc-text">load_images</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#准备load方法"><span class="toc-number">1.3.</span> <span class="toc-text">准备load方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#prepare_load_methods"><span class="toc-number">1.3.1.</span> <span class="toc-text">prepare_load_methods</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#add_class_to_loadable_list_和_add_category_to_loadable_list"><span class="toc-number">1.3.2.</span> <span class="toc-text">add_class_to_loadable_list 和 add_category_to_loadable_list</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调用load方法"><span class="toc-number">1.4.</span> <span class="toc-text">调用load方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#call_load_methods"><span class="toc-number">1.4.1.</span> <span class="toc-text">call_load_methods</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#class‘s_load"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">class‘s load</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#category‘s_load"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">category‘s load</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Initialize笔记"><span class="toc-number">2.</span> <span class="toc-text">Initialize笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#关于Initialize"><span class="toc-number">2.1.</span> <span class="toc-text">关于Initialize</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从源码来看"><span class="toc-number">2.2.</span> <span class="toc-text">从源码来看</span></a></li></ol></li></ol></div></div><div class="post-content"><h1 id="Load笔记">Load笔记</h1><h2 id="关于Load">关于Load</h2><p>正如字面意义一样，<code>+(void)Load;</code>调用发生在程序的载入阶段而不是执行阶段，这意味着<code>Load</code>发生在<code>main</code>之前。关于Load，文档有如下介绍：</p>
<blockquote>
<p>Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.<br>...<br>The load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.<br>...<br>In addition:<br>A class’s +load method is called after all of its superclasses’ +load methods.<br>A category +load method is called after the class’s own +load method.</p>
<p>In a custom implementation of load you can therefore safely message other unrelated classes from the same image, but any load methods implemented by those classes may not have run yet.</p>
</blockquote>
<a id="more"></a>
<p><code>load</code>最显著的特点是：</p>
<ul>
<li>load调用发生在加载进runtime时</li>
<li>无论是静态链接或动态加载的类和分类，load都会调用</li>
<li>类的load调用在其所有superclass的load调用之后</li>
<li>category的load不会覆盖class的load，这2个方法都会被调用。且分类的load调用在其class的load调用之后</li>
<li>以上所有的前提是：load方法有实现</li>
</ul>
<h2 id="load_images">load_images</h2><p>关于load的源码，大概入手点应该是：objc-runtime-new.mm中的 load_images方法。<br>删减关于线程互斥之类的代码后：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span><br><span class="line">* load_images</span><br><span class="line">* Process +load in the given images which are being mapped in by dyld.</span><br><span class="line">* Calls ABI-agnostic code after taking ABI-specific locks.</span><br><span class="line">*</span><br><span class="line">* Locking: write-locks runtimeLock and loadMethodLock</span><br><span class="line">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *</span><br><span class="line"><span class="title">load_images</span><span class="params">(<span class="keyword">enum</span> dyld_image_states state, uint32_t infoCount,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">struct</span> dyld_image_info infoList[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    BOOL found; </span><br><span class="line">    <span class="comment">// Discover load methods</span></span><br><span class="line">    found = load_images_nolock(state, infoCount, infoList);</span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    <span class="keyword">if</span> (found) &#123;</span><br><span class="line">        call_load_methods();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>load_images</code>就干了2个工作：</p>
<ol>
<li>准备load方法</li>
<li>调用load方法</li>
</ol>
<p><code>load_images</code>方法将会在恰当时机被runtime所调用。</p>
<p><em>Edited：<br><a href="/2015/09/11/iOS/Objective-C/runtime/iOS_objc_runtime_lauch/#附：有关于+(void)load;">关于这个“恰当的调用时机”</a></em></p>
<h2 id="准备load方法">准备load方法</h2><h3 id="prepare_load_methods">prepare_load_methods</h3><p><a href="http://opensource.apple.com/source/objc4/objc4-680/runtime/objc-runtime-new.mm" target="_blank" rel="external">objc-runtime-new.mm</a><br>load_images_nolock调用 <code>prepare_load_methods</code>方法来进行准备工作。<br><figure class="highlight cpp"><figcaption><span>有删减</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count, i;</span><br><span class="line">    <span class="keyword">classref_t</span> *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">category_t</span> **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">category_t</span> *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>runtime首先获取classlist，然后逐个<code>schedule_class_load</code></li>
<li>获取categorylist，将categorylist中的category所属的class实现</li>
<li>最后将category添加进载入列表<code>add_category_to_loadable_list</code>准备调用<code>load</code></li>
</ol>
<figure class="highlight cpp"><figcaption><span>有删减</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_class_load</span><span class="params">(Class cls)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    assert(cls-&gt;isRealized());  <span class="comment">// _read_images should realize</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>schedule_class_load</code>中检查class是否有superclass有则递归调用<code>schedule_class_load</code>以将class及其所有superclass添加进载入列表<code>add_class_to_loadable_list</code>.<em>这就是为什么class的load调用在其所有superclass的load之后</em>。</p>
<p>综合以上2个方法来看。<code>prepare_load_methods</code>干的就是：</p>
<ol>
<li>将class列表中的类递归添加入一个存储载入类信息的loadable_list，</li>
<li>将category列表中的分类添加入一个存储载入分类信息的loadable_list。</li>
</ol>
<h3 id="add_class_to_loadable_list_和_add_category_to_loadable_list">add_class_to_loadable_list 和 add_category_to_loadable_list</h3><p><a href="http://opensource.apple.com/source/objc4/objc4-647/runtime/objc-loadmethod.mm" target="_blank" rel="external">源码见objc-loadmethod.mm</a></p>
<p>首先定义了一些数据结构：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct loadable_class &#123;</span><br><span class="line">    <span class="type">Class</span> cls;  // may be <span class="keyword">nil</span></span><br><span class="line">    <span class="type">IMP</span> <span class="keyword">method</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct loadable_category &#123;</span><br><span class="line">    <span class="type">Category</span> cat;  // may be <span class="keyword">nil</span></span><br><span class="line">    <span class="type">IMP</span> <span class="keyword">method</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>loadable_class</code>和<code>loadable_category</code>分别代表载入的class和category。<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMP <span class="function"><span class="keyword">method</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>指向class和category的<code>+(void)load;</code>函数指针，将用于直接调用。</p>
<figure class="highlight cpp"><figcaption><span>有删减</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span><br><span class="line">* add_class_to_loadable_list</span><br><span class="line">* Class cls has just become connected. Schedule it for +load if</span><br><span class="line">* it implements a +load method.</span><br><span class="line">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_class_to_loadable_list</span><span class="params">(Class cls)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    IMP method;</span><br><span class="line">    method = cls-&gt;getLoadMethod();</span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;  <span class="comment">// Don't bother if cls has no +load method</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_classes = (<span class="keyword">struct</span> loadable_class *)</span><br><span class="line">            _realloc_internal(loadable_classes,</span><br><span class="line">                              <span class="function">loadable_classes_allocated *</span><br><span class="line">                              <span class="title">sizeof</span><span class="params">(<span class="keyword">struct</span> loadable_class)</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>add_class_to_loadable_list</code>方法实现中：</p>
<ol>
<li><code>loadable_classes</code>是一个用来存储载入的class的数组列表。</li>
<li>runtime将载入的类添加进该数组，之后将用于逐个调用数组中每个类的<code>load</code>。</li>
<li>9-10行，如果<code>load</code>方法未实现则直接返回。<em>这说明load调用的一切前提是该方法有实现</em>。</li>
</ol>
<p>添加category到载入列表的方法<code>add_category_to_loadable_list</code>和上面大同小异。</p>
<h2 id="调用load方法">调用load方法</h2><h3 id="call_load_methods">call_load_methods</h3><p>在完成将载入类和分类添加如待载入列表后，runtime就完成了准备工作；<br>之后将会进入<code>call_load_methods</code>来逐一调用class和category的load方法。<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span> call_load_methods</span><br><span class="line"><span class="keyword">*</span> Call all pending class and category +load methods.</span><br><span class="line"><span class="keyword">*</span> Class +load methods are called superclass-first. </span><br><span class="line"><span class="keyword">*</span> Category +load methods are not called until after the parent class's +load.</span><br><span class="line"><span class="keyword">*</span> </span><br><span class="line"><span class="keyword">*</span> This method must be RE-ENTRANT, because a +load could trigger </span><br><span class="line"><span class="keyword">*</span> more image mapping. In addition, the superclass-first ordering </span><br><span class="line"><span class="keyword">*</span> must be preserved in the face of re-entrant calls. Therefore, </span><br><span class="line"><span class="keyword">*</span> only the OUTERMOST call of this function will do anything, and </span><br><span class="line"><span class="keyword">*</span> that call will handle all loadable classes, even those generated </span><br><span class="line"><span class="keyword">*</span> while it was running.</span><br><span class="line"><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span> The sequence below preserves +load ordering in the face of </span><br><span class="line"><span class="keyword">*</span> image loading during a +load, and make sure that no </span><br><span class="line"><span class="keyword">*</span> +load method is forgotten because it was added during </span><br><span class="line"><span class="keyword">*</span> a +load call.</span><br><span class="line"><span class="keyword">*</span> Sequence:</span><br><span class="line"><span class="keyword">*</span> 1. Repeatedly call class +loads until there aren't any more</span><br><span class="line"><span class="keyword">*</span> 2. Call category +loads ONCE.</span><br><span class="line"><span class="keyword">*</span> 3. Run more +loads if:</span><br><span class="line"><span class="keyword">*</span>    (a) there are more classes to load, OR</span><br><span class="line"><span class="keyword">*</span>    (b) there are some potential category +loads that have </span><br><span class="line"><span class="keyword">*</span>        still never been attempted.</span><br><span class="line"><span class="keyword">*</span> Category +loads are only run once to ensure <span class="string">"parent class first"</span> </span><br><span class="line"><span class="keyword">*</span> ordering, even if a category +load triggers a new loadable class </span><br><span class="line"><span class="keyword">*</span> and a new loadable category attached to that class. </span><br><span class="line"><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span> Locking: loadMethodLock must be held by the caller </span><br><span class="line"><span class="keyword">*</span>   All other locks must not be held.</span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/</span><br><span class="line">void call_load_methods(void)</span><br><span class="line">&#123;</span><br><span class="line">    static BOOL loading = NO;</span><br><span class="line">    BOOL more_categories;</span><br><span class="line">    </span><br><span class="line">    // Re-entrant calls do nothing; the outermost call will finish the job.</span><br><span class="line">    if (loading) return;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    void <span class="keyword">*</span>pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        // 1. Repeatedly call class +loads until there aren't any more</span><br><span class="line">        while (loadable_classes_used &gt; 0) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. Call category +loads ONCE</span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        // 3. Run more +loads if there are classes OR more untried categories</span><br><span class="line">    &#125; while (loadable_classes_used &gt; 0  ||<span class="string">  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>45-53行中，的do-while循环里runtime调用class和category的load<br>其中43-47行的嵌套while循环可见 <em>load的调用先class的<code>call_class_loads();</code>在class的load调用全部完成后，再category的<code>call_category_loads();</code></em>。</p>
<h4 id="class‘s_load">class‘s load</h4><figure class="highlight cpp"><figcaption><span>有删减</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">call_class_loads</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        <span class="keyword">load_method_t</span> load_method = (<span class="keyword">load_method_t</span>)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"LOAD: +[%s load]\n"</span>, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>从<code>loadable_classes</code>数组从逐个取出载入的class</li>
<li>取出class中的load方法实现</li>
<li>调用load方法<code>(*load_method)(cls, SEL_load);</code></li>
</ol>
<h4 id="category‘s_load">category‘s load</h4><p><code>call_category_loads</code>方法主要也是从<code>loadable_categories</code>数组逐个取出载入的分类，调用其load方法。另外还有些对新添加分类和调用排序上的操作。</p>
<h1 id="Initialize笔记">Initialize笔记</h1><h2 id="关于Initialize">关于Initialize</h2><p><code>+ (void)initialize</code>最显著的特点是：</p>
<ul>
<li>每个类只调用其一次</li>
<li>只在第一条消息发送前调用</li>
<li>superclass的initialize先于subclass</li>
<li>如果subclass未实现该方法，那么将再次调用superclass的initialize</li>
</ul>
<h2 id="从源码来看">从源码来看</h2><p><a href="http://opensource.apple.com/source/objc4/objc4-680/runtime/objc-initialize.mm" target="_blank" rel="external">关于initialize的源码</a></p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span> class_initialize.  Send the '+initialize' message on demand to any</span><br><span class="line"><span class="keyword">*</span> uninitialized class. Force initialization of superclasses first.</span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/</span><br><span class="line">void _class_initialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    Class supercls;</span><br><span class="line"></span><br><span class="line">    // Make sure super is done initializing BEFORE beginning to initialize cls.</span><br><span class="line">    // See note about deadlock above.</span><br><span class="line">    supercls = cls-&gt;superclass;</span><br><span class="line">    if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     // Send the +initialize message.</span><br><span class="line">     // Note that +initialize is sent to the superclass (again) if </span><br><span class="line">     // this class doesn't implement +initialize. 2157218</span><br><span class="line">      </span><br><span class="line">    ((void(<span class="keyword">*</span>)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是删去线程操作后的代码.</p>
<p>第13-16行，在subclass的initilize调用前首先会检查superclass的是否initialized情况，因此<em>superclass的initialize先于subclass</em></p>
<p>第22行，如果class没有initialize那么将向class发送initialize消息，以调用initialize方法:<br><code>((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</code><br>根据Objective-C的消息机制，<code>objc_msgSend</code>将根据<code>isa</code>指针搜索class的方法列表，如果class没有实现该方法，消息机制将追溯到superclass的方法列表继续查找。因此<em>如果class没有实现initialize方法，那么将再次调用superclass的initialize</em>；</p>
<p>文档中建议了这种方式来避免superclass的initialize的多次调用：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span> == [ClassName <span class="keyword">self</span>]) &#123;</span><br><span class="line">    <span class="comment">// ... do the initialization ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，上面的<code>void _class_initialize(Class cls)</code>方法，将会被runtime在方法查找时进行调用，因为当向对象发送消息时，才会进行方法查找。<em>因此，<code>initialize</code>只在第一条消息发送前调用。</em><br>又因为方法查找函数<code>lookUpImpOrForward</code>中有如下实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check for +initialize</span></span><br><span class="line">    <span class="keyword">if</span> (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><em>因此，每个类只调用一次<code>initialize</code>。</em></p>
</div><a data-url="http://www.hitlolo.com/2015/06/02/iOS/Foundation/NSObject/NSObject_load_initialize/" data-id="cipuydq6v002flshti8l6xvca" class="article-share-link">分享到</a><div class="tags"><a href="/tags/NSObject/">NSObject</a></div><div class="post-nav"><a href="/2015/06/03/iOS/Foundation/NSObject/NSObject_copying/" class="pre">NSObject:Copying</a><a href="/2015/06/01/iOS/Foundation/NSObject/Something i should know about-NSObject/" class="next">-&gt;[ NSObject ]</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Log/">Log</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">14</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Foundation/">Foundation</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Foundation/NSObject/">NSObject</a><span class="category-list-count">4</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objc/">Objc</a><span class="category-list-count">7</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objc/Runtime/">Runtime</a><span class="category-list-count">7</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/UIKit/">UIKit</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/UIKit/Interface-Builder/">Interface Builder</a><span class="category-list-count">3</span></li></ul></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/compiler/" style="font-size: 15px;">compiler</a> <a href="/tags/storyboard/" style="font-size: 15px;">storyboard</a> <a href="/tags/self/" style="font-size: 15px;">self</a> <a href="/tags/super/" style="font-size: 15px;">super</a> <a href="/tags/dyld/" style="font-size: 15px;">dyld</a> <a href="/tags/runtime/" style="font-size: 15px;">runtime</a> <a href="/tags/class/" style="font-size: 15px;">class</a> <a href="/tags/object/" style="font-size: 15px;">object</a> <a href="/tags/metaclass/" style="font-size: 15px;">metaclass</a> <a href="/tags/NSObject/" style="font-size: 15px;">NSObject</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 快速通道</i></div><ul></ul><a href="https://developer.apple.com/library" title="Apple Dev" target="_blank">Apple Dev</a><ul></ul><a href="http://stackoverflow.com/" title="StackOverflow" target="_blank">StackOverflow</a><ul></ul><a href="http://www.cocoawithlove.com/" title="CocoaWithLove" target="_blank">CocoaWithLove</a><ul></ul><a href="https://www.mikeash.com/" title="MikeAsh" target="_blank">MikeAsh</a><ul></ul><a href="http://nshipster.com/" title="NSHipster" target="_blank">NSHipster</a><ul></ul><a href="https://www.objc.io/" title="Objc" target="_blank">Objc</a></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">Command+R.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/jquery.min.js?v=0.0.0"></script><script type="text/javascript" src="/js/totop.js?v=0.0.0"></script><script type="text/javascript" src="/js/fancybox.pack.js?v=0.0.0"></script><script type="text/javascript" src="/js/jquery.fancybox.js?v=0.0.0"></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/share.js?v=0.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
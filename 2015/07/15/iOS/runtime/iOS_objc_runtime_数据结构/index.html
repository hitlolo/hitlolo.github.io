<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
    

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.4"/>


    <meta name="description" content="Zero's Blog | iOS学习日志" />



  <meta name="keywords" content="runtime," />





  <link rel="shorticon icon" type="image/x-icon" href="/img/favicon.png?v=0.4.4" />


<meta name="description" content="首先，Objective-C即面向对象的C语言，是在C的基础上给C提供了面向对象支持。如何提供的呢。Objective-C在支持所有C特性的同时，将C语法进行了一个面向对象的包装。比如说提供了面向对象层的数据结构：如Class，Object。另外，C语言的方法调用（method call）也用消息（message sending）来包装。之所以用“包装”这个词，是因为,本质上，Class、Obje">
<meta property="og:type" content="article">
<meta property="og:title" content="Objective-C--Runtime--数据结构">
<meta property="og:url" content="www.hitlolo.com/2015/07/15/iOS/runtime/iOS_objc_runtime_数据结构/index.html">
<meta property="og:site_name" content="Into the Wild">
<meta property="og:description" content="首先，Objective-C即面向对象的C语言，是在C的基础上给C提供了面向对象支持。如何提供的呢。Objective-C在支持所有C特性的同时，将C语法进行了一个面向对象的包装。比如说提供了面向对象层的数据结构：如Class，Object。另外，C语言的方法调用（method call）也用消息（message sending）来包装。之所以用“包装”这个词，是因为,本质上，Class、Obje">
<meta property="og:image" content="http://i1.tietuku.com/dfefb259adc37d43.jpg">
<meta property="og:updated_time" content="2016-02-21T04:24:54.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Objective-C--Runtime--数据结构">
<meta name="twitter:description" content="首先，Objective-C即面向对象的C语言，是在C的基础上给C提供了面向对象支持。如何提供的呢。Objective-C在支持所有C特性的同时，将C语法进行了一个面向对象的包装。比如说提供了面向对象层的数据结构：如Class，Object。另外，C语言的方法调用（method call）也用消息（message sending）来包装。之所以用“包装”这个词，是因为,本质上，Class、Obje">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post'
  };
</script>

    <title> Objective-C--Runtime--数据结构 // Into the Wild </title>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="">
<!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->




<div class="container one-column page-post-detail">
    <div class="headband"></div>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner">

 <h1 class="site-meta">
  
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Into the Wild</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  
 
  
    <ul id="menu" class="menu ">
       
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-home"></i> <br />
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            <i class="menu-item-icon icon-categories"></i> <br />
            分類
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-tags"></i> <br />
            標籤
          </a>
        </li>
      
      
    </ul>
  

  
</nav>


        </div>
    </header>

    <main id="main" class="main">
        <div class="main-inner">
            <div id="content" class="content">
                

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              Objective-C--Runtime--数据结构
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-07-15T16:40:26+08:00" content="2015-07-15">
            2015-07-15
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

              
              
                ， 
              

            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/iOS/Runtime/" itemprop="url" rel="index"><span itemprop="name">Runtime</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      

      
        <span itemprop="articleBody"><p>首先，Objective-C即面向对象的C语言，是在C的基础上给C提供了面向对象支持。<br>如何提供的呢。Objective-C在支持所有C特性的同时，将C语法进行了一个面向对象的包装。<br>比如说提供了面向对象层的数据结构：如Class，Object。<br>另外，C语言的方法调用（method call）也用消息（message sending）来包装。<br>之所以用“包装”这个词，是因为,本质上，Class、Object还是C结构体，消息传递本质还是方法调用。</p>
<p>在link阶段，每个app都会链接运行时库runtime library，运行时库是Objective-C动态性和面向对象的基础，提供了一系列数据结构和与runtime System交互的api函数，比如上文提到的Class，Object，消息传递等。<br>这里简单做一下笔记。<br><a id="more"></a></p>
<p><strong>Runtime数据结构：</strong></p>
<h2 id="Class">Class</h2><ol class="breadcrumb"><li><a href="http://opensource.apple.com/source/objc4/objc4-647/runtime/" target="_blank" rel="external">Runtime</a></li><li><a href="http://opensource.apple.com/source/objc4/objc4-647/runtime/objc.h" target="_blank" rel="external">objc.h</a></li></ol>

<p>中Class的定义为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents an Objective-C class.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> !__OBJC2__</span></span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="comment">/* Use `Class` instead of `struct objc_class *` */</span></span><br></pre></td></tr></table></figure>
<p>那么，Class是一个指向objc_class结构体的指针，而且这个结构体包含指向另一个Class的isa指针。</p>
<p>这个isa指针几乎无处不在，所有对象都包含isa指针。isa指针代表了对象所属的类，关于对象类型的所有信息都包含在这个指针里，runtime利用它才能正常得处理类和对象。</p>
<h3 id="关于isa？"><strong><span class="text-primary">关于isa？</span></strong></h3><p><strong><code>isa</code></strong>是对象指向其类结构的指针，&quot;我是什么?&quot;</p>
<h4 id="首先,对象是一个类的实例"><span class="text-primary">首先,对象是一个类的实例</span></h4><p>Objective-C是面向对象的语言，Objective-C的每一个对象(Object)都是一个类(Class)的实例，Class描述了对象的数据结构和行为。<br>当使用一个类实例化一个对象时，对象的isa就指向它的类。<br>为什么需要有个isa指向它的类？<br>我猜其中一个原因是：<br>对象(Object)在内存中占据一定空间保存自己的成员变量，但却没有自己的方法列表。<br>类(Class)的方法是其所有对象(Object)公用的。<br>当我们向一个类的实例对象发送消息时，消息绑定机制将（利用isa）追根溯源到实例对象(Instance Object)的类(Class)去决定调用哪一个方法。<br>例如：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Peple *jackson = [People pepleWithName:<span class="string">@"jackson"</span>];</span><br></pre></td></tr></table></figure></p>
<p>当代码执行后，我们获得一个实例对象jackson，它是类People的一个实例。考虑到以下几点：</p>
<ul>
<li>Class描述一个类别的状态（数据）和行为（方法）。</li>
<li>Class在内存中不持有任何状态（数据），只持有行为（方法）。、</li>
<li><p>Class持有的这些方法是类的实例对象Object共有的。</p>
</li>
<li><p>Object持有自己的状态（数据）。（jackson对象在内存中持有自己的数据：姓名&quot;jackson&quot;</p>
</li>
<li>Object不持有自己的行为（方法)。</li>
<li>Object持有指向类结构的（isa）指针作为其持有数据的一部分。（jackson知道自己的类是People）</li>
</ul>
<p>一言以蔽之：</p>
<ul>
<li><strong><span class="text-success">对象（jackson）持有状态（实例变量），类（People）持有行为（方法）。</span></strong></li>
</ul>
<p>当我们向jackson对象发送一条消息时，isa就是一切的关键：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jackson sayHello];</span><br></pre></td></tr></table></figure></p>
<ol>
<li>因为jackson是对象，并不持有方法。所以首先，得找到方法的持有者。</li>
<li>isa告之，我的类是People，其是方法的持有者。</li>
<li>根据isa指针找到People，搜索方法列表（method_list）。</li>
<li>找到则搜索停止，没找到，则搜索People的方法的持有者..一路向上。</li>
</ol>
<pre><code>                         +-------------------+        
                         |<span class="string">          </span>|<span class="string">        </span>|<span class="string">        
                         </span>|<span class="string"> NSObject </span>|<span class="string"> Class  </span>|<span class="string">        
                         </span>|<span class="string">          </span>|<span class="string">        </span>|<span class="string">        
                         +-------------------+        
                                       ^              
                                       </span>|<span class="string">              
                                       </span>|<span class="string">              
           +-------------------+       </span>|<span class="string">              
           </span>|<span class="string">          </span>|<span class="string">        </span>|<span class="string">       </span>|<span class="string">              
           </span>|<span class="string"> People   </span>|<span class="string"> Class  +-------+              
           </span>|<span class="string">          </span>|<span class="string">        </span>|<span class="string">                      
           +-------------------+                      
                         ^                            
                         </span>|<span class="string">                            
+------------------+     </span>|<span class="string">                            
</span>|<span class="string">         </span>|<span class="string">        </span>|<span class="string">     </span>|<span class="string">                            
</span>|<span class="string"> jackson </span>|<span class="string"> Object +-----+                            
</span>|<span class="string">         </span>|<span class="string">        </span>|<span class="string">                                  
+------------------+                                                  Object Method Dispatch</span>
</code></pre><p>好，我已经知道了大概： 因为对象只持有状态，类才持有方法。</p>
<p>那么：<strong><span class="text-primary">objc_class是类，为什么类结构的定义里也是以isa开始呢？</span></strong></p>
<h4 id="类也是对象"><span class="text-primary">类也是对象</span></h4><p>每个Objective-C的类也是一个对象，类也有isa指针，也可以响应消息。</p>
<blockquote>
<p>The compiler creates just one object, a class object, to represent the class. The class object has access to all the information about the class, which means mainly information about what instances of the class are like. It&#39;s able to produce new instances according to the plan put forward in the class definition.</p>
</blockquote>
<p>在方法定义时的<code>+</code>(加号)表示定义的正是类方法。如<code>[NSObject alloc]</code>就是向类发送一条消息;事实上，最开始的例子调用的也是类方法，在看一次：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Peple *jackson = [People pepleWithName:<span class="string">@"jackson"</span>];</span><br></pre></td></tr></table></figure></p>
<p>我们是向People类发送的消息，而不是对象。<br>那问题来了，<strong><span class="text-primary">类持有对象的方法，类的方法被什么持有呢？</span></strong><br>另外：<strong><span class="text-primary">我们说对象代表一个类的实例，既然类也是对象，它是什么的实例呢？</span></strong><br>这其实是同一个问题。<br>答案是：Class是mtaclass的实例,metaclass持有类方法。</p>
<blockquote>
<p>The compiler also builds a ``meta-class object&#39;&#39; for each class. It describes the class object just as the class object describes instances of the class. But while you can send messages to instances and to the class object, the meta-class object is used only internally by the run-time system.</p>
</blockquote>
<p>正如类描述了对象，metaclass（元类）也是对类的描述。<br>正如类为对象描述了实例方法，同理：元类的方法列表描述的正是类的类方法。<br>正如当向对象发送消息时<code>objc_msgSend</code>查找类的方法列表（实例方法）以决定方法调用，当向类发送消息时<code>objc_msgSend</code>查找metaclass的方法列表（类方法）以决定方法调用。<br>举个例子来看看：<br>首先，需要知道：当消息传递时，编译器进行objc_msgSend改写，会为方法声明添加2个隐藏参数：</p>
<ol>
<li>self  代表当前消息的接收者</li>
<li>_cmd  代表当前消息的selector</li>
</ol>
<p>如下例：给NSObject添加一个类别：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span>(<span class="title">MyObject</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)sayHello;</span><br><span class="line">+ (<span class="keyword">void</span>)sayHello;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span></span></span><br><span class="line">- (<span class="keyword">void</span>)sayHello&#123;&#125;;<span class="comment">//空实现</span></span><br><span class="line">+ (<span class="keyword">void</span>)sayHello&#123;&#125;;<span class="comment">//空实现</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>使用命令<code>clang -Xclang -ast-dump main.m</code>后可以看到：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">|-ObjCCategoryDecl <span class="number">0x1055d20c0</span> &lt;main.m:<span class="number">15</span>:<span class="number">1</span>, line:<span class="number">20</span>:<span class="number">2</span>&gt; line:<span class="number">15</span>:<span class="number">12</span> MyObject</span><br><span class="line">| |-ObjCInterface <span class="number">0x1033ab3b0</span> <span class="string">'NSObject'</span></span><br><span class="line">| |-ObjCCategoryImpl <span class="number">0x1055d2290</span> <span class="string">'NSObject'</span></span><br><span class="line">| |-ObjCMethodDecl <span class="number">0x1055d2160</span> &lt;line:<span class="number">17</span>:<span class="number">1</span>, col:<span class="number">17</span>&gt; col:<span class="number">1</span> - sayHello <span class="string">'void'</span></span><br><span class="line">| <span class="string">`-ObjCMethodDecl 0x1055d2200 &lt;line:18:1, col:17&gt; col:1 + sayHello 'void'</span><br><span class="line">|-ObjCCategoryImplDecl 0x1055d2290 &lt;line:22:1, line:33:1&gt; line:22:17 NSObject</span><br><span class="line">| |-ObjCInterface 0x1033ab3b0 'NSObject'</span><br><span class="line">| |-ObjCCategory 0x1055d20c0 'MyObject'</span><br><span class="line">| |-ObjCMethodDecl 0x1055d2310 &lt;line:24:1, line:26:1&gt; line:24:1 - sayHello 'void'</span><br><span class="line">| | |-ImplicitParamDecl 0x1055d2440 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit self 'NSObject *'</span><br><span class="line">| | |-ImplicitParamDecl 0x1055d24a0 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit _cmd 'SEL':'SEL *'</span><br><span class="line">| | `</span>-CompoundStmt <span class="number">0x1055d24f8</span> &lt;col:<span class="number">17</span>, line:<span class="number">26</span>:<span class="number">1</span>&gt;</span><br><span class="line">| <span class="string">`-ObjCMethodDecl 0x1055d23b0 &lt;line:28:1, line:30:1&gt; line:28:1 + sayHello 'void'</span><br><span class="line">|   |-ImplicitParamDecl 0x1055d2510 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit self 'Class':'Class'</span><br><span class="line">|   |-ImplicitParamDecl 0x1055d2570 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit _cmd 'SEL':'SEL *'</span><br><span class="line">|   `</span>-CompoundStmt <span class="number">0x1055d25c8</span> &lt;col:<span class="number">17</span>, line:<span class="number">30</span>:<span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>仔细看一下：<br>在9-11行，NSObject实例方法<code>- (void)sayHello</code>增添的两个隐藏参数是：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implicit self <span class="string">'NSObject *'</span></span><br><span class="line">implicit _cmd <span class="string">'SEL'</span>:<span class="string">'SEL *'</span></span><br></pre></td></tr></table></figure></p>
<p>在13-15行，NSObject类方法<code>+ (void)sayHello</code>增添的两个隐藏参数是：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implicit self <span class="string">'Class'</span>:<span class="string">'Class'</span></span><br><span class="line">implicit _cmd <span class="string">'SEL'</span>:<span class="string">'SEL *'</span></span><br></pre></td></tr></table></figure></p>
<p>这也说明：</p>
<ul>
<li>NSObject中实例方法的消息接收者：<code>self</code>是<code>NSObject*</code> 是指向NSObject对象的指针，即实例对象</li>
<li>NSObject类方法消息接收者者：<code>self</code>是<code>Class</code>,这个<code>Class</code>是NSObject类。</li>
</ul>
<p>现在再来看刚才的例子，</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span></span></span><br><span class="line">- (<span class="keyword">void</span>)sayHello&#123;&#125;;<span class="comment">//空实现</span></span><br><span class="line">+ (<span class="keyword">void</span>)sayHello&#123;&#125;;<span class="comment">//空实现</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><code>+ (void)sayHello{};</code>将被NSObject Class调用，消息的接收者<code>self</code>是一个<code>Class</code>，这个Class是NSObject-metaclass的实例NSObject class。这个方法是类方法，其被NSObject的metaclass持有。<br><code>- (void)sayHello{};</code>将被NSobject的inctance object调用，消息的接收者<code>self</code>是一个<code>NSObject*</code>,即NSObject的一个实例对象。这个对象是NSObject的实例。这个方法是实例方法，其持有者是NSObject。<br>好像有点绕，希望没理解错吧。</p>
<h4 id="那么,metaclass又是什么？"><strong><span class="text-primary">那么,metaclass又是什么？</span></strong></h4><p>meta-class 是 Class 对象的类,由runtime system创建及维护。它拥有和其他类一样的数据结构，也有isa，super_class,方法列表。</p>
<blockquote>
<p>The compiler also builds a ``meta-class object&#39;&#39; for each class. It describes the class object just as the class object describes instances of the class. But while you can send messages to instances and to the class object, the meta-class object is used only internally by the run-time system.</p>
</blockquote>
<p>这意味着，其实meta-class也是一个对象。那么问题来了，<strong><span class="text-primary">难道无止境了吗？</span></strong><br>metaclass的isa指向基类的metaclass。请注意，这里说的是<strong>基类</strong>而不是<strong>父类</strong>。<br>Objective-C的中NSObject继承体系下的基类就是NSObject。所以上文中说的metaclass的isa指向基类的metaclass即是说metaclass的isa指向NSObject的metaclass。<br>那么,<strong><span class="text-primary">NSObject的metaclass又是什么？</span></strong><br>显然，它是NSObject类的元类，NSObject是其类继承链上的基，NSObject-metaclass是其元类继承链上的基。NSObject的metaclass的isa指向自己。<br>这可以在runtime源码中找到证据：</p>
<ol class="breadcrumb"><li><a href="http://opensource.apple.com/source/objc4/objc4-647/runtime/" target="_blank" rel="external">Runtime</a></li><li><a href="http://opensource.apple.com/source/objc4/objc4-647/runtime/objc-runtime-new.h" target="_blank" rel="external">objc-runtime-new.h</a></li></ol>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMetaClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assert(<span class="keyword">this</span>);</span><br><span class="line">    assert(isRealized());</span><br><span class="line">    <span class="keyword">return</span> data()-&gt;ro-&gt;flags &amp; RO_META;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// NOT identical to this-&gt;ISA when this is a metaclass</span></span><br><span class="line"><span class="function">Class <span class="title">getMeta</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isMetaClass()) <span class="keyword">return</span> (Class)<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">this</span>-&gt;ISA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRootClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> superclass == nil;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRootMetaclass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ISA() == (Class)<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合代码，再引用一篇博客中看到的图：<br><img src="http://i1.tietuku.com/dfefb259adc37d43.jpg" alt=""><br>Class与metaclass的继承链平行，这样使得metaclass可以描述平级的Class。<br>NSObject-metaclass继承自NSObject，这样使得NSObject-metaclass可以描述NSObject。<br>NSObject-metaclass isa 指向自己，这样完成闭环。</p>
<h3 id="关于super_class">关于super_class</h3><p><code>super_class</code>也是一个指向类结构的指针，&quot;我的父类是什么？&quot;。<br>是关于面向对象的继承链的问题,方法查找机制当在对象上找不到调用方法时，将追溯到super_class继续进行。<br>根类(如NSObject或NSProxy)的super_class为nil。<br>Class的super_class指向其父类，而meta-class的super_class则指向父类的元类。<br>由继承链从下往上看。<br>元类的super_class链与类的super_class链平行，所以类方法的继承与实例方法的继承也是并行的。<br>基类的元类(root class’s metaclass)的父类super_class指向基类自己(root class)。<br>这样一来，其实后面的所有类也都是根类的的实例，正如所有对象都是根类的的实例一样。</p>
<p>例如：现在有根类的子类People，<code>@interface People:NSObject</code><br>NSObject的metaclass继承自自己，所以root metaclass是NSObject的子类。<br>People的metaclass继承自NSObject的root metaclass。所以People的metaclass也是NSObject的子类。<br>People是metaclass的实例，所以People也是NSObject子类的实例。<br>也就是说，所有类都可以响应根类(NSObject)的实例方法。所有类和所有实例其实都是根类的实例或子类。<br>不知道理解错没有。总之有点晕。<a href="http://sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" target="_blank" rel="external">这篇文章感觉讲得很清晰。</a></p>
<h3 id="实例变量objc_ivar_list">实例变量objc_ivar_list</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">    <span class="keyword">char</span> *ivar_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">char</span> *ivar_type                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">int</span> ivar_offset                                          OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>实例变量结构体，定义了变量的所有信息：变量名，变量类型，在类结构体中的地址偏移位置，和占用空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_ivar_list &#123;</span><br><span class="line">    <span class="keyword">int</span> ivar_count                                           OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar ivar_list[<span class="number">1</span>]                            OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例变量表，定义了实例变量数量和一个<a href="https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html" target="_blank" rel="external">可变长的数组</a>，根据实际变量数量分配空间。</p>
<h3 id="objc_method_list">objc_method_list</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/// An opaque type that represents a method in a class definition.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">char</span> *method_types                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_method_list &#123;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list *obsolete                        OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> method_count                                         OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method method_list[<span class="number">1</span>]                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>objc_method结构体持有方法的SEL方法名和实现（函数指针）IMP。<br>objc_method_list持有可变长数组持有方法列表。</p>
<h3 id="objc_cache">objc_cache</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_cache *Cache                             OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_cache &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>                 OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line">    Method buckets[<span class="number">1</span>]                                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将原本直接的函数调用(method call)包装为消息传递（send message）后函数调用的简单方式演变为先SEL查找对应IMP，再调用IMP的过程，当方法列表庞大时，SEL和IMP的查找对应显然会成为一个耗时的工序。objc_cache正是消息传递机制中的一个优化环节。当第一次发送消息时，runtime将查找结果Method放入objc_cache的篮子（buckets）中，以加快之后该消息工作的速度。</p>
<h2 id="id和objc_object">id和objc_object</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#if !OBJC_TYPES_DEFINED</span></span><br><span class="line"><span class="comment">/// An opaque type that represents an Objective-C class.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Represents an instance of a class.</span></span><br><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_<span class="built_in">AVAILABILITY</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A pointer to an instance of a class.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br></pre></td></tr></table></figure>
<p>objc_object即对象，代表类的实例。id是指向类实例的指针。可持有任意对象。id类型是dynamic typing的基础，在编译阶段无法确定为变量分配什么对象类型时，可以赋值给id类型，将该变量的类型检查和确定推迟到运行时。</p>
<h2 id="SEL和IMP">SEL和IMP</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents a method selector.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A pointer to the function of a method implementation. </span></span><br><span class="line"><span class="preprocessor">#if !OBJC_OLD_DISPATCH_PROTOTYPES</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (*IMP)(<span class="keyword">void</span> <span class="comment">/* id, SEL, ... */</span> ); </span><br><span class="line"><span class="preprocessor">#else</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">id</span> (*IMP)(<span class="keyword">id</span>, SEL, ...); </span><br><span class="line"><span class="preprocessor">#endif</span></span><br></pre></td></tr></table></figure>
<p>关于SEL，从定义中只可以得出其是指向<code>struct objc_selector</code>的指针，但是我没有找到<code>objc_selector</code>的定义。有点迷惑。</p>
<p><ol class="breadcrumb"><a href="http://www.opensource.apple.com/source/objc4/objc4-532.2/runtime/objc-sel.mm" target="_blank" rel="external">objc_sel.mm</a></ol><br>中有一段代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *sel_getName(SEL sel) &#123;</span><br><span class="line"><span class="preprocessor">#if SUPPORT_IGNORED_SELECTOR_CONSTANT</span></span><br><span class="line">    <span class="keyword">if</span> ((uintptr_t)sel == kIgnore) <span class="keyword">return</span> <span class="string">"&lt;ignored selector&gt;"</span>;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">    <span class="keyword">return</span> sel ? (<span class="keyword">const</span> <span class="keyword">char</span> *)sel : <span class="string">"&lt;null selector&gt;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到SEL似乎是char*，但是不确定。<br>编译器指令@selector将方法名转换为SEL类型，这个是很常用的：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SEL aSelector = <span class="keyword">@selector</span>(run);</span><br><span class="line">[aDog performSelector:aSelector];</span><br></pre></td></tr></table></figure></p>
<p>IMP即函数指针,指向方法的具体实现。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)methodWithInt:(<span class="keyword">int</span>)firstInt andInt:(<span class="keyword">int</span>)secondInt &#123; </span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, firstInt + secondInt); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//get SEL</span></span><br><span class="line">SEL theSelector = <span class="keyword">@selector</span>(methodWithInt:andInt:);</span><br><span class="line"><span class="comment">//get IMP</span></span><br><span class="line">IMP theImplementation = [<span class="keyword">self</span> methodForSelector:theSelector]; </span><br><span class="line"><span class="comment">//note that if the method doesn't return void, you have to explicitly typecast the IMP, e.g. int(* foo)(id, SEL, int, int) = ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//after get the IMP,we can call IMP as a function pointer</span></span><br><span class="line">theImplementation(<span class="keyword">self</span>, theSelector, <span class="number">3</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure></p>
<p>SEL和IMP是dynamic binding的关键元素。SEL确定方法名，IMP确定方法的具体实现。在运行时阶段，runtime system通过SEL和IMP将消息与方法对应起来。</p>
</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/runtime/" rel="tag">#runtime</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/05/26/iOS/runtime/iOS_objc_runtime_compiler/" rel="next">Objective-C——Compiler</a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


            </div>

            

            
              <div class="comments" id="comments">
                
              </div>
            
        </div>

        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目錄
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            本站概覽
          </li>
        </ul>
      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/img/logo.png" alt="Zero" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Zero</p>
        </div>
        <p class="site-description motion-element" itemprop="description">Zero's Blog | iOS学习日志</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">5</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">分類</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">3</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/hitlolo" target="_blank">github</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
            <p class="site-author-name">Links</p>
            
              <span class="links-of-author-item">
              <a href="https://developer.apple.com/library" target="_blank">Apple Lib</a>
              </span>
            
              <span class="links-of-author-item">
              <a href="http://developer.android.com/index.html" target="_blank">Android</a>
              </span>
            
              <span class="links-of-author-item">
              <a href="http://stackoverflow.com/" target="_blank">StackOverflow</a>
              </span>
            
          
        </div>

      </section>

      
        <section class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Class"><span class="nav-number">1.</span> <span class="nav-text">Class</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关于isa？"><span class="nav-number">1.1.</span> <span class="nav-text">关于isa？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#首先,对象是一个类的实例"><span class="nav-number">1.1.1.</span> <span class="nav-text">首先,对象是一个类的实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类也是对象"><span class="nav-number">1.1.2.</span> <span class="nav-text">类也是对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#那么,metaclass又是什么？"><span class="nav-number">1.1.3.</span> <span class="nav-text">那么,metaclass又是什么？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于super_class"><span class="nav-number">1.2.</span> <span class="nav-text">关于super_class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例变量objc_ivar_list"><span class="nav-number">1.3.</span> <span class="nav-text">实例变量objc_ivar_list</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#objc_method_list"><span class="nav-number">1.4.</span> <span class="nav-text">objc_method_list</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#objc_cache"><span class="nav-number">1.5.</span> <span class="nav-text">objc_cache</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#id和objc_object"><span class="nav-number">2.</span> <span class="nav-text">id和objc_object</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SEL和IMP"><span class="nav-number">3.</span> <span class="nav-text">SEL和IMP</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
        <div class="footer-inner">
            



<div class="copyright">
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  
  <span class="author" itemprop="copyrightHolder">Zero</span>
 


</div>



<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



        </div>
    </footer>

    <div class="back-to-top"></div>
</div>

<script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.4"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.4"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.4" id="motion.global"></script>



  <script type="text/javascript" src="/js/search-toggle.js"></script>


  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.4" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 0.4 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    var $tocContent = $('.post-toc-content');
    if (isDesktop() && CONFIG.sidebar === 'post') {
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
        displaySidebar();
      }
    }
  });
</script>



<script type="text/javascript">
    $(document).ready(function () {
        if (CONFIG.sidebar === 'always') {
            displaySidebar();
        }
    });
</script>








<!-- lazyload -->
<script type="text/javascript" src="/js/lazyload.js"></script>
<script type="text/javascript">
    jQuery(function () {
        jQuery("#posts img").lazyload({
            placeholder: "/images/loading.gif",
            effect: "fadeIn"
        });
    });
</script>
</body>
</html>

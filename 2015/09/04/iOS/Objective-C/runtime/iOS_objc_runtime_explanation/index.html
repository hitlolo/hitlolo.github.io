<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Zero's Blog | iOS学习日志"><title>Runtime：Why runtime? | Command+R</title><link rel="stylesheet" type="text/css" href="/css/highlight/highlight.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/normalize.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/pure-min.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Runtime：Why runtime?</h1><a id="logo" href="/.">Command+R</a><p class="description">Life doesn't have a ctrl-z. Type wisely.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/categories/"><i class="fa fa-folder"> 分类</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Runtime：Why runtime?</h1><div class="post-meta">Sep 4, 2015<span> | </span><span class="category"><a href="/categories/iOS/">iOS @ </a><a href="/categories/iOS/Objc/">Objc @ </a><a href="/categories/iOS/Objc/Runtime/">Runtime</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#So,_why_Runtime?"><span class="toc-number">1.</span> <span class="toc-text">So, why Runtime?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Still_Why?"><span class="toc-number">2.</span> <span class="toc-text">Still Why?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Answer"><span class="toc-number">3.</span> <span class="toc-text">Answer</span></a></li></ol></div></div><div class="post-content"><p>学习一个东西之前，我觉得最好先想想为什么这个东西存在。<br>所谓，“存在即合理”，那么，先了解一下这个合理性？</p>
<h1 id="So,_why_Runtime?">So, why Runtime?</h1><p>每个人都在教科书上看到过：“面向过程编程”，“面向对象编程”。<br>有好多好多的书阐释什么是面向过程，什么是面向对象分析，什么是面向对象设计。<br>在我看来：<em>它们只是两种不同的思维方式。</em><br>编写程序时，这2种不同的思维方式，产生出的是的两种不同代码组织形式。<br>就好像2个思路不同的作者讲述同一个故事：一个流水账般地从故事的开始讲到结束。一个把故事组织成从不同主人翁的角度来徐徐道出。<br>然而，他们讲的都是同一个故事。</p>
<p>程序是码农讲述给CPU听的故事。<br>只要CPU能听懂，那么程序就是OK的。CPU不管这个故事是以什么方式讲述的，它不care故事的叙事结构。<br>如何讲述这个故事，纯粹是码农自己的事。</p>
<p>然而，CPU的头脑是简单的，只接受流水式的故事。所以在以前，码农们为了CPU能听懂，都流水式地讲故事。<br>有些码农发现这个方式，很累，不符合自己的思考方式。想用更符合思考方式的方法来有组织，分对象地讲。<br>他们在既有的叙事结构上增加了对象，消息等概念。但可惜，CPU不明白你在说什么。<br>因为CPU只听得懂简单的流水式故事，鉴于此，码农在叙述故事的同时，还必须增加对象，方法列表等额外的信息来进行必要的的阐释和说明：对象是什么，消息怎么处理，这个对象你可以去哪里哪里查到，这个类在内存哪里哪里。反正不懂的你去那里查就行了。</p>
<p>runtime干的就是这个工作，是对面向过程和面向对象2种叙事风格转换过程中的起承转合。<br>这大概就是runtime的意义了。</p>
<h1 id="Still_Why?">Still Why?</h1><p>综上，所谓：“面向过程编程”，“面向对象编程”，不过是程序编写时的2种不同思维方式。<br>并没有硬性的非要用哪一种？<br>因为不管用哪一种方式讲这个故事。讲的都是同一个故事。也就是说：用面向对象完成的讲述的故事，面向过程一样可以讲述出来。反之亦然。<br>C就是面向过程的语言，不支持所谓的面向对象特性。但是我们一样可以用C来面向对象。<br>所需要做的就是把我们希望表达的概念和工作机制用合适的方式表达出来而已。</p>
<p>举个栗子：<br>面向对象，首先我们有Class的概念。怎么表达呢？<br>可以用struct来表达一个封装的Class(事实上，C++，Objective-C也是这么做的):</p>
<p>用一个类来表达人类，增添3个基本属性：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Human&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">bool</span> gender;</span><br><span class="line">    <span class="keyword">int</span>  age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它在内存中是这样：</p>
<pre><code>Human

<span class="code">+-------------+</span>
|name         | 10bytes
<span class="header">|             |
+-------------+</span>
<span class="header">|gender       | 1bytes
+-------------+</span>
<span class="header">|age          | 4bytes
+-------------+</span>
</code></pre><p>结构很明晰，我们只要只要对象的起始地址，结束地址，各属性所占大小，就可以根据起始地址访问各个属性。</p>
<p>现在，再来表达一下继承：</p>
<p>新增加男孩，女孩类，它们都是人类，但有各自的独有属性。<br><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Boy</span></span>&#123;</span><br><span class="line">    Human human;</span><br><span class="line">    int powerValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Girl</span></span>&#123;</span><br><span class="line">    Human human;</span><br><span class="line">    int beautyValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它们在内存中也只是在原Human结构上再增加了自己的变量：</p>
<pre><code>Boy                          Girl

+-------------+              +-------------+
|<span class="string">name         </span>|<span class="string"> 10bytes      </span>|<span class="string">name         </span>|<span class="string"> 10bytes
</span>|<span class="string">             </span>|<span class="string">              </span>|<span class="string">             </span>|
+-------------+              +-------------+
|<span class="string">gender       </span>|<span class="string"> 1bytes       </span>|<span class="string">gender       </span>|<span class="string"> 1bytes
+-------------+              +-------------+
</span>|<span class="string">age          </span>|<span class="string"> 4bytes       </span>|<span class="string">age          </span>|<span class="string"> 4bytes
+-------------+              +-------------+
</span>|<span class="string">powerValue   </span>|<span class="string"> 4bytes       </span>|<span class="string">beautyValue  </span>|<span class="string"> 4bytes
+-------------+              +-------------+</span>
</code></pre><p>从内存来看，父类Human和子类，Girl，Boy在前面的字节都是完全一样的。我们可以用Human的指针引用其子类Boy，Girl，在需要的时候在强制转换来表达特定的类型。</p>
<p>下面在来表达一下类的行为（方法）：<br>Boy和Girl都有玩的行为。但是它们所玩的内容不一样，如何表示Boy和Girl子类对同一个行为的不同实现（多态）：</p>
<p>新增加一个play函数，它接受对象为参数，根据对象的不同调用不同的玩的方法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Human* human,<span class="keyword">int</span> hour)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( human-&gt;gender == BOY ) </span><br><span class="line">        playFootball(hour);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        playDoll(hour);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Play方法只是简单地针对不同的对象选择不同的方法实现。</p>
<p>接下来，我们希望不但要为不同对象调用不同的实现，我们还想在它们各自玩的方法中访问对象的实例进行操作，或者在方法中在调用对象的其他行为。<br>需要做的就是在方法调用中，增加一个对象参数：</p>
<p>让 playFootball和playDoll也接受所要操作的对象参数。让它们可以针对特定对象进行操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Human* human,<span class="keyword">int</span> hour)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( human-&gt;gender == BOY ) </span><br><span class="line">        playFootball((Boy*)human,hour);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        playDoll((Girl*)human,hour);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后这样调用这个Play方法让一个Boy的实例对象玩2个小时，一个Girl实例对象玩3个小时：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">play(boy,<span class="number">2</span>);   </span><br><span class="line">play(girl,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们通过在第一个参数传入对象指针来明确是对具体哪一个对象调用方法和该对象的类型。<br>例如：可以在方法中这样访问对象的实例变量：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">playFootball</span><span class="params">(Human *human,<span class="keyword">int</span> hour)</span></span>&#123;</span><br><span class="line">    human-&gt;powerValue = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了更明确这个参数的目的。可以把它取名为：<code>self</code>或者<code>this</code>。（事实上，Objective-C的消息机制也是这么做的）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">playFootball</span><span class="params">(Human *self,<span class="keyword">int</span> hour)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(self-&gt;powerValue &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    self-&gt;age = <span class="number">10</span></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们还只是在对象外部定义了方法，然后去针对对象而调用不同的方法实现。<br>如何表达面向对象中成员函数的概念呢？<br>只需要在类结构中添加函数指针成员变量，让它们分别指向函数的实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Human&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">bool</span> gender;</span><br><span class="line">    <span class="keyword">int</span>  age;</span><br><span class="line">    <span class="comment">//function</span></span><br><span class="line">    <span class="keyword">void</span>(*play)(Human *self,<span class="keyword">int</span> hour);</span><br><span class="line">    <span class="keyword">void</span>(*rest)(Human *self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在实例化对象时，让方法指向对象的特有实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Human human;</span><br><span class="line">Boy jack;</span><br><span class="line">Girl rose;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">human.play = super_play;</span><br><span class="line">human.rest = super_rest;</span><br><span class="line"></span><br><span class="line">jack.play = playFootBall;</span><br><span class="line">jack.rest = watchTV;</span><br><span class="line"></span><br><span class="line">rose.play = playDoll;</span><br><span class="line">rose.rest = bath;</span><br></pre></td></tr></table></figure></p>
<p>之后就可以这样来调用成员函数让它们分别玩起来：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jack.play(&amp;jack,<span class="number">2</span>);</span><br><span class="line">rose.play(&amp;rose,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<p>这样的确实现了对成员函数的调用。但是却很不方便：</p>
<ol>
<li>如果我们为一个类创建多个对象，则需要为每个对象赋值其成员函数指针。这样，每个对象都持有其所有成员函数指针。对象的成员函数实现是一致的，在此前提下，每个对象都对一个相同的函数指针持有引用会产生很多问题。明显的就有：初始化复杂的，维护困难，空间浪费巨大。</li>
<li>没有办法调用父类的成员函数。因为函数指针在初始化时被绑定了，且没有针对父类函数的引用。</li>
</ol>
<p>所以，最好是把成员函数剥离出来，让一个类的所有对象共享函数实现。<br>具体做法是设计一个结构保存函数列表（事实上 ，Objective-C也是这么做的。当然，我是说大体上）：</p>
<p>新建一个结构表达Human类的所有行为，包括的信息有它的方法，方法数，方法所在空间。<br>依例也建立一个Boy子类的行为结构，表达子类的方法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Human superclass's method</span></span><br><span class="line"><span class="keyword">struct</span> HumanClassMethod&#123;</span><br><span class="line">    <span class="keyword">int</span> method_count;</span><br><span class="line">    <span class="keyword">int</span> method_size;</span><br><span class="line">    <span class="keyword">void</span> (*play)(Human* self,<span class="keyword">int</span> hour);</span><br><span class="line">    <span class="keyword">void</span> (*rest)(Human* self);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Boy subclass's method</span></span><br><span class="line"><span class="keyword">struct</span> BoyClassMethod&#123;</span><br><span class="line">    <span class="keyword">int</span> method_count;</span><br><span class="line">    <span class="keyword">int</span> method_size;</span><br><span class="line">    <span class="comment">//super's method first</span></span><br><span class="line">    HumanClassMethod *super_method_list,</span><br><span class="line">    <span class="keyword">void</span> (*play)(Human* self,<span class="keyword">int</span> hour);</span><br><span class="line">    <span class="keyword">void</span> (*rest)(Human* self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数列表结构中保存有</p>
<ol>
<li>函数个数，</li>
<li>函数列表结构所占大小的信息，</li>
<li>函数列表——每一个函数指针指向函数的具体实现。</li>
</ol>
<p>其中1,2这两个信息足以让我访问到结构中保存的每一个函数指针。<br>函数列表所罗列的则是每个行为的具体实现。<br>类的每个对象都可以根据这些信息在内存中找到函数实现，并予以调用。</p>
<p>在使用类和对象前，提前准备好这些含有类成员函数信息的结构数据结构，让所有类对象可以共享：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HumanClassMethod human_method_list = &#123;</span><br><span class="line">    super_play,</span><br><span class="line">    super_rest</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BoyClassMethod boy_method_list = &#123;</span><br><span class="line">    &amp;human_method_list,</span><br><span class="line">    playFootBall,</span><br><span class="line">    watchTV</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>最后，在类的成员中添加指向函数列表结构的指针，使其表达为类的成员函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Human&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">bool</span> gender;</span><br><span class="line">    <span class="keyword">int</span>  age;</span><br><span class="line">    <span class="comment">//function</span></span><br><span class="line">    <span class="keyword">struct</span> HumanClassMethod *method_list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Boy&#123;</span><br><span class="line">    Human human;</span><br><span class="line">    <span class="keyword">int</span> powerValue;</span><br><span class="line">    <span class="keyword">struct</span> BoyClassMethod *method_list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，当我们实例化对象时，让对象的函数列表指针指向之前准备好的类的函数列表：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Boy jack;</span><br><span class="line">Boy tom;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">jack.method_list = &amp;boy_method_list;</span><br><span class="line">tom.method_list =  &amp;boy_method_list;</span><br></pre></td></tr></table></figure></p>
<p>对象成员函数的调用就变成调用类函数表中的函数实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jack.method_list-&gt;play(&amp;jack,<span class="number">2</span>);</span><br><span class="line">tom.method_list-&gt;play(&amp;tom,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<p>甚至还可以调用父类的函数实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jack.method_list-&gt;super_method_list-&gt;play(&amp;jack,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>到这里看起来，似乎越来越面向对象了。<br>接下来，我们还可以设计更好的方法调用机制：比如为方法增加方法名和方法实现的映射，在方法调用时，先搜索方法结构中是否存在这个方法，再进行调用：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> method&#123;</span><br><span class="line">    <span class="keyword">char</span>* method_name;</span><br><span class="line">    <span class="keyword">void</span> (IMP*)(id* self,...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看上去越来越眼熟了。<br>当然，以上结构和方法只是尽量进行概念的表达。要完成完整的面向对象，还需要很多工作和设计：我们可以为类结构加入super指针，用来引用类的父类。可以为类结构的方法列表设计其他方法查找机制。。。等等等等。<br>总之，一切需要的特性。其实都可以用面向过程的C来实现。<br>因为：就像本文一开始提到的：“面向对象”和“面向过程”仅仅是2种不同的思维方式：<br>不管用哪一种方式讲故事。讲的都是同一个故事。</p>
<h1 id="Answer">Answer</h1><p>现在回到咱们的问题上：为什么要存在这个runtime system。<br>如上所述我们知道：面向过程的语言也可以用面向对象的思维来进行编程。需要转换的只是数据的抽象，方法调用机制的转换以及其他一些概念的转变。<br>这些仅仅是思维概念的不同和逻辑的改变。</p>
<ol>
<li><p>为了改变故事的叙事结构，我们不需要重新设计一门外语来讲这个故事。<br>增加面向对象特性，我们也不需要非得将一个既有语言彻底颠覆，或者重新设计一个语言(当然，你也可以这么做）。如果比较懒的话，只需要在原有语言的基础上，清楚地抽象出我们需要的数据模型，实现需要的特性和机制就可以达到目的。<br>（比如在C的基础上增加面向对象的概念和机制而由来的Objective-C）</p>
</li>
<li><p>再者，没人会在每次编写的时候，都重新抽象一套数据，设计一套方法调用机制，或将之前的设计重新在写一次。这一套概念的转陈肯定是一个一劳永逸的系统。编写一次就好。</p>
</li>
</ol>
<p>综上，Objective-C把其面向对象的数据抽象，类特性，方法查找机制，协议，分类等它的设计哲学都统一放在了runtime中，供每一个用C来讲面向对象故事的程序使用。<br>我想这就是runtime的由来。</p>
<p>所以，把runtime形容成面向过程C的面向对象概念转换说明书，也不为过。<br>你按你喜欢的面向对象来讲故事就好了，其他CPU什么的听不懂的，runtime来帮你解决。<br>这大概就是runtime起承转合的意义。</p>
</div><a data-url="http://www.hitlolo.com/2015/09/04/iOS/Objective-C/runtime/iOS_objc_runtime_explanation/" data-id="ciqqfns7h001asghtpapf0sdx" class="article-share-link">分享到</a><div class="tags"><a href="/tags/runtime/">runtime</a></div><div class="post-nav"><a href="/2015/09/10/iOS/Objective-C/runtime/iOS_objc_runtime_compiler/" class="pre">Runtime：Before lauch，关于Compiler time</a><a href="/2015/09/01/iOS/Objective-C/runtime/Something i should know about-Runtime/" class="next">-&gt;[ Runtime ]</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Log/">Log</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">14</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Foundation/">Foundation</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Foundation/NSObject/">NSObject</a><span class="category-list-count">4</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objc/">Objc</a><span class="category-list-count">7</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Objc/Runtime/">Runtime</a><span class="category-list-count">7</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/UIKit/">UIKit</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/UIKit/Interface-Builder/">Interface Builder</a><span class="category-list-count">3</span></li></ul></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/compiler/" style="font-size: 15px;">compiler</a> <a href="/tags/storyboard/" style="font-size: 15px;">storyboard</a> <a href="/tags/self/" style="font-size: 15px;">self</a> <a href="/tags/super/" style="font-size: 15px;">super</a> <a href="/tags/dyld/" style="font-size: 15px;">dyld</a> <a href="/tags/runtime/" style="font-size: 15px;">runtime</a> <a href="/tags/class/" style="font-size: 15px;">class</a> <a href="/tags/object/" style="font-size: 15px;">object</a> <a href="/tags/metaclass/" style="font-size: 15px;">metaclass</a> <a href="/tags/NSObject/" style="font-size: 15px;">NSObject</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 快速通道</i></div><ul></ul><a href="https://developer.apple.com/library" title="Apple Dev" target="_blank">Apple Dev</a><ul></ul><a href="http://stackoverflow.com/" title="StackOverflow" target="_blank">StackOverflow</a><ul></ul><a href="http://www.cocoawithlove.com/" title="CocoaWithLove" target="_blank">CocoaWithLove</a><ul></ul><a href="https://www.mikeash.com/" title="MikeAsh" target="_blank">MikeAsh</a><ul></ul><a href="http://nshipster.com/" title="NSHipster" target="_blank">NSHipster</a><ul></ul><a href="https://www.objc.io/" title="Objc" target="_blank">Objc</a></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">Command+R.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/jquery.min.js?v=0.0.0"></script><script type="text/javascript" src="/js/totop.js?v=0.0.0"></script><script type="text/javascript" src="/js/fancybox.pack.js?v=0.0.0"></script><script type="text/javascript" src="/js/jquery.fancybox.js?v=0.0.0"></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/share.js?v=0.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
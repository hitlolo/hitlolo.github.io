<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Zero's Blog | iOS学习日志"><title>笔记——Runtime：Class &amp; Object | Command+R</title><link rel="stylesheet" type="text/css" href="/css/highlight/highlight.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/normalize.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/pure-min.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">笔记——Runtime：Class &amp; Object</h1><a id="logo" href="/.">Command+R</a><p class="description">Life doesn't have a ctrl-z. Type wisely.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">笔记——Runtime：Class &amp; Object</h1><div class="post-meta">Sep 15, 2015<span> | </span><span class="category"><a href="/categories/iOS/">iOS @ </a><a href="/categories/iOS/Runtime/">Runtime</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#@interface"><span class="toc-number">2.</span> <span class="toc-text">@interface</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#class_&_obejct"><span class="toc-number">3.</span> <span class="toc-text">class & obejct</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#object"><span class="toc-number">3.1.</span> <span class="toc-text">object</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class"><span class="toc-number">3.2.</span> <span class="toc-text">Class</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#isa"><span class="toc-number">3.2.1.</span> <span class="toc-text">isa</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super_class"><span class="toc-number">3.2.2.</span> <span class="toc-text">super_class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ivars"><span class="toc-number">3.2.3.</span> <span class="toc-text">ivars</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#methodLists"><span class="toc-number">3.2.4.</span> <span class="toc-text">methodLists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cache"><span class="toc-number">3.2.5.</span> <span class="toc-text">cache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#protocols"><span class="toc-number">3.2.6.</span> <span class="toc-text">protocols</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#End"><span class="toc-number">4.</span> <span class="toc-text">End</span></a></li></ol></div></div><div class="post-content"><h1 id="前言">前言</h1><p>首先，在之前关于runtime的学习中已经提到过：<br>Objective-C即面向对象的C语言，是在C的基础上给C提供了面向对象支持。<br>Objective-C在支持所有C特性的同时，将C语法进行了一个面向对象的包装。<br>比如说提供了面向对象层的数据结构：如Class，Object。<br>另外，C语言的方法调用（method call）也用消息（message sending）来包装。<br>之所以用“包装”这个词，是因为,本质上，Class、Object还是C结构体，消息传递本质还是方法调用。</p>
<hr>
<h1 id="@interface">@interface</h1><p>Objetive-C的类声明由<code>@interface</code>开始，<code>@end</code>结束。<br>虽然不知道<code>@interface</code>具体如何工作的。<br>但经过之前的一些学习，已经大概了解了编译器会对源文件做出的处理（<a href="/2015/09/04/iOS/Objective-C/runtime/iOS_objc_runtime_compiler/">笔记：关于Compiler</a>）：<br>对于本文的主题——类来说呢，编译器会将<code>@interface</code>，<code>@end</code>中的内容构造成一个C结构体，并将其信息存储在最后生成的Mach-O可执行文件中的<code>_OBJC segment</code>中的<code>__class section</code>中，最后在执行时，由loader载入对应的内存。<br>所以，从本质上来看，如果我说“<code>@interface</code>，<code>@end</code>不过是<code>typedef struct</code>的比较漂亮的写法”，我想，这一观点也并不过分。<br>当然<code>@interface</code>和<code>@end</code>显然还给了编译器一些其他信息，例如，“这是一个类声明，从哪开始的，哪结束的，将它存进<code>_OBJC segment</code>中的<code>__class section</code>中，balabala”，我猜它大概说了这些。</p>
<a id="more"></a>
<h1 id="class_&amp;_obejct">class &amp; obejct</h1><p>关于类和对象，从哪个先讲起呢。<br>鉴于一个普遍共识:对象是类的实例——这样一个从属关系来看，可能从class开始介绍比较合理。<br>但，我更想从object着手，遵循自己的脑子关于object和class的思考过程。</p>
<h2 id="object">object</h2><p>学习Objective-C的最最最开始，就是“Objective-C”这个语言名字本身：<br>Objective-C，面向对象的C，然后，第一堂课就是对象——object，那么，什么是对象。<br>教科书说：对象是类的实例。<br>我们接触到的第一个类就是<code>NSObject</code>,接着,打开runtime中<code>NSObject.h</code>可以看到NSObject是这样定义的：<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="class"><span class="keyword">interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">Class</span> <span class="title">isa</span>  <span class="title">OBJC_ISA_AVAILABILITY</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么NSObject类的实例是什么呢：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSObject* object = <span class="comment">[<span class="comment">[NSObject alloc]</span>init]</span>;</span><br></pre></td></tr></table></figure></p>
<p>这个object就是类——NSObject的实例——咱们的对象了。<br>从内存的角度来看，这个对象不过是堆中的一块区域，仅占4个字节（一个包含Class isa指针的C结构体）。<br>现在，另外声明2个类：<br><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="class"><span class="keyword">interface</span> <span class="title">IntObject</span>:NSObject</span>&#123;</span><br><span class="line">    int i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">interface</span> <span class="title">CharObject</span>:<span class="title">NSObject</span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">char</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例化之后，从内存的角度看，IntObject的对象是堆中的一块区域占8个字节，而CharObject的对象也一模一样占8个字节。2个对象在内存中都仅仅是8个字节的数据而已。<br>那么问题来了：<br><em>问题一</em><br>我们通过对象指针，仅知道对象在哪，但是却对对象的信息一无所知。<br>当处理这个对象的时候，会有很多问题：<br>我们只能如结构体指针一样来访问指向结构中的成员。可以访问i，可以访问到a，b，c，d。<br>但这不够，信息太少。如果在运行过程中，我需要知道i是什么类型呢。<br>另外，对象的属性，方法呢，NSObject对象也仅4个字节，NSObject那么多的方法在哪？<br>还有协议什么的呢？</p>
<p><em>问题二</em><br>runtime中对象的定义是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Represents an instance of a class.</span></span><br><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意到，注释里说的和教科书里一样，“这代表类的实例”。<br>除此之外，还有个<code>id</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A pointer to an instance of a class.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *id;</span><br></pre></td></tr></table></figure></p>
<p>并介绍了：1个指向类实例的指针。<br>再然后又看到这样一句话：“<code>id</code>可以指向任何对象”。<br>好吧，<code>struct objc_object</code>就是类的实例（对象），且“<code>id</code>可以指向任何对象”。但是它们其实都仅是一个占4字节的其中仅含一个指针的结构体啊。<br>为什么？为什么仅仅1个4个字节的指针就可以代表一个对象，且可以代表任何对象。单从所占内存字节来看，每个不同类的对象仅根据实例变量的不同所占字节都是不一样的，千变万化，然而为什么这4个字节的<code>Class isa</code>就可以代表任何对象了？</p>
<p>而这2个问题的答案是一样的：</p>
<p>答案都包罗在唯一已知的那4个字节里：<br>单从对象看，我们确实对对象的信息一无所知，<br>但事实是：按照Objective-C的对象的定义，我们已知且唯一已知的是每个对象前4个字节都是这样一个指针：<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">isa</span>  <span class="title">OBJC_ISA_AVAILABILITY</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>这个指针指向的就是类——class：class描述对象的所有信息。我有多大，我有哪些属性，我有哪些方法，我的方法的实现是什么，后面的内存字节中那几个字节是什么内容等等的问题的答案都在这里。<br>class的所有对象都有<code>isa</code>来指向class获取关于这些信息，共享这一份类信息。<br>对象是多个的，而说明书只需要一份，class就是这一份说明书，isa就是说明书的位置。</p>
<p>为什么这样，可以回顾下之前的笔记：<a href="/2015/09/04/iOS/Objective-C/runtime/iOS_objc_runtime_explanation/#Still_Why?">笔记——Runtime：Why runtime?</a></p>
<h2 id="Class">Class</h2><p>class是对象的原型。是其所有实例对象所共享的信息之源。<br><a href="http://opensource.apple.com/source/objc4/objc4-647/runtime/objc.h" target="_blank" rel="external">/runtime/objc.h</a>中Class的定义为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents an Objective-C class.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> !__OBJC2__</span></span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="comment">/* Use `Class` instead of `struct objc_class *` */</span></span><br></pre></td></tr></table></figure>
<p>这就是class。<br>那么，Class是一个指向objc_class结构体的指针。<br>一目了然，objc_class结构体描述了一个类的所有信息，父类，名称，信息，变量大小，变量列表，方法列表，协议列表等等。<br>可能最有趣的是：objc_class结构体中第一个数据又是指向另一个Class的isa指针。（而这关乎的是另一个话题metaclass）。</p>
<p>先不管这个isa。<br>总之，这就是类了。<br>对象存储在堆里，当我们实例一个对象时，会在堆中开辟空间存储对象。<br>类并不是实例时生成的，而是在程序加载时从可执行文件载入到内存中。<br>当在源代码中声明一个类后，编译器将每个类构造成了这样一个结构体<code>struct objc_class</code>,并将其信息存储在最后生成的Mach-O可执行文件中的<code>_OBJC segment</code>中的<code>__class section</code>中。<br>最后在加载阶段将<code>_OBJC segment</code>连同<code>__TEXT segment</code>,<code>__DATA segment</code>等一起载入内存，开始执行。<br><code>_OBJC segment</code>中存储了runtime需要的所有信息，包括class，metaclass，category，method等等。之前有过<a href="/2015/09/04/iOS/Objective-C/runtime/iOS_objc_runtime_compiler/#5：Mach-O_file">_OBJC segment的笔记。</a></p>
<p>总之：objc_class里面存储了关于类的一切。而这一切都将用于描述这个类的所有实例object。每一个已声明的类都将构造成这样一个结构存储在<code>_OBJC segment</code>中加载进内存。<br>所以在运行时，runtime其实对每一个object都已了然于胸，遇到不知道的，通过isa指向的`_OBJC segment·查查就知道了。</p>
<h3 id="isa">isa</h3><p>之前提到了，objc_class结构体中第一个数据又是指向另一个Class的isa指针。关于metaclass的东西在看看吧。<br><em><br>Edited:<br><a href="/2015/09/25/iOS/Objective-C/runtime/iOS_objc_runtime_class_metaclass/">笔记：about metaclass</a>
</em></p>
<h3 id="super_class">super_class</h3><p>显然，<code>super_class</code>也是一个指向类结构的指针，&quot;我的父类是什么？&quot;。<br>是关于面向对象的继承链的问题。当我们继承自某类时（比如按常例，我们会继承NSObject类），那么<code>super_class</code>指向父类。<br>如果存在继承，那么对象就需要2份说明书才能阐释清楚，一份是自己的类和一份是父类。<br>在自己的类里找不到的说明，就去父类里找。<br>例如：变量的信息找不到就去super_class继续进行，方法在当前对象上也缺失，那么就追溯到super_class继续进行。<br>根类(如NSObject或NSProxy)的super_class为nil。</p>
<h3 id="ivars">ivars</h3><p>对象利用<code>instance_size</code>再配合<code>struct objc_ivar_list</code>对象实例变量链表，这2个信息来揭露关于对象实例变量的一切。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> instance_size                                       OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>instance_size</code>存储了关于对象的大小信息，让我们清楚了对象在内存所占据的区域。</p>
<p>ivars指向<code>struct objc_ivar_list</code>,那么<code>objc_ivar_list</code>是什么：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_ivar_list &#123;</span><br><span class="line">    <span class="keyword">int</span> ivar_count                                           OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar ivar_list[<span class="number">1</span>]                            OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>struct objc_ivar_list</code>这个结构体描述关于class的实例变量的信息：</p>
<ul>
<li>有几个实例变量，</li>
<li>一共占用内存多大</li>
<li>一个<a href="https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html" target="_blank" rel="external">可变长的数组</a>，根据实际变量数量再进而描述每一个实例变量的信息：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">    <span class="keyword">char</span> *ivar_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">char</span> *ivar_type                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">int</span> ivar_offset                                          OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p><code>struct objc_ivar</code>描述具体某个实例变量的信息：</p>
<ul>
<li>变量名，</li>
<li>变量类型，</li>
<li>在类结构体中的地址偏移位置，</li>
<li>占用空间。</li>
</ul>
<p>有了<code>instance_size</code>，又有了总共多少实例变量，再加上每个实例变量的类型，大小和位置。这些信息足以描述对象的所有实例变量，相当于解释了对象在内存中的每一个字节的具体内容。</p>
<h3 id="methodLists">methodLists</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_method_list &#123;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list *obsolete                        OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> method_count                                         OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method method_list[<span class="number">1</span>]                        OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">&#125;                                                            OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br></pre></td></tr></table></figure>
<p><code>struct objc_method_list</code>结构体存储关于方法的所有信息：</p>
<ul>
<li>方法的总数，</li>
<li>占用空间，</li>
<li>一个可变长数组存储每一个对象方法<code>objc_method</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents a method in a class definition.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">char</span> *method_types                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>objc_method结构体描述具体单个方法：</p>
<ul>
<li>SEL（方法名），</li>
<li>method_types，方法的参数类型，返回类型</li>
<li>IMP（实现——函数指针）。</li>
</ul>
<p>当向对象发送消息时，对象实质上对自己的行为和方法也一无所知，对象通过isa找到自己的类信息，在类信息结构中<code>objc_method_list</code>存储了类的实例方法列表。对象在这里匹配对应的方法名和实现，再进行函数调用。</p>
<h3 id="cache">cache</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_cache *Cache                             OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_cache &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>                 OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line">    Method buckets[<span class="number">1</span>]                                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将原本直接的函数调用(method call)包装为消息传递（send message）后函数调用的简单方式演变为先SEL查找对应IMP，再调用IMP的过程。当方法列表庞大时，SEL和IMP的查找对应显然会成为一个耗时的工序。objc_cache正是消息传递机制中的一个优化环节。当第一次发送消息时，runtime将查找结果Method放入objc_cache的篮子（buckets）中，以加快之后该消息工作的速度。</p>
<h3 id="protocols">protocols</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_protocol_list &#123;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *next;</span><br><span class="line">    <span class="keyword">long</span> count;</span><br><span class="line">    Protocol *<span class="built_in">list</span>[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object Protocol;</span><br></pre></td></tr></table></figure>
<p>从这个定义看，似乎protocol就是一个对象啊。<br>确实是:<br><a href="http://opensource.apple.com/source/objc4/objc4-647/runtime/Protocol.h" target="_blank" rel="external">/runtime/Protocol.h</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface Protocol : Object</span><br><span class="line">&#123;</span><br><span class="line">@<span class="keyword">private</span></span><br><span class="line">    <span class="keyword">char</span> *protocol_name OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocol_list OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_description_list *instance_methods OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_description_list *class_methods OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这也正是协议可以继承的原因，因为其本质就是对象，存储了：</p>
<ul>
<li>协议名，</li>
<li>继承的协议链表，</li>
<li>实例方法信息链表，</li>
<li>类方法信息链表</li>
</ul>
<p>这意味着，每一个协议后面都有一个class描述协议的信息，不过这个class中只有协议的方法信息，没有方法实现信息。<br>方法的具体实现由遵循协议的类给出。</p>
<h1 id="End">End</h1><p>Objective-C是面向对象的语言，Objective-C的每一个对象(Object)都是一个类(Class)的实例，Class描述了对象的数据结构和行为。<br>当使用一个类实例化一个对象时，对象的isa就指向它的类。<br>为什么需要有个isa指向它的类？<br>对象(Object)在内存中占据一定空间保存自己的实例变量，但却没有自己的方法列表和自己的实例变量信息。<br>类(Class)的方法和关于类的实例变量信息是其所有对象(Object)公用的。<br>当我们向一个类的实例对象发送消息时，消息绑定机制将（利用isa）追溯到实例对象(Instance Object)的类(Class)去寻找方法。<br>当我们使用对象的实例变量时，也是isa指向的类揭示关于实例变量的类型和大小等信息。</p>
<blockquote>
<p>The compiler creates just one object, a class object, to represent the class. The class object has access to all the information about the class, which means mainly information about what instances of the class are like. It&#39;s able to produce new instances according to the plan put forward in the class definition.</p>
</blockquote>
<p>一言以蔽之：<br><em>对象持有数据（实例变量），类持有行为（方法）和数据的相关解释。</em></p>
</div><a data-url="http://www.hitlolo.com/2015/09/15/iOS/Objective-C/runtime/iOS_objc_runtime_class_object/" data-id="cim2v4zd2000s60ht1rd1ry8c" class="article-share-link">分享到</a><div class="tags"><a href="/tags/class/">class</a><a href="/tags/object/">object</a></div><div class="post-nav"><a href="/2015/09/25/iOS/Objective-C/runtime/iOS_objc_runtime_class_metaclass/" class="pre">笔记——Runtime：Class &amp; metaclass</a><a href="/2015/09/10/iOS/Objective-C/runtime/iOS_objc_runtime_compiler/" class="next">笔记——Runtime：关于Compiler</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Log/">Log</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">10</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/NSObject/">NSObject</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/Runtime/">Runtime</a><span class="category-list-count">6</span></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/self/" style="font-size: 15px;">self</a> <a href="/tags/super/" style="font-size: 15px;">super</a> <a href="/tags/runtime/" style="font-size: 15px;">runtime</a> <a href="/tags/compiler/" style="font-size: 15px;">compiler</a> <a href="/tags/class/" style="font-size: 15px;">class</a> <a href="/tags/object/" style="font-size: 15px;">object</a> <a href="/tags/metaclass/" style="font-size: 15px;">metaclass</a> <a href="/tags/NSObject/" style="font-size: 15px;">NSObject</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 快速通道</i></div><ul></ul><a href="https://developer.apple.com/library" title="Apple Dev" target="_blank">Apple Dev</a><ul></ul><a href="http://stackoverflow.com/" title="StackOverflow" target="_blank">StackOverflow</a><ul></ul><a href="http://www.cocoawithlove.com/" title="CocoaWithLove" target="_blank">CocoaWithLove</a><ul></ul><a href="https://www.mikeash.com/" title="MikeAsh" target="_blank">MikeAsh</a><ul></ul><a href="http://nshipster.com/" title="NSHipster" target="_blank">NSHipster</a><ul></ul><a href="https://www.objc.io/" title="Objc" target="_blank">Objc</a></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">Command+R.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/jquery.min.js?v=0.0.0"></script><script type="text/javascript" src="/js/totop.js?v=0.0.0"></script><script type="text/javascript" src="/js/fancybox.pack.js?v=0.0.0"></script><script type="text/javascript" src="/js/jquery.fancybox.js?v=0.0.0"></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/share.js?v=0.0.0"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>